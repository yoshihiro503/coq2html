
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Interpreter</title>
<meta name="description" content="Documentation of Coq module Interpreter" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="compcert"><summary>compcert</summary>
          <ul>
          <li><details id="compcert.backend"><summary>backend</summary>
          <ul>
          <li><a href="compcert.backend.Allocation.html">Allocation</a></li>
<li><a href="compcert.backend.Allocproof.html">Allocproof</a></li>
<li><a href="compcert.backend.Asmgenproof0.html">Asmgenproof0</a></li>
<li><a href="compcert.backend.Bounds.html">Bounds</a></li>
<li><a href="compcert.backend.CleanupLabels.html">CleanupLabels</a></li>
<li><a href="compcert.backend.CleanupLabelsproof.html">CleanupLabelsproof</a></li>
<li><a href="compcert.backend.Cminor.html">Cminor</a></li>
<li><a href="compcert.backend.CminorSel.html">CminorSel</a></li>
<li><a href="compcert.backend.Cminortyping.html">Cminortyping</a></li>
<li><a href="compcert.backend.Constprop.html">Constprop</a></li>
<li><a href="compcert.backend.Constpropproof.html">Constpropproof</a></li>
<li><a href="compcert.backend.Conventions.html">Conventions</a></li>
<li><a href="compcert.backend.CSE.html">CSE</a></li>
<li><a href="compcert.backend.CSEdomain.html">CSEdomain</a></li>
<li><a href="compcert.backend.CSEproof.html">CSEproof</a></li>
<li><a href="compcert.backend.Deadcode.html">Deadcode</a></li>
<li><a href="compcert.backend.Deadcodeproof.html">Deadcodeproof</a></li>
<li><a href="compcert.backend.Debugvar.html">Debugvar</a></li>
<li><a href="compcert.backend.Debugvarproof.html">Debugvarproof</a></li>
<li><a href="compcert.backend.Inlining.html">Inlining</a></li>
<li><a href="compcert.backend.Inliningproof.html">Inliningproof</a></li>
<li><a href="compcert.backend.Inliningspec.html">Inliningspec</a></li>
<li><a href="compcert.backend.Kildall.html">Kildall</a></li>
<li><a href="compcert.backend.Linear.html">Linear</a></li>
<li><a href="compcert.backend.Linearize.html">Linearize</a></li>
<li><a href="compcert.backend.Linearizeproof.html">Linearizeproof</a></li>
<li><a href="compcert.backend.Lineartyping.html">Lineartyping</a></li>
<li><a href="compcert.backend.Liveness.html">Liveness</a></li>
<li><a href="compcert.backend.Locations.html">Locations</a></li>
<li><a href="compcert.backend.LTL.html">LTL</a></li>
<li><a href="compcert.backend.Mach.html">Mach</a></li>
<li><a href="compcert.backend.NeedDomain.html">NeedDomain</a></li>
<li><a href="compcert.backend.Registers.html">Registers</a></li>
<li><a href="compcert.backend.Renumber.html">Renumber</a></li>
<li><a href="compcert.backend.Renumberproof.html">Renumberproof</a></li>
<li><a href="compcert.backend.RTL.html">RTL</a></li>
<li><a href="compcert.backend.RTLgen.html">RTLgen</a></li>
<li><a href="compcert.backend.RTLgenproof.html">RTLgenproof</a></li>
<li><a href="compcert.backend.RTLgenspec.html">RTLgenspec</a></li>
<li><a href="compcert.backend.RTLtyping.html">RTLtyping</a></li>
<li><a href="compcert.backend.SelectDiv.html">SelectDiv</a></li>
<li><a href="compcert.backend.SelectDivproof.html">SelectDivproof</a></li>
<li><a href="compcert.backend.Selection.html">Selection</a></li>
<li><a href="compcert.backend.Selectionproof.html">Selectionproof</a></li>
<li><a href="compcert.backend.SplitLong.html">SplitLong</a></li>
<li><a href="compcert.backend.SplitLongproof.html">SplitLongproof</a></li>
<li><a href="compcert.backend.Stacking.html">Stacking</a></li>
<li><a href="compcert.backend.Stackingproof.html">Stackingproof</a></li>
<li><a href="compcert.backend.Tailcall.html">Tailcall</a></li>
<li><a href="compcert.backend.Tailcallproof.html">Tailcallproof</a></li>
<li><a href="compcert.backend.Tunneling.html">Tunneling</a></li>
<li><a href="compcert.backend.Tunnelingproof.html">Tunnelingproof</a></li>
<li><a href="compcert.backend.Unusedglob.html">Unusedglob</a></li>
<li><a href="compcert.backend.Unusedglobproof.html">Unusedglobproof</a></li>
<li><a href="compcert.backend.ValueAnalysis.html">ValueAnalysis</a></li>
<li><a href="compcert.backend.ValueDomain.html">ValueDomain</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.cfrontend"><summary>cfrontend</summary>
          <ul>
          <li><a href="compcert.cfrontend.Cexec.html">Cexec</a></li>
<li><a href="compcert.cfrontend.Clight.html">Clight</a></li>
<li><a href="compcert.cfrontend.ClightBigstep.html">ClightBigstep</a></li>
<li><a href="compcert.cfrontend.Cminorgen.html">Cminorgen</a></li>
<li><a href="compcert.cfrontend.Cminorgenproof.html">Cminorgenproof</a></li>
<li><a href="compcert.cfrontend.Cop.html">Cop</a></li>
<li><a href="compcert.cfrontend.Csem.html">Csem</a></li>
<li><a href="compcert.cfrontend.Csharpminor.html">Csharpminor</a></li>
<li><a href="compcert.cfrontend.Cshmgen.html">Cshmgen</a></li>
<li><a href="compcert.cfrontend.Cshmgenproof.html">Cshmgenproof</a></li>
<li><a href="compcert.cfrontend.Cstrategy.html">Cstrategy</a></li>
<li><a href="compcert.cfrontend.Csyntax.html">Csyntax</a></li>
<li><a href="compcert.cfrontend.Ctypes.html">Ctypes</a></li>
<li><a href="compcert.cfrontend.Ctyping.html">Ctyping</a></li>
<li><a href="compcert.cfrontend.Initializers.html">Initializers</a></li>
<li><a href="compcert.cfrontend.Initializersproof.html">Initializersproof</a></li>
<li><a href="compcert.cfrontend.SimplExpr.html">SimplExpr</a></li>
<li><a href="compcert.cfrontend.SimplExprproof.html">SimplExprproof</a></li>
<li><a href="compcert.cfrontend.SimplExprspec.html">SimplExprspec</a></li>
<li><a href="compcert.cfrontend.SimplLocals.html">SimplLocals</a></li>
<li><a href="compcert.cfrontend.SimplLocalsproof.html">SimplLocalsproof</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.common"><summary>common</summary>
          <ul>
          <li><a href="compcert.common.AST.html">AST</a></li>
<li><a href="compcert.common.Behaviors.html">Behaviors</a></li>
<li><a href="compcert.common.Builtins.html">Builtins</a></li>
<li><a href="compcert.common.Builtins0.html">Builtins0</a></li>
<li><a href="compcert.common.Determinism.html">Determinism</a></li>
<li><a href="compcert.common.Errors.html">Errors</a></li>
<li><a href="compcert.common.Events.html">Events</a></li>
<li><a href="compcert.common.Globalenvs.html">Globalenvs</a></li>
<li><a href="compcert.common.Linking.html">Linking</a></li>
<li><a href="compcert.common.Memdata.html">Memdata</a></li>
<li><a href="compcert.common.Memory.html">Memory</a></li>
<li><a href="compcert.common.Memtype.html">Memtype</a></li>
<li><a href="compcert.common.Separation.html">Separation</a></li>
<li><a href="compcert.common.Smallstep.html">Smallstep</a></li>
<li><a href="compcert.common.Switch.html">Switch</a></li>
<li><a href="compcert.common.Unityping.html">Unityping</a></li>
<li><a href="compcert.common.Values.html">Values</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.cparser"><summary>cparser</summary>
          <ul>
          <li><a href="compcert.cparser.Cabs.html">Cabs</a></li>
<li><a href="compcert.cparser.Parser.html">Parser</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.driver"><summary>driver</summary>
          <ul>
          <li><a href="compcert.driver.Compiler.html">Compiler</a></li>
<li><a href="compcert.driver.Complements.html">Complements</a></li>
<li><a href="compcert.driver.Compopts.html">Compopts</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.lib"><summary>lib</summary>
          <ul>
          <li><a href="compcert.lib.Axioms.html">Axioms</a></li>
<li><a href="compcert.lib.BoolEqual.html">BoolEqual</a></li>
<li><a href="compcert.lib.Coqlib.html">Coqlib</a></li>
<li><a href="compcert.lib.Decidableplus.html">Decidableplus</a></li>
<li><a href="compcert.lib.Floats.html">Floats</a></li>
<li><a href="compcert.lib.FSetAVLplus.html">FSetAVLplus</a></li>
<li><a href="compcert.lib.Heaps.html">Heaps</a></li>
<li><a href="compcert.lib.IEEE754_extra.html">IEEE754_extra</a></li>
<li><a href="compcert.lib.Integers.html">Integers</a></li>
<li><a href="compcert.lib.Intv.html">Intv</a></li>
<li><a href="compcert.lib.IntvSets.html">IntvSets</a></li>
<li><a href="compcert.lib.Iteration.html">Iteration</a></li>
<li><a href="compcert.lib.Lattice.html">Lattice</a></li>
<li><a href="compcert.lib.Maps.html">Maps</a></li>
<li><a href="compcert.lib.Ordered.html">Ordered</a></li>
<li><a href="compcert.lib.Parmov.html">Parmov</a></li>
<li><a href="compcert.lib.Postorder.html">Postorder</a></li>
<li><a href="compcert.lib.UnionFind.html">UnionFind</a></li>
<li><a href="compcert.lib.Wfsimpl.html">Wfsimpl</a></li>
<li><a href="compcert.lib.Zbits.html">Zbits</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.x86"><summary>x86</summary>
          <ul>
          <li><a href="compcert.x86.Asm.html">Asm</a></li>
<li><a href="compcert.x86.Asmgen.html">Asmgen</a></li>
<li><a href="compcert.x86.Asmgenproof.html">Asmgenproof</a></li>
<li><a href="compcert.x86.Asmgenproof1.html">Asmgenproof1</a></li>
<li><a href="compcert.x86.Builtins1.html">Builtins1</a></li>
<li><a href="compcert.x86.CombineOp.html">CombineOp</a></li>
<li><a href="compcert.x86.CombineOpproof.html">CombineOpproof</a></li>
<li><a href="compcert.x86.ConstpropOp.html">ConstpropOp</a></li>
<li><a href="compcert.x86.ConstpropOpproof.html">ConstpropOpproof</a></li>
<li><a href="compcert.x86.Conventions1.html">Conventions1</a></li>
<li><a href="compcert.x86.Machregs.html">Machregs</a></li>
<li><a href="compcert.x86.NeedOp.html">NeedOp</a></li>
<li><a href="compcert.x86.Op.html">Op</a></li>
<li><a href="compcert.x86.SelectLong.html">SelectLong</a></li>
<li><a href="compcert.x86.SelectLongproof.html">SelectLongproof</a></li>
<li><a href="compcert.x86.SelectOp.html">SelectOp</a></li>
<li><a href="compcert.x86.SelectOpproof.html">SelectOpproof</a></li>
<li><a href="compcert.x86.Stacklayout.html">Stacklayout</a></li>
<li><a href="compcert.x86.ValueAOp.html">ValueAOp</a></li>
          </ul>
          </details>
          </li>
<li><details id="compcert.x86_64"><summary>x86_64</summary>
          <ul>
          <li><a href="compcert.x86_64.Archi.html">Archi</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Flocq"><summary>Flocq</summary>
          <ul>
          <li><details id="Flocq.Calc"><summary>Calc</summary>
          <ul>
          <li><a href="Flocq.Calc.Bracket.html">Bracket</a></li>
<li><a href="Flocq.Calc.Div.html">Div</a></li>
<li><a href="Flocq.Calc.Operations.html">Operations</a></li>
<li><a href="Flocq.Calc.Plus.html">Plus</a></li>
<li><a href="Flocq.Calc.Round.html">Round</a></li>
<li><a href="Flocq.Calc.Sqrt.html">Sqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Flocq.Core"><summary>Core</summary>
          <ul>
          <li><a href="Flocq.Core.Core.html">Core</a></li>
<li><a href="Flocq.Core.Defs.html">Defs</a></li>
<li><a href="Flocq.Core.Digits.html">Digits</a></li>
<li><a href="Flocq.Core.FIX.html">FIX</a></li>
<li><a href="Flocq.Core.Float_prop.html">Float_prop</a></li>
<li><a href="Flocq.Core.FLT.html">FLT</a></li>
<li><a href="Flocq.Core.FLX.html">FLX</a></li>
<li><a href="Flocq.Core.FTZ.html">FTZ</a></li>
<li><a href="Flocq.Core.Generic_fmt.html">Generic_fmt</a></li>
<li><a href="Flocq.Core.Raux.html">Raux</a></li>
<li><a href="Flocq.Core.Round_NE.html">Round_NE</a></li>
<li><a href="Flocq.Core.Round_pred.html">Round_pred</a></li>
<li><a href="Flocq.Core.Ulp.html">Ulp</a></li>
<li><a href="Flocq.Core.Zaux.html">Zaux</a></li>
          </ul>
          </details>
          </li>
<li><details id="Flocq.IEEE754"><summary>IEEE754</summary>
          <ul>
          <li><a href="Flocq.IEEE754.Binary.html">Binary</a></li>
<li><a href="Flocq.IEEE754.BinarySingleNaN.html">BinarySingleNaN</a></li>
<li><a href="Flocq.IEEE754.Bits.html">Bits</a></li>
          </ul>
          </details>
          </li>
<li><details id="Flocq.Prop"><summary>Prop</summary>
          <ul>
          <li><a href="Flocq.Prop.Div_sqrt_error.html">Div_sqrt_error</a></li>
<li><a href="Flocq.Prop.Double_rounding.html">Double_rounding</a></li>
<li><a href="Flocq.Prop.Mult_error.html">Mult_error</a></li>
<li><a href="Flocq.Prop.Plus_error.html">Plus_error</a></li>
<li><a href="Flocq.Prop.Relative.html">Relative</a></li>
<li><a href="Flocq.Prop.Round_odd.html">Round_odd</a></li>
<li><a href="Flocq.Prop.Sterbenz.html">Sterbenz</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="MenhirLib"><summary>MenhirLib</summary>
          <ul>
          <li><a href="MenhirLib.Alphabet.html">Alphabet</a></li>
<li><a href="MenhirLib.Automaton.html">Automaton</a></li>
<li><a href="MenhirLib.Grammar.html">Grammar</a></li>
<li><a href="MenhirLib.Interpreter.html">Interpreter</a></li>
<li><a href="MenhirLib.Interpreter_complete.html">Interpreter_complete</a></li>
<li><a href="MenhirLib.Interpreter_correct.html">Interpreter_correct</a></li>
<li><a href="MenhirLib.Main.html">Main</a></li>
<li><a href="MenhirLib.Validator_classes.html">Validator_classes</a></li>
<li><a href="MenhirLib.Validator_complete.html">Validator_complete</a></li>
<li><a href="MenhirLib.Validator_safe.html">Validator_safe</a></li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module Interpreter</h1>
<pre class="ssrdoc">
                                                                         
                                  Menhir                                 
                                                                         
          Jacques-Henri Jourdan, CNRS, LRI, Universit√© Paris Sud         
                                                                         
 Copyright Inria. All rights reserved. This file is distributed under    
 the terms of the GNU Lesser General Public License as published by the  
 Free Software Foundation, either version 3 of the License, or (at your  
 option) any later version, as described in the file LICENSE.            
                                                                         
</pre>
<br/>
<span class="vernacular">From</span> <span class="id">Coq</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">List</span> <span class="id">Syntax</span>.<br/>
<span class="vernacular">Import</span> <span class="id">ListNotations</span>.<br/>
<span class="vernacular">From</span> <span class="id">Coq.ssr</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">ssreflect</span>.<br/>
<span class="vernacular">Require</span> <span class="id">Automaton</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">Alphabet</span> <span class="id">Grammar</span> <span class="id">Validator_safe</span>.<br/>
<br/>
<span class="vernacular">Module</span> <span class="id">Make</span>(<span class="vernacular">Import</span> <span class="id">A:Automaton</span>.<span class="id">T</span>).<br/>
<span class="vernacular">Module</span> <span class="vernacular">Import</span> <span class="id">ValidSafe</span> <span class="id">:=</span> <span class="id">Validator_safe.Make</span> <span class="id">A</span>.<br/>
<br/>
<div class="doc">A few helpers for dependent types. </div>
<br/>
<div class="doc">Decidable propositions. </div>
<span class="vernacular">Class</span> <span class="id">Decidable</span> (<span class="id">P</span> <span class="id">:</span> <span class="gallina-kwd">Prop</span>) <span class="id">:=</span> <span class="id">decide</span> <span class="id">:</span> <span class="id">{P}</span> <span class="id">+</span> <span class="id">{~P}</span>.<br/>
<span class="vernacular">Arguments</span> <span class="id">decide</span> <span class="id">_</span> <span class="id">{_}</span>.<br/>
<br/>
<div class="doc">A <span class="bracket"><span class="id">Comparable</span></span> type has decidable equality. </div>
<span class="id">Global</span> <span class="vernacular">Instance</span> <span class="id">comparable_decidable_eq</span> <span class="id">T</span> <span class="id">`{ComparableLeibnizEq</span> <span class="id">T}</span> (<span class="id">x</span> <span class="id">y</span> <span class="id">:</span> <span class="id">T</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">Decidable</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">Decidable</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">compare</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">eqn:EQ;</span> <span class="id">[left;</span> <span class="id">apply</span> <span class="id">compare_eq;</span> <span class="id">intuition</span> <span class="id">|</span> ..<span class="id">];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right;</span> <span class="id">intros</span> <span class="id">-&gt;;</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">compare_refl</span> <span class="gallina-kwd">in</span> <span class="id">EQ</span>.<br/>
Defined.</div>
<br/>
<span class="id">Global</span> <span class="vernacular">Instance</span> <span class="id">list_decidable_eq</span> <span class="id">T</span> <span class="id">:</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">:</span> <span class="id">T,</span> <span class="id">Decidable</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">y</span>)) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> <span class="id">l1</span> <span class="id">l2</span> <span class="id">:</span> <span class="id">list</span> <span class="id">T,</span> <span class="id">Decidable</span> (<span class="id">l1</span> <span class="id">=</span> <span class="id">l2</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="id">unfold</span> <span class="id">Decidable</span>. <span class="id">decide</span> <span class="id">equality</span>. Defined.</div>
<br/>
<span class="vernacular">Ltac</span> <span class="id">subst_existT</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">repeat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">goal</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">progress</span> <span class="id">subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">H</span> <span class="id">:</span> @<span class="id">existT</span> <span class="id">?A</span> <span class="id">?P</span> <span class="id">?x</span> <span class="id">?y1</span> <span class="id">=</span> @<span class="id">existT</span> <span class="id">?A</span> <span class="id">?P</span> <span class="id">?x</span> <span class="id">?y2</span> <span class="id">|-</span> <span class="id">_</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">DEC</span> <span class="id">:=</span> <span class="id">fresh</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">DEC</span> <span class="id">:</span> <span class="gallina-kwd">forall</span> <span class="id">u1</span> <span class="id">u2</span> <span class="id">:</span> <span class="id">A,</span> <span class="id">Decidable</span> (<span class="id">u1</span> <span class="id">=</span> <span class="id">u2</span>)) <span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">_;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Eqdep_dec.inj_pair2_eq_dec</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">[|by</span> <span class="id">apply</span> <span class="id">DEC];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clear</span> <span class="id">DEC</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<div class="doc">The interpreter is written using dependent types. In order to
  avoid reducing proof terms while executing the parser, we thunk all
  the propositions behind an arrow.
  Note that thunkP is still in Prop so that it is erased by
  extraction.
 </div>
<span class="vernacular">Definition</span> <span class="id">thunkP</span> (<span class="id">P</span> <span class="id">:</span> <span class="gallina-kwd">Prop</span>) <span class="id">:</span> <span class="gallina-kwd">Prop</span> <span class="id">:=</span> <span class="id">True</span> <span class="id">-&gt;</span> <span class="id">P</span>.<br/>
<br/>
<div class="doc">Sometimes, we actually need a reduced proof in a program (for
  example when using an equality to cast a value). In that case,
  instead of reducing the proof we already have, we reprove the
  assertion by using decidability. </div>
<span class="vernacular">Definition</span> <span class="id">reprove</span> <span class="id">{P}</span> <span class="id">`{Decidable</span> <span class="id">P}</span> (<span class="id">p</span> <span class="id">:</span> <span class="id">thunkP</span> <span class="id">P</span>) <span class="id">:</span> <span class="id">P</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">decide</span> <span class="id">P</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">left</span> <span class="id">p</span> <span class="id">=&gt;</span> <span class="id">p</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">right</span> <span class="id">np</span> <span class="id">=&gt;</span> <span class="id">False_ind</span> <span class="id">_</span> (<span class="id">np</span> (<span class="id">p</span> <span class="id">I</span>))<br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<div class="doc">Combination of reprove with eq_rect. </div>
<span class="vernacular">Definition</span> <span class="id">cast</span> <span class="id">{T</span> <span class="id">:</span> <span class="id">Type}</span> (<span class="id">F</span> <span class="id">:</span> <span class="id">T</span> <span class="id">-&gt;</span> <span class="gallina-kwd">Type</span>) <span class="id">{x</span> <span class="id">y</span> <span class="id">:</span> <span class="id">T}</span> (<span class="id">eq</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{DEC</span> <span class="id">:</span> <span class="id">unit</span> <span class="id">-&gt;</span> <span class="id">Decidable</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">y</span>)<span class="id">}:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span> <span class="id">x</span> <span class="id">-&gt;</span> <span class="id">F</span> <span class="id">y</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span> <span class="id">a</span> <span class="id">=&gt;</span> <span class="id">eq_rect</span> <span class="id">x</span> <span class="id">F</span> <span class="id">a</span> <span class="id">y</span> (@<span class="id">reprove</span> <span class="id">_</span> (<span class="id">DEC</span> ()) <span class="id">eq</span>).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">cast_eq</span> <span class="id">T</span> <span class="id">F</span> (<span class="id">x</span> <span class="id">:</span> <span class="id">T</span>) (<span class="id">eq</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">x</span>)) <span class="id">`{forall</span> <span class="id">x</span> <span class="id">y,</span> <span class="id">Decidable</span> (<span class="id">x</span> <span class="id">=</span> <span class="id">y</span>)<span class="id">}</span> <span class="id">a</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">cast</span> <span class="id">F</span> <span class="id">eq</span> <span class="id">a</span> <span class="id">=</span> <span class="id">a</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/cast</span> <span class="id">-Eqdep_dec</span>.<span class="id">eq_rect_eq_dec</span>. Qed.</div>
<br/>
<div class="doc">Input buffers and operations on them. *</div>
<span class="vernacular">CoInductive</span> <span class="id">buffer</span> <span class="id">:</span> <span class="gallina-kwd">Type</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">Buf_cons</span> <span class="id">{</span> <span class="id">buf_head</span> <span class="id">:</span> <span class="id">token;</span> <span class="id">buf_tail</span> <span class="id">:</span> <span class="id">buffer</span> <span class="id">}</span>.<br/>
<br/>
<span class="vernacular">Declare</span> <span class="vernacular">Scope</span> <span class="id">buffer_scope</span>.<br/>
<span class="vernacular">Delimit</span> <span class="vernacular">Scope</span> <span class="id">buffer_scope</span> <span class="gallina-kwd">with</span> <span class="id">buf</span>.<br/>
<span class="vernacular">Bind</span> <span class="vernacular">Scope</span> <span class="id">buffer_scope</span> <span class="gallina-kwd">with</span> <span class="id">buffer</span>.<br/>
<br/>
<span class="vernacular">Infix</span> <span class="id">&quot;::&quot;</span> <span class="id">:=</span> <span class="id">Buf_cons</span> (<span class="gallina-kwd">at</span> <span class="id">level</span> <span class="id">60,</span> <span class="id">right</span> <span class="id">associativity</span>) <span class="id">:</span> <span class="id">buffer_scope</span>.<br/>
<br/>
<div class="doc">Concatenation of a list and an input buffer *</div>
<span class="vernacular">Fixpoint</span> <span class="id">app_buf</span> (<span class="id">l:list</span> <span class="id">token</span>) (<span class="id">buf:buffer</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">l</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">nil</span> <span class="id">=&gt;</span> <span class="id">buf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">cons</span> <span class="id">t</span> <span class="id">q</span> <span class="id">=&gt;</span> (<span class="id">t</span> <span class="id">::</span> <span class="id">app_buf</span> <span class="id">q</span> <span class="id">buf</span>)%<span class="id">buf</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<span class="vernacular">Infix</span> <span class="id">&quot;++&quot;</span> <span class="id">:=</span> <span class="id">app_buf</span> (<span class="gallina-kwd">at</span> <span class="id">level</span> <span class="id">60,</span> <span class="id">right</span> <span class="id">associativity</span>) <span class="id">:</span> <span class="id">buffer_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">app_buf_assoc</span> (<span class="id">l1</span> <span class="id">l2:list</span> <span class="id">token</span>) (<span class="id">buf:buffer</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;(<span class="id">l1</span> <span class="id">++</span> (<span class="id">l2</span> <span class="id">++</span> <span class="id">buf</span>) <span class="id">=</span> (<span class="id">l1</span> <span class="id">++</span> <span class="id">l2</span>) <span class="id">++</span> <span class="id">buf</span>)%<span class="id">buf</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="id">induction</span> <span class="id">l1</span> <span class="gallina-kwd">as</span> <span class="id">[|??</span> <span class="id">IH]=&gt;//=</span>. <span class="id">rewrite</span> <span class="id">IH</span> <span class="id">//</span>. Qed.</div>
<br/>
<div class="doc">The type of a non initial state: the type of semantic values associated
   with the last symbol of this state. </div>
<span class="vernacular">Definition</span> <span class="id">noninitstate_type</span> <span class="id">state</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">symbol_semantic_type</span> (<span class="id">last_symb_of_non_init_state</span> <span class="id">state</span>).<br/>
<br/>
<div class="doc">The stack of the automaton : it can be either nil or contains a non
    initial state, a semantic value for the symbol associted with this state,
    and a nested stack. *</div>
<span class="vernacular">Definition</span> <span class="id">stack</span> <span class="id">:=</span> <span class="id">list</span> (<span class="id">sigT</span> <span class="id">noninitstate_type</span>). <br/>
<br/>
<span class="vernacular">Section</span> <span class="id">Interpreter</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span> <span class="id">safe:</span> <span class="id">safe</span>.<br/>
<br/>
<span class="vernacular">Proposition</span> <span class="id">shift_head_symbs:</span> <span class="id">shift_head_symbs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">safe;</span> <span class="id">unfold</span> <span class="id">ValidSafe.safe</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">intuition</span>. Qed.</div>
<span class="vernacular">Proposition</span> <span class="id">goto_head_symbs:</span> <span class="id">goto_head_symbs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">safe;</span> <span class="id">unfold</span> <span class="id">ValidSafe.safe</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">intuition</span>. Qed.</div>
<span class="vernacular">Proposition</span> <span class="id">shift_past_state:</span> <span class="id">shift_past_state</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">safe;</span> <span class="id">unfold</span> <span class="id">ValidSafe.safe</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">intuition</span>. Qed.</div>
<span class="vernacular">Proposition</span> <span class="id">goto_past_state:</span> <span class="id">goto_past_state</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">safe;</span> <span class="id">unfold</span> <span class="id">ValidSafe.safe</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">intuition</span>. Qed.</div>
<span class="vernacular">Proposition</span> <span class="id">reduce_ok:</span> <span class="id">reduce_ok</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">safe;</span> <span class="id">unfold</span> <span class="id">ValidSafe.safe</span> <span class="gallina-kwd">in</span> <span class="id">H;</span> <span class="id">intuition</span>. Qed.</div>
<br/>
<span class="vernacular">Variable</span> <span class="id">init</span> <span class="id">:</span> <span class="id">initstate</span>.<br/>
<br/>
<div class="doc">The top state of a stack *</div>
<span class="vernacular">Definition</span> <span class="id">state_of_stack</span> (<span class="id">stack:stack</span>)<span class="id">:</span> <span class="id">state</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">stack</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">[]</span> <span class="id">=&gt;</span> <span class="id">init</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">existT</span> <span class="id">_</span> <span class="id">s</span> <span class="id">_::_</span> <span class="id">=&gt;</span> <span class="id">s</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<div class="doc">The stack of states of an automaton stack *</div>
<span class="vernacular">Definition</span> <span class="id">state_stack_of_stack</span> (<span class="id">stack:stack</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;(<span class="id">List.map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">cell:sigT</span> <span class="id">noninitstate_type</span> <span class="id">=&gt;</span> <span class="id">singleton_state_pred</span> (<span class="id">projT1</span> <span class="id">cell</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack</span> <span class="id">++</span> <span class="id">[singleton_state_pred</span> <span class="id">init]</span>)%<span class="id">list</span>.<br/>
<br/>
<div class="doc">The stack of symbols of an automaton stack *</div>
<span class="vernacular">Definition</span> <span class="id">symb_stack_of_stack</span> (<span class="id">stack:stack</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">List.map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">cell:sigT</span> <span class="id">noninitstate_type</span> <span class="id">=&gt;</span> <span class="id">last_symb_of_non_init_state</span> (<span class="id">projT1</span> <span class="id">cell</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack</span>.<br/>
<br/>
<div class="doc">The stack invariant : it basically states that the assumptions on the
    states are true. *</div>
<span class="vernacular">Inductive</span> <span class="id">stack_invariant:</span> <span class="id">stack</span> <span class="id">-&gt;</span> <span class="gallina-kwd">Prop</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">stack_invariant_constr:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> <span class="id">stack,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">prefix</span>      (<span class="id">head_symbs_of_state</span> (<span class="id">state_of_stack</span> <span class="id">stack</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">symb_stack_of_stack</span> <span class="id">stack</span>) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">prefix_pred</span> (<span class="id">head_states_of_state</span> (<span class="id">state_of_stack</span> <span class="id">stack</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">state_stack_of_stack</span> <span class="id">stack</span>) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_invariant_next</span> <span class="id">stack</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_invariant</span> <span class="id">stack</span><br/>
<span class="gallina-kwd">with</span> <span class="id">stack_invariant_next:</span> <span class="id">stack</span> <span class="id">-&gt;</span> <span class="gallina-kwd">Prop</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">stack_invariant_next_nil:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_invariant_next</span> <span class="id">[]</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">stack_invariant_next_cons:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> <span class="id">state_cur</span> <span class="id">st</span> <span class="id">stack_rec,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_invariant</span> <span class="id">stack_rec</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_invariant_next</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">state_cur</span> <span class="id">st::stack_rec</span>).<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">pop</span></span> pops some symbols from the stack. It returns the popped semantic
    values using <span class="bracket"><span class="id">sem_popped</span></span> as an accumulator and discards the popped
    states.*</div>
<span class="vernacular">Fixpoint</span> <span class="id">pop</span> (<span class="id">symbols_to_pop:list</span> <span class="id">symbol</span>) <span class="id">{A:Type}</span> (<span class="id">stk:stack</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">thunkP</span> (<span class="id">prefix</span> <span class="id">symbols_to_pop</span> (<span class="id">symb_stack_of_stack</span> <span class="id">stk</span>)) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">action:arrows_right</span> <span class="id">A</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">symbols_to_pop</span>))<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack</span> <span class="id">*</span> <span class="id">A</span>.<br/>
<span class="id">unshelve</span> <span class="id">refine</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">match</span> <span class="id">symbols_to_pop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">return</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">thunkP</span> (<span class="id">prefix</span> <span class="id">symbols_to_pop</span> (<span class="id">symb_stack_of_stack</span> <span class="id">stk</span>))) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">action:arrows_right</span> <span class="id">A</span> (<span class="id">map</span> <span class="id">_</span> <span class="id">symbols_to_pop</span>))<span class="id">,</span> <span class="id">stack</span> <span class="id">*</span> <span class="id">A</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">[]</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">action</span> <span class="id">=&gt;</span> (<span class="id">stk,</span> <span class="id">action</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">t::q</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hp</span> <span class="id">action</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">stk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">return</span> <span class="id">thunkP</span> (<span class="id">prefix</span> (<span class="id">t::q</span>) (<span class="id">symb_stack_of_stack</span> <span class="id">stk</span>)) <span class="id">-&gt;</span> <span class="id">stack</span> <span class="id">*</span> <span class="id">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">existT</span> <span class="id">_</span> <span class="id">state_cur</span> <span class="id">sem::stack_rec</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hp</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">sem_conv</span> <span class="id">:=</span> <span class="id">cast</span> <span class="id">symbol_semantic_type</span> <span class="id">_</span> <span class="id">sem</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pop</span> <span class="id">q</span> <span class="id">_</span> <span class="id">stack_rec</span> <span class="id">_</span> (<span class="id">action</span> <span class="id">sem_conv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">[]</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hp</span> <span class="id">=&gt;</span> <span class="id">False_rect</span> <span class="id">_</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span> <span class="id">Hp</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
&nbsp;&nbsp;<span class="id">-</span> <span class="id">simpl</span> <span class="gallina-kwd">in</span> <span class="id">Hp</span>. <span class="id">clear</span> <span class="id">-Hp</span>. <span class="id">abstract</span> (<span class="id">intros</span> <span class="id">_</span> <span class="id">;</span> <span class="id">specialize</span> (<span class="id">Hp</span> <span class="id">I</span>)<span class="id">;</span> <span class="id">now</span> <span class="id">inversion</span> <span class="id">Hp</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">clear</span> <span class="id">-Hp</span>. <span class="id">abstract</span> (<span class="id">specialize</span> (<span class="id">Hp</span> <span class="id">I</span>)<span class="id">;</span> <span class="id">now</span> <span class="id">inversion</span> <span class="id">Hp</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">simpl</span> <span class="gallina-kwd">in</span> <span class="id">Hp</span>. <span class="id">clear</span> <span class="id">-Hp</span>. <span class="id">abstract</span> (<span class="id">intros</span> <span class="id">_</span> <span class="id">;</span> <span class="id">specialize</span> (<span class="id">Hp</span> <span class="id">I</span>)<span class="id">;</span> <span class="id">now</span> <span class="id">inversion</span> <span class="id">Hp</span>).<br/>
Defined.</div>
<br/>
<span class="vernacular">Inductive</span> <span class="id">pop_spec</span> <span class="id">{A:Type}</span> <span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">symbols_to_pop:list</span> <span class="id">symbol</span>) (<span class="id">stk</span> <span class="id">:</span> <span class="id">stack</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">action</span> <span class="id">:</span> <span class="id">arrows_right</span> <span class="id">A</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">symbols_to_pop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stk'</span> <span class="id">:</span> <span class="id">stack</span>) (<span class="id">sem</span> <span class="id">:</span> <span class="id">A</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">Prop</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Nil_pop_spec</span> <span class="id">stk</span> <span class="id">sem</span> <span class="id">:</span> <span class="id">pop_spec</span> <span class="id">[]</span> <span class="id">stk</span> <span class="id">sem</span> <span class="id">stk</span> <span class="id">sem</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Cons_pop_spec</span> <span class="id">symbols_to_pop</span> <span class="id">st</span> <span class="id">stk</span> <span class="id">action</span> <span class="id">sem</span> <span class="id">stk'</span> <span class="id">res</span> <span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pop_spec</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> (<span class="id">action</span> <span class="id">sem</span>) <span class="id">stk'</span> <span class="id">res</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pop_spec</span> (<span class="id">last_symb_of_non_init_state</span> <span class="id">st::symbols_to_pop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">existT</span> <span class="id">_</span> <span class="id">st</span> <span class="id">sem</span> <span class="id">::</span> <span class="id">stk</span>) <span class="id">action</span> <span class="id">stk'</span> <span class="id">res</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">pop_spec_ok</span> <span class="id">{A:Type}</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">action</span> <span class="id">stk'</span> <span class="id">res:</span><br/>
&nbsp;&nbsp;<span class="id">pop</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">action</span> <span class="id">=</span> (<span class="id">stk',</span> <span class="id">res</span>) <span class="id">&lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">pop_spec</span> (<span class="id">A:=A</span>) <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">action</span> <span class="id">stk'</span> <span class="id">res</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">action</span>.<br/>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">symbols_to_pop</span> <span class="gallina-kwd">as</span> <span class="id">[|t</span> <span class="id">symbols_to_pop</span> <span class="id">IH]=&gt;stk</span> <span class="id">Hp</span> <span class="id">action</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span> <span class="id">[=</span> <span class="id">&lt;-</span> <span class="id">&lt;-]</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span> <span class="id">H</span>. <span class="id">inversion</span> <span class="id">H</span>. <span class="gallina-kwd">by</span> <span class="id">subst_existT</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">destruct</span> <span class="id">stk</span> <span class="gallina-kwd">as</span> <span class="id">[|[st</span> <span class="id">sem]]=&gt;/=;</span> <span class="id">[by</span> <span class="id">destruct</span> <span class="id">pop_subproof0|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">pop_subproof</span> <span class="id">t</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">st</span> <span class="id">Hp</span>) <span class="gallina-kwd">as</span> <span class="id">EQ</span> <span class="id">eqn:eq</span>. <span class="id">clear</span> <span class="id">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">generalize</span> <span class="id">EQ</span>. <span class="id">revert</span> <span class="id">Hp</span> <span class="id">action</span>. <span class="id">rewrite</span> <span class="id">&lt;-</span>(<span class="id">EQ</span> <span class="id">I</span>)<span class="id">=&gt;Hp</span> <span class="id">action</span> <span class="id">?</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">cast_eq</span>. <span class="id">rewrite</span> <span class="id">IH</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span>. <span class="gallina-kwd">by</span> <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span> <span class="id">H</span>. <span class="id">inversion</span> <span class="id">H</span>. <span class="gallina-kwd">by</span> <span class="id">subst_existT</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">pop_preserves_invariant</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">action</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">stack_invariant</span> <span class="id">stk</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">stack_invariant</span> (<span class="id">fst</span> (<span class="id">pop</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> (<span class="id">A:=A</span>) <span class="id">action</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">action</span>. <span class="id">induction</span> <span class="id">symbols_to_pop</span> <span class="gallina-kwd">as</span> <span class="id">[|t</span> <span class="id">q</span> <span class="id">IH]=&gt;//=</span>.<br/>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">action</span> <span class="id">Hi</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">Hi</span> <span class="gallina-kwd">as</span> <span class="id">[stack</span> <span class="id">Hp'</span> <span class="id">Hpp</span> <span class="id">[|state</span> <span class="id">st</span> <span class="id">stk']]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">destruct</span> <span class="id">pop_subproof0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">now</span> <span class="id">apply</span> <span class="id">IH</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">pop_state_valid</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">action</span> <span class="id">lpred</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">prefix_pred</span> <span class="id">lpred</span> (<span class="id">state_stack_of_stack</span> <span class="id">stk</span>) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">stk'</span> <span class="id">:=</span> <span class="id">fst</span> (<span class="id">pop</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> (<span class="id">A:=A</span>) <span class="id">action</span>) <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">state_valid_after_pop</span> (<span class="id">state_of_stack</span> <span class="id">stk'</span>) <span class="id">symbols_to_pop</span> <span class="id">lpred</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">action</span> <span class="id">lpred</span>. <span class="id">induction</span> <span class="id">symbols_to_pop</span> <span class="gallina-kwd">as</span> <span class="id">[|t</span> <span class="id">q</span> <span class="id">IH]=&gt;/=</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">intros</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">a</span> <span class="id">lpred</span> <span class="id">Hpp</span>. <span class="id">destruct</span> <span class="id">lpred</span> <span class="gallina-kwd">as</span> <span class="id">[|pred</span> <span class="id">lpred];</span> <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inversion</span> <span class="id">Hpp</span> <span class="gallina-kwd">as</span> <span class="id">[|?</span> <span class="id">lpred'</span> <span class="id">?</span> <span class="id">pred'</span> <span class="id">Himpl</span> <span class="id">Hpp'</span> <span class="id">eq1</span> <span class="id">eq2];</span> <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">Himpl</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">pred'</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>)) <span class="gallina-kwd">as</span> <span class="id">[]</span> <span class="id">eqn:Heqpred'=&gt;//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">stk</span> <span class="gallina-kwd">as</span> <span class="id">[|[]];</span> <span class="id">simpl</span> <span class="gallina-kwd">in</span> <span class="id">*</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">inversion</span> <span class="id">eq2;</span> <span class="id">subst;</span> <span class="id">clear</span> <span class="id">eq2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">singleton_state_pred</span> <span class="gallina-kwd">in</span> <span class="id">Heqpred'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">now</span> <span class="id">rewrite</span> <span class="id">compare_refl</span> <span class="gallina-kwd">in</span> <span class="id">Heqpred';</span> <span class="id">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">inversion</span> <span class="id">eq2;</span> <span class="id">subst;</span> <span class="id">clear</span> <span class="id">eq2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">singleton_state_pred</span> <span class="gallina-kwd">in</span> <span class="id">Heqpred'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">now</span> <span class="id">rewrite</span> <span class="id">compare_refl</span> <span class="gallina-kwd">in</span> <span class="id">Heqpred';</span> <span class="id">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">intros</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">A</span> <span class="id">a</span> <span class="id">lpred</span> <span class="id">Hpp</span>. <span class="id">destruct</span> <span class="id">stk</span> <span class="gallina-kwd">as</span> <span class="id">[|[]</span> <span class="id">stk]=&gt;//=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">destruct</span> <span class="id">pop_subproof0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">destruct</span> <span class="id">lpred</span> <span class="gallina-kwd">as</span> <span class="id">[|pred</span> <span class="id">lpred];</span> <span class="id">[by</span> <span class="id">constructor|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">apply</span> <span class="id">IH</span>. <span class="gallina-kwd">by</span> <span class="id">inversion</span> <span class="id">Hpp</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">step_result</span></span> represents the result of one step of the automaton : it can
    fail, accept or progress. <span class="bracket"><span class="id">Fail_sr</span></span> means that the input is incorrect.
    <span class="bracket"><span class="id">Accept_sr</span></span> means that this is the last step of the automaton, and it
    returns the semantic value of the input word. <span class="bracket"><span class="id">Progress_sr</span></span> means that
    some progress has been made, but new steps are needed in order to accept
    a word.
    For <span class="bracket"><span class="id">Accept_sr</span></span> and <span class="bracket"><span class="id">Progress_sr</span></span>, the result contains the new input buffer.
    <span class="bracket"><span class="id">Fail_sr</span></span> means that the input word is rejected by the automaton. It is
    different to <span class="bracket"><span class="id">Err</span></span> (from the error monad), which mean that the automaton is
    bogus and has perfomed a forbidden action. *</div>
<span class="vernacular">Inductive</span> <span class="id">step_result</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Fail_sr_full:</span> <span class="id">state</span> <span class="id">-&gt;</span> <span class="id">token</span> <span class="id">-&gt;</span> <span class="id">step_result</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Accept_sr:</span> <span class="id">symbol_semantic_type</span> (<span class="id">NT</span> (<span class="id">start_nt</span> <span class="id">init</span>)) <span class="id">-&gt;</span> <span class="id">buffer</span> <span class="id">-&gt;</span> <span class="id">step_result</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Progress_sr:</span> <span class="id">stack</span> <span class="id">-&gt;</span> <span class="id">buffer</span> <span class="id">-&gt;</span> <span class="id">step_result</span>.<br/>
<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">reduce_step</span></span> does a reduce action :
   - pops some elements from the stack
   - execute the action of the production
   - follows the goto for the produced non terminal symbol *</div>
<span class="vernacular">Definition</span> <span class="id">reduce_step</span> <span class="id">stk</span> <span class="id">prod</span> (<span class="id">buffer</span> <span class="id">:</span> <span class="id">buffer</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hval</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">valid_for_reduce</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>) <span class="id">prod</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hi</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">stack_invariant</span> <span class="id">stk</span>))<br/>
&nbsp;&nbsp;<span class="id">:</span> <span class="id">step_result</span>.<br/>
<span class="id">refine</span><br/>
&nbsp;&nbsp;((<span class="gallina-kwd">let</span> <span class="id">'</span>(<span class="id">stk',</span> <span class="id">sem</span>) <span class="gallina-kwd">as</span> <span class="id">ss</span> <span class="id">:=</span> <span class="id">pop</span> (<span class="id">prod_rhs_rev</span> <span class="id">prod</span>) <span class="id">stk</span> <span class="id">_</span> (<span class="id">prod_action</span> <span class="id">prod</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">return</span> <span class="id">thunkP</span> (<span class="id">state_valid_after_pop</span> (<span class="id">state_of_stack</span> (<span class="id">fst</span> <span class="id">ss</span>)) <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">head_states_of_state</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>))) <span class="id">-&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">in</span> <span class="gallina-kwd">fun</span> <span class="id">Hval'</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">goto_table</span> (<span class="id">state_of_stack</span> <span class="id">stk'</span>) (<span class="id">prod_lhs</span> <span class="id">prod</span>) <span class="gallina-kwd">as</span> <span class="id">goto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">return</span> (<span class="id">thunkP</span> (<span class="id">goto</span> <span class="id">=</span> <span class="id">None</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">state_of_stack</span> <span class="id">stk'</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Init</span> <span class="id">i</span> <span class="id">=&gt;</span> <span class="id">prod_lhs</span> <span class="id">prod</span> <span class="id">=</span> <span class="id">start_nt</span> <span class="id">i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Ninit</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span>)) <span class="id">-&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> <span class="id">state_new</span> <span class="id">e</span>) <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">sem</span> <span class="id">:=</span> <span class="id">eq_rect</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sem</span> <span class="id">_</span> <span class="id">e</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Progress_sr</span> (<span class="id">existT</span> <span class="id">noninitstate_type</span> <span class="id">state_new</span> <span class="id">sem::stk'</span>) <span class="id">buffer</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">None</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hval</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">sem</span> <span class="id">:=</span> <span class="id">cast</span> <span class="id">symbol_semantic_type</span> <span class="id">_</span> <span class="id">sem</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Accept_sr</span> <span class="id">sem</span> <span class="id">buffer</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span> (<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">_</span>))<br/>
&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">pop_state_valid</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
&nbsp;&nbsp;<span class="id">-</span> <span class="id">clear</span> <span class="id">-Hi</span> <span class="id">Hval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstract</span> (<span class="id">intros</span> <span class="id">_;</span> <span class="id">destruct</span> <span class="id">Hi=&gt;//;</span> <span class="id">eapply</span> <span class="id">prefix_trans;</span> <span class="id">[by</span> <span class="id">apply</span> <span class="id">Hval|eassumption]</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">clear</span> <span class="id">-Hval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstract</span> (<span class="id">intros</span> <span class="id">_;</span> <span class="id">f_equal;</span> <span class="id">specialize</span> (<span class="id">Hval</span> <span class="id">I</span> <span class="id">eq_refl</span>)<span class="id">;</span> <span class="id">destruct</span> <span class="id">stk'</span> <span class="gallina-kwd">as</span> <span class="id">[|[]]=&gt;//</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">simpl</span> <span class="gallina-kwd">in</span> <span class="id">Hval'</span>. <span class="id">clear</span> <span class="id">-Hval</span> <span class="id">Hval'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstract</span> (<span class="id">move</span> <span class="id">:</span> <span class="id">Hval</span> <span class="id">=&gt;</span> <span class="id">/</span>(<span class="id">_</span> <span class="id">I</span>) <span class="id">[_</span> <span class="id">/</span>(<span class="id">_</span> <span class="id">_</span> (<span class="id">Hval'</span> <span class="id">I</span>))<span class="id">]</span> <span class="id">Hval2</span> <span class="id">Hgoto;</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">Hgoto</span> <span class="gallina-kwd">in</span> <span class="id">Hval2</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">clear</span> <span class="id">-Hi</span>. <span class="id">abstract</span> <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">Hi</span>.<br/>
Defined.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">reduce_step_stack_invariant_preserved</span> <span class="id">stk</span> <span class="id">prod</span> <span class="id">buffer</span> <span class="id">Hv</span> <span class="id">Hi</span> <span class="id">stk'</span> <span class="id">buffer':</span><br/>
&nbsp;&nbsp;<span class="id">reduce_step</span> <span class="id">stk</span> <span class="id">prod</span> <span class="id">buffer</span> <span class="id">Hv</span> <span class="id">Hi</span> <span class="id">=</span> <span class="id">Progress_sr</span> <span class="id">stk'</span> <span class="id">buffer'</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">stack_invariant</span> <span class="id">stk'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">reduce_step</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">goal</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">|-</span> <span class="id">context</span> <span class="id">[pop</span> <span class="id">?symbols_to_pop</span> <span class="id">stk</span> <span class="id">?Hp</span> <span class="id">?action]</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">Hi':=pop_preserves_invariant</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">_</span> <span class="id">action</span> (<span class="id">Hi</span> <span class="id">I</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">generalize</span> (<span class="id">pop_state_valid</span> <span class="id">symbols_to_pop</span> <span class="id">stk</span> <span class="id">Hp</span> <span class="id">_</span> <span class="id">action</span>)<br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">pop</span> <span class="gallina-kwd">as</span> <span class="id">[stk0</span> <span class="id">sem]=&gt;/=</span>. <span class="id">simpl</span> <span class="gallina-kwd">in</span> <span class="id">Hi'</span>. <span class="id">intros</span> <span class="id">Hv'</span>.<br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">Hgoto1:=goto_head_symbs</span> (<span class="id">state_of_stack</span> <span class="id">stk0</span>) (<span class="id">prod_lhs</span> <span class="id">prod</span>)).<br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">Hgoto2:=goto_past_state</span> (<span class="id">state_of_stack</span> <span class="id">stk0</span>) (<span class="id">prod_lhs</span> <span class="id">prod</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">goal</span> <span class="gallina-kwd">with</span> <span class="id">|</span> <span class="id">|-</span> <span class="id">context</span> <span class="id">[fun</span> <span class="id">_</span> <span class="id">:</span> <span class="id">True</span> <span class="id">=&gt;</span> <span class="id">?X]</span> <span class="id">=&gt;</span> <span class="id">generalize</span> <span class="id">X</span> <span class="gallina-kwd">end</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">goto_table</span> <span class="gallina-kwd">as</span> <span class="id">[[state_new</span> <span class="id">e]|]</span> <span class="id">eqn:EQgoto=&gt;//</span>.<br/>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">_</span> <span class="id">[=</span> <span class="id">&lt;-</span> <span class="id">&lt;-]</span>. <span class="id">constructor=&gt;/=</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">constructor</span>. <span class="id">eapply</span> <span class="id">prefix_trans</span>. <span class="id">apply</span> <span class="id">Hgoto1</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">Hi'</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">unfold</span> <span class="id">state_stack_of_stack;</span> <span class="id">simpl;</span> <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span> <span class="id">?</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">singleton_state_pred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">eapply</span> <span class="id">prefix_pred_trans</span>. <span class="id">apply</span> <span class="id">Hgoto2</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">Hi'</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="doc">One step of parsing. *</div>
<span class="vernacular">Definition</span> <span class="id">step</span> <span class="id">stk</span> <span class="id">buffer</span> (<span class="id">Hi</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">stack_invariant</span> <span class="id">stk</span>))<span class="id">:</span> <span class="id">step_result</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">action_table</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>) <span class="gallina-kwd">as</span> <span class="id">a</span> <span class="gallina-kwd">return</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">thunkP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">a</span> <span class="gallina-kwd">return</span> <span class="gallina-kwd">Prop</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Default_reduce_act</span> <span class="id">prod</span> <span class="id">=&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Lookahead_act</span> <span class="id">awt</span> <span class="id">=&gt;</span> <span class="gallina-kwd">forall</span> <span class="id">t</span> <span class="id">:</span> <span class="id">terminal,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">awt</span> <span class="id">t</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Reduce_act</span> <span class="id">p</span> <span class="id">=&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span> <span class="id">-&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Default_reduce_act</span> <span class="id">prod</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hv</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reduce_step</span> <span class="id">stk</span> <span class="id">prod</span> <span class="id">buffer</span> <span class="id">Hv</span> <span class="id">Hi</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Lookahead_act</span> <span class="id">awt</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hv</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">buf_head</span> <span class="id">buffer</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">tok</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">awt</span> (<span class="id">token_term</span> <span class="id">tok</span>) <span class="gallina-kwd">as</span> <span class="id">a</span> <span class="gallina-kwd">return</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">thunkP</span> <span class="gallina-kwd">match</span> <span class="id">a</span> <span class="gallina-kwd">return</span> <span class="gallina-kwd">Prop</span> <span class="gallina-kwd">with</span> <span class="id">Reduce_act</span> <span class="id">p</span> <span class="id">=&gt;</span> <span class="id">_</span> <span class="id">|</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">_</span> <span class="gallina-kwd">end</span> <span class="id">-&gt;</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Shift_act</span> <span class="id">state_new</span> <span class="id">e</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">sem_conv</span> <span class="id">:=</span> <span class="id">eq_rect</span> <span class="id">_</span> <span class="id">symbol_semantic_type</span> (<span class="id">token_sem</span> <span class="id">tok</span>) <span class="id">_</span> <span class="id">e</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Progress_sr</span> (<span class="id">existT</span> <span class="id">noninitstate_type</span> <span class="id">state_new</span> <span class="id">sem_conv::stk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">buf_tail</span> <span class="id">buffer</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Reduce_act</span> <span class="id">prod</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">Hv</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reduce_step</span> <span class="id">stk</span> <span class="id">prod</span> <span class="id">buffer</span> <span class="id">Hv</span> <span class="id">Hi</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Fail_act</span> <span class="id">=&gt;</span> <span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Fail_sr_full</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>) <span class="id">tok</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span> (<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">Hv</span> <span class="id">I</span> (<span class="id">token_term</span> <span class="id">tok</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span> (<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">reduce_ok</span> <span class="id">_</span>).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">step_stack_invariant_preserved</span> <span class="id">stk</span> <span class="id">buffer</span> <span class="id">Hi</span> <span class="id">stk'</span> <span class="id">buffer':</span><br/>
&nbsp;&nbsp;<span class="id">step</span> <span class="id">stk</span> <span class="id">buffer</span> <span class="id">Hi</span> <span class="id">=</span> <span class="id">Progress_sr</span> <span class="id">stk'</span> <span class="id">buffer'</span> <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">stack_invariant</span> <span class="id">stk'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">step</span>.<br/>
&nbsp;&nbsp;<span class="id">generalize</span> (<span class="id">reduce_ok</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>))<span class="id">=&gt;Hred</span>.<br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">Hshift1</span> <span class="id">:=</span> <span class="id">shift_head_symbs</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>)).<br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">Hshift2</span> <span class="id">:=</span> <span class="id">shift_past_state</span> (<span class="id">state_of_stack</span> <span class="id">stk</span>)).<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">action_table</span> <span class="gallina-kwd">as</span> <span class="id">[prod|awt]=&gt;/=</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">eauto</span> <span class="gallina-kwd">using</span> <span class="id">reduce_step_stack_invariant_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span> <span class="id">set</span> (<span class="id">term</span> <span class="id">:=</span> <span class="id">token_term</span> (<span class="id">buf_head</span> <span class="id">buffer</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">generalize</span> (<span class="id">Hred</span> <span class="id">term</span>). <span class="id">clear</span> <span class="id">Hred</span>. <span class="id">intros</span> <span class="id">Hred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">Hshift1</span> <span class="id">term</span>). <span class="id">specialize</span> (<span class="id">Hshift2</span> <span class="id">term</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">awt</span> <span class="id">term</span>) <span class="gallina-kwd">as</span> <span class="id">[state_new</span> <span class="id">e|prod|]=&gt;//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">intros</span> <span class="id">[=</span> <span class="id">&lt;-</span> <span class="id">&lt;-]</span>. <span class="id">constructor=&gt;/=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span> <span class="id">constructor</span>. <span class="id">eapply</span> <span class="id">prefix_trans</span>. <span class="id">apply</span> <span class="id">Hshift1</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">Hi</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span> <span class="id">unfold</span> <span class="id">state_stack_of_stack;</span> <span class="id">simpl;</span> <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">--</span> <span class="id">intros</span> <span class="id">?</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">singleton_state_pred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">--</span> <span class="id">eapply</span> <span class="id">prefix_pred_trans</span>. <span class="id">apply</span> <span class="id">Hshift2</span>. <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">Hi</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span> <span class="id">constructor;</span> <span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">Hi</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span> <span class="id">eauto</span> <span class="gallina-kwd">using</span> <span class="id">reduce_step_stack_invariant_preserved</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The parsing use a <span class="bracket"><span class="id">nat</span></span> fuel parameter <span class="bracket"><span class="id">log_n_steps</span></span>, so that we
    do not have to prove terminaison, which is difficult.
    Note that <span class="bracket"><span class="id">log_n_steps</span></span> is *not* the fuel in the conventionnal
    sense: this parameter contains the logarithm (in base 2) of the
    number of steps to perform. Hence, a value of, e.g., 50 will
    usually be enough to ensure termination. </div>
<span class="vernacular">Fixpoint</span> <span class="id">parse_fix</span> <span class="id">stk</span> <span class="id">buffer</span> (<span class="id">log_n_steps</span> <span class="id">:</span> <span class="id">nat</span>) (<span class="id">Hi</span> <span class="id">:</span> <span class="id">thunkP</span> (<span class="id">stack_invariant</span> <span class="id">stk</span>))<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">{</span> <span class="id">sr</span> <span class="id">:</span> <span class="id">step_result</span> <span class="id">|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> <span class="id">stk'</span> <span class="id">buffer',</span> <span class="id">sr</span> <span class="id">=</span> <span class="id">Progress_sr</span> <span class="id">stk'</span> <span class="id">buffer'</span> <span class="id">-&gt;</span> <span class="id">stack_invariant</span> <span class="id">stk'</span> <span class="id">}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">log_n_steps</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">O</span> <span class="id">=&gt;</span> <span class="id">exist</span> <span class="id">_</span> (<span class="id">step</span> <span class="id">stk</span> <span class="id">buffer</span> <span class="id">Hi</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">step_stack_invariant_preserved</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hi</span>)<br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">S</span> <span class="id">log_n_steps</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">match</span> <span class="id">parse_fix</span> <span class="id">stk</span> <span class="id">buffer</span> <span class="id">log_n_steps</span> <span class="id">Hi</span> <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">exist</span> <span class="id">_</span> (<span class="id">Progress_sr</span> <span class="id">stk</span> <span class="id">buffer</span>) <span class="id">Hi'</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_fix</span> <span class="id">stk</span> <span class="id">buffer</span> <span class="id">log_n_steps</span> (<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">Hi'</span> <span class="id">_</span> <span class="id">buffer</span> <span class="id">eq_refl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">sr</span> <span class="id">=&gt;</span> <span class="id">sr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<div class="doc">The final result of a parsing is either a failure (the automaton
    has rejected the input word), either a timeout (the automaton has
    spent all the given <span class="bracket">2^<span class="id">log_n_steps</span></span>), either a parsed semantic value
    with a rest of the input buffer.
    Note that we do not make parse_result depend on start_nt for the
    result type, so that this inductive is extracted without the use
    of Obj.t in OCaml.  *</div>
<span class="vernacular">Inductive</span> <span class="id">parse_result</span> <span class="id">{A</span> <span class="id">:</span> <span class="id">Type}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Fail_pr_full:</span> <span class="id">state</span> <span class="id">-&gt;</span> <span class="id">token</span> <span class="id">-&gt;</span> <span class="id">parse_result</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Timeout_pr:</span> <span class="id">parse_result</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Parsed_pr:</span> <span class="id">A</span> <span class="id">-&gt;</span> <span class="id">buffer</span> <span class="id">-&gt;</span> <span class="id">parse_result</span>.<br/>
<span class="id">Global</span> <span class="vernacular">Arguments</span> <span class="id">parse_result</span> <span class="id">_</span> <span class="id">:</span> <span class="id">clear</span> <span class="id">implicits</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">parse</span> (<span class="id">buffer</span> <span class="id">:</span> <span class="id">buffer</span>) (<span class="id">log_n_steps</span> <span class="id">:</span> <span class="id">nat</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">parse_result</span> (<span class="id">symbol_semantic_type</span> (<span class="id">NT</span> (<span class="id">start_nt</span> <span class="id">init</span>))).<br/>
<span class="id">refine</span> (<span class="gallina-kwd">match</span> <span class="id">proj1_sig</span> (<span class="id">parse_fix</span> <span class="id">[]</span> <span class="id">buffer</span> <span class="id">log_n_steps</span> <span class="id">_</span>) <span class="gallina-kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Fail_sr_full</span> <span class="id">st</span> <span class="id">tok</span> <span class="id">=&gt;</span> <span class="id">Fail_pr_full</span> <span class="id">st</span> <span class="id">tok</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Accept_sr</span> <span class="id">sem</span> <span class="id">buffer'</span> <span class="id">=&gt;</span> <span class="id">Parsed_pr</span> <span class="id">sem</span> <span class="id">buffer'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span> <span class="id">Progress_sr</span> <span class="id">_</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">Timeout_pr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">end</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
&nbsp;&nbsp;<span class="id">abstract</span> (<span class="id">repeat</span> <span class="id">constructor;</span> <span class="id">intros;</span> <span class="gallina-kwd">by</span> <span class="id">destruct</span> <span class="id">singleton_state_pred</span>).<br/>
Defined.</div>
<br/>
<span class="vernacular">End</span> <span class="id">Interpreter</span>.<br/>
<br/>
<span class="vernacular">Arguments</span> <span class="id">Fail_sr_full</span> <span class="id">{init}</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="vernacular">Arguments</span> <span class="id">Accept_sr</span> <span class="id">{init}</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="vernacular">Arguments</span> <span class="id">Progress_sr</span> <span class="id">{init}</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">Fail_sr</span> <span class="id">:=</span> (<span class="id">Fail_sr_full</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">Fail_pr</span> <span class="id">:=</span> (<span class="id">Fail_pr_full</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="vernacular">End</span> <span class="id">Make</span>.<br/>
<br/>
<span class="vernacular">Module</span> <span class="gallina-kwd">Type</span> <span class="id">T</span>(<span class="id">A:Automaton</span>.<span class="id">T</span>).<br/>
&nbsp;&nbsp;<span class="vernacular">Include</span> (<span class="id">Make</span> <span class="id">A</span>).<br/>
<span class="vernacular">End</span> <span class="id">T</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
