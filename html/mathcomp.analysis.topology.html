
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.topology</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.topology" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module mathcomp.analysis.topology</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">all_ssreflect</span> <span class="id">all_algebra</span> <span class="id">finmap</span> <span class="id">generic_quotient</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.boolp.html">boolp</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html">classical_sets</a></span> <span class="id"><a href="mathcomp.classical.functions.html">functions</a></span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.cardinality.html">cardinality</a></span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></span> <span class="id"><a href="mathcomp.classical.fsbigop.html">fsbigop</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.reals.html">reals</a></span> <span class="id"><a href="mathcomp.analysis.signed.html">signed</a></span>.<br/>
<br/>
<pre>
(******************************************************************************)
(*                  Filters and basic topological notions                     *)
(*                                                                            *)
(* This file develops tools for the manipulation of filters and basic         *)
(* topological notions. The development of topological notions builds on      *)
(* "filtered types". They are types equipped with an interface that           *)
(* associates to each element a set of sets, intended to represent a filter.  *)
(* The notions of limit and convergence are defined for filtered types and in *)
(* the documentation below we call "canonical filter" of an element the set   *)
(* of sets associated to it by the interface of filtered types.               *)
(*                                                                            *)
(*                 monotonous A f := {in A &amp;, {mono f : x y / x &lt;= y}} \/     *)
(*                                   {in A &amp;, {mono f : x y /~ x &lt;= y}}.      *)
(*                                                                            *)
(* * Filters :                                                                *)
(*                   filteredType U == interface type for types whose         *)
(*                                     elements represent sets of sets on U.  *)
(*                                     These sets are intended to be filters  *)
(*                                     on U but this is not enforced yet.     *)
(*               FilteredType U T m == packs the function m: T -&gt; set (set U) *)
(*                                     to build a filtered type of type       *)
(*                                     filteredType U; T must have a          *)
(*                                     pointedType structure.                 *)
(*     [filteredType U of T for cT] == T-clone of the filteredType U          *)
(*                                     structure cT.                          *)
(*            [filteredType U of T] == clone of a canonical structure of      *)
(*                                     filteredType U on T.                   *)
(*              Filtered.source Y Z == structure that records types X such    *)
(*                                     that there is a function mapping       *)
(*                                     functions of type X -&gt; Y to filters on *)
(*                                     Z. Allows to infer the canonical       *)
(*                                     filter associated to a function by     *)
(*                                     looking at its source type.            *)
(*                Filtered.Source F == if F : (X -&gt; Y) -&gt; set (set Z), packs  *)
(*                                     X with F in a Filtered.source Y Z      *)
(*                                     structure.                             *)
(*                           nbhs p == set of sets associated to p (in a      *)
(*                                     filtered type).                        *)
(*                  filter_from D B == set of the supersets of the elements   *)
(*                                     of the family of sets B whose indices  *)
(*                                     are in the domain D.                   *)
(*                                     This is a filter if (B_i)_(i in D)     *)
(*                                     forms a filter base.                   *)
(*                  filter_prod F G == product of the filters F and G.        *)
(*                    [filter of x] == canonical filter associated to x.      *)
(*                        F `=&gt;` G &lt;-&gt; G is included in F; F and G are sets   *)
(*                                     of sets.                               *)
(*                         F --&gt; G &lt;-&gt; the canonical filter associated to G   *)
(*                                     is included in the canonical filter    *)
(*                                     associated to F.                       *)
(*                            lim F == limit of the canonical filter          *)
(*                                     associated with F if there is such a   *)
(*                                     limit, i.e., an element l such that    *)
(*                                     the canonical filter associated to l   *)
(*                                     is a subset of F.                      *)
(*                     [lim F in T] == limit of the canonical filter          *)
(*                                     associated to F in T where T has type  *)
(*                                     filteredType U.                        *)
(*                    [cvg F in T] &lt;-&gt; the canonical filter associated to F   *)
(*                                     converges in T.                        *)
(*                           cvg F &lt;-&gt; same as [cvg F in T] where T is        *)
(*                                     inferred from the type of the          *)
(*                                     canonical filter associated to F.      *)
(*                         Filter F == type class proving that the set of     *)
(*                                     sets F is a filter.                    *)
(*                   ProperFilter F == type class proving that the set of     *)
(*                                     sets F is a proper filter.             *)
(*                    UltraFilter F == type class proving that the set of     *)
(*                                     sets F is an ultrafilter               *)
(*                      filter_on T == interface type for sets of sets on T   *)
(*                                     that are filters.                      *)
(*                  FilterType F FF == packs the set of sets F with the proof *)
(*                                     FF of Filter F to build a filter_on T  *)
(*                                     structure.                             *)
(*                     pfilter_on T == interface type for sets of sets on T   *)
(*                                     that are proper filters.               *)
(*                 PFilterPack F FF == packs the set of sets F with the proof *)
(*                                     FF of ProperFilter F to build a        *)
(*                                     pfilter_on T structure.                *)
(*                         fmap f F == image of the filter F by the function  *)
(*                                     f                                      *)
(*                       E @[x --&gt; F] == image of the canonical filter        *)
(*                                     associated to F by the function        *)
(*                                     (fun x =&gt; E).                          *)
(*                            f @ F == image of the canonical filter          *)
(*                                     associated to F by the function f.     *)
(*                        fmapi f F == image of the filter F by the relation  *)
(*                                     f                                      *)
(*                      E `@[x --&gt; F] == image of the canonical filter        *)
(*                                     associated to F by the relation        *)
(*                                     (fun x =&gt; E).                          *)
(*                           f `@ F == image of the canonical filter          *)
(*                                     associated to F by the relation f.     *)
(*                       globally A == filter of the sets containing A.       *)
(*                @frechet_filter T := [set S : set T | finite_set (~` S)]    *)
(*                                     a.k.a. cofinite filter                 *)
(*                       at_point a == filter of the sets containing a.       *)
(*                       within D F == restriction of the filter F to the     *)
(*                                     domain D.                              *)
(*               principal_filter x == filter containing every superset of x. *)
(*                subset_filter F D == similar to within D F, but with        *)
(*                                     dependent types.                       *)
(*           powerset_filter_from F == The filter of downward closed subsets  *)
(*                                     of F. Enables use of near notation to  *)
(*                                     pick suitably small members of F       *)
(*                      in_filter F == interface type for the sets that       *)
(*                                     belong to the set of sets F.           *)
(*                      InFilter FP == packs a set P with a proof of F P to   *)
(*                                     build a in_filter F structure.         *)
(*                              \oo == "eventually" filter on nat: set of     *)
(*                                     predicates on natural numbers that are *)
(*                                     eventually true.                       *)
(*                         clopen U == U is both open and closed              *)
(*                   normal_space X == X is normal, sometimes called T4       *)
(*                  regular_space X == X is regular, sometimes called T3      *)
(*    separate_points_from_closed f == For a closed set U and point x outside *)
(*                                     some member of the family f sends      *)
(*                                     f_i(x) outside (closure (f_i @` U)).   *)
(*                                     Used together with join_product.       *)
(*                   join_product f == The function (x =&gt; f ^~ x). When the   *)
(*                                     family f separates points from closed  *)
(*                                     sets, join_product is an embedding.    *)
(*                                                                            *)
(* * Near notations and tactics:                                              *)
(*   --&gt; The purpose of the near notations and tactics is to make the         *)
(*       manipulation of filters easier. Instead of proving F G, one can      *)
(*       prove G x for x "near F", i.e. for x such that H x for H arbitrarily *)
(*       precise as long as F H. The near tactics allow for a delayed         *)
(*       introduction of H: H is introduced as an existential variable and    *)
(*       progressively instantiated during the proof process.                 *)
(*   --&gt; Notations:                                                           *)
(*                      {near F, P} == the property P holds near the          *)
(*                                     canonical filter associated to F; P    *)
(*                                     must have the form forall x, Q x.      *)
(*                                     Equivalent to F Q.                     *)
(*          \forall x \near F, P x &lt;-&gt; F (fun x =&gt; P x).                      *)
(*                     \near x, P x := \forall y \near x, P y.                *)
(*                  {near F &amp; G, P} == same as {near H, P}, where H is the    *)
(*                                     product of the filters F and G.        *)
(*   \forall x \near F &amp; y \near G, P x y := {near F &amp; G, forall x y, P x y}. *)
(*     \forall x &amp; y \near F, P x y == same as before, with G = F.            *)
(*               \near x &amp; y, P x y := \forall z \near x &amp; t \near y, P x y.  *)
(*                     x \is_near F == x belongs to a set P : in_filter F.    *)
(*   --&gt; Tactics:                                                             *)
(*     - near=&gt; x    introduces x:                                            *)
(*       On the goal \forall x \near F, G x, introduces the variable x and an *)
(*       "existential", and unaccessible hypothesis ?H x and asks the user to *)
(*       prove (G x) in this context.                                         *)
(*       Under the hood delays the proof of F ?H and waits for near: x        *)
(*       Also exists under the form near=&gt; x y.                               *)
(*     - near: x     discharges x:                                            *)
(*       On the goal H_i x, and where x \is_near F, it asks the user to prove *)
(*       that (\forall x \near F, H_i x), provided that H_i x does not depend *)
(*       on variables introduced after x.                                     *)
(*       Under the hood, it refines by intersection the existential variable  *)
(*       ?H attached to x, computes the intersection with F, and asks the     *)
(*       user to prove F H_i, right now                                       *)
(*     - end_near should be used to close remaining existentials trivially    *)
(*     - near F =&gt; x     poses a variable near F, where F is a proper filter  *)
(*       adds to the context a variable x that \is_near F, i.e. one may       *)
(*       assume H x for any H in F. This new variable x can be dealt with     *)
(*       using  near: x, as for variables introduced by near=&gt;.               *)
(*                                                                            *)
(* * Topology :                                                               *)
(*                  topologicalType == interface type for topological space   *)
(*                                     structure.                             *)
(* TopologicalMixin nbhs_filt nbhsE == builds the mixin for a topological     *)
(*                                     space from the proofs that nbhs        *)
(*                                     outputs proper filters and defines the *)
(*                                     same notion of neighbourhood as the    *)
(*                                     open sets.                             *)
(* topologyOfFilterMixin nbhs_filt nbhs_sing nbhs_nbhs == builds the mixin    *)
(*                                     for a topological space from the       *)
(*                                     properties of nbhs and hence assumes   *)
(*                                     that the carrier is a filterType       *)
(*   topologyOfOpenMixin opT opI op_bigU == builds the mixin for a            *)
(*                                     topological space from the properties  *)
(*                                     of open sets, assuming the carrier is  *)
(*                                     a pointed type. nbhs_of_open must be   *)
(*                                     used to declare a filterType.          *)
(*   topologyOfBaseMixin b_cover b_join == builds the mixin for a topological *)
(*                                     space from the properties of a base of *)
(*                                     open sets; the type of indices must be *)
(*                                     a pointedType, as well as the carrier. *)
(*                                     nbhs_of_open \o open_from must be      *)
(*                                     used to declare a filterType           *)
(*                 filterI_iter F n == nth stage of recursively building the  *)
(*                                     filter of finite intersections of F    *)
(*                    finI_from D f == set of \bigcap_(i in E) f i where E is *)
(*                                     a finite subset of D                   *)
(*       topologyOfSubbaseMixin D b == builds the mixin for a topological     *)
(*                                     space from a subbase of open sets b    *)
(*                                     indexed on domain D; the type of       *)
(*                                     indices must be a pointedType.         *)
(*              TopologicalType T m == packs the mixin m to build a           *)
(*                                     topologicalType; T must have a         *)
(*                                     canonical structure of filteredType T. *)
(*           weak_topologicalType f == weak topology by f : S -&gt; T on S; S    *)
(*                                     must be a pointedType and T a          *)
(*                                     topologicalType.                       *)
(*           sup_topologicalType Tc == supremum topology of the family of     *)
(*                                     topologicalType structures Tc on T; T  *)
(*                                     must be a pointedType.                 *)
(*        product_topologicalType T == product topology of the family of      *)
(*                                     topologicalTypes T.                    *)
(*    [topologicalType of T for cT] == T-clone of the topologicalType         *)
(*                                     structure cT.                          *)
(*           [topologicalType of T] == clone of a canonical structure of      *)
(*                                     topologicalType on T.                  *)
(*                             open == set of open sets.                      *)
(*                      open_nbhs p == set of open neighbourhoods of p.       *)
(*                          basis B == a family of open sets that converges   *)
(*                                     to each point                          *)
(*               second_countable T == T has a countable basis                *)
(*                    continuous f &lt;-&gt; f is continuous w.r.t the topology.    *)
(*                              x^' == set of neighbourhoods of x where x is  *)
(*                                     excluded (a "deleted neighborhood").   *)
(*                        closure A == closure of the set A.                  *)
(*                    limit_point E == the set of limit points of E           *)
(*                           closed == set of closed sets.                    *)
(*                        cluster F == set of cluster points of F.            *)
(*                          compact == set of compact sets w.r.t. the filter- *)
(*                                     based definition of compactness.       *)
(*                   compact_near F == the filter F contains a closed comapct *)
(*                                     set                                    *)
(*                     precompact A == The set A is contained in a closed and *)
(*                                     compact set                            *)
(*                locally_compact A == every point in A has a compact         *)
(*                                     (and closed) neighborhood              *)
(*               hausdorff_space T &lt;-&gt; T is a Hausdorff space (T_2).          *)
(*                discrete_space T &lt;-&gt; every nbhs is a principal filter       *)
(*        finite_subset_cover D F A == the family of sets F is a cover of A   *)
(*                                     for a finite number of indices in D    *)
(*                    cover_compact == set of compact sets w.r.t. the open    *)
(*                                     cover-based definition of compactness. *)
(*                    near_covering == a reformulation of covering compact    *)
(*                                     better suited for use with `near`      *)
(*                     connected A &lt;-&gt; the only non empty subset of A which   *)
(*                                     is both open and closed in A is A.     *)
(*              kolmogorov_space T &lt;-&gt; T is a Kolmogorov space (T_0).         *)
(*              accessible_space T &lt;-&gt; T is an accessible space (T_1).        *)
(*                    separated A B == the two sets A and B are separated     *)
(*                      component x == the connected component of point x     *)
(*                    perfect_set A == A is closed, and is every point in A   *)
(*                                     is a limit point of A.                 *)
(*           totally_disconnected A == The only connected subsets of A are    *)
(*                                     empty or singletons.                   *)
(*               zero_dimensional T == Points are separable by a clopen set.  *)
(*                       set_nbhs A == filter from open sets containing A     *)
(*                                                                            *)
(*                                                                            *)
(*                      [locally P] := forall a, A a -&gt; G (within A (nbhs x)) *)
(*                                     if P is convertible to G (globally A)  *)
(*              quotient_topology Q == the quotient topology corresponding to *)
(*                                     quotient Q : quotType T where T has    *)
(*                                     type topologicalType                   *)
(*                                                                            *)
(* * Function space topologies :                                              *)
(*     {uniform` A -&gt; V} == The space U -&gt; V, equipped with the topology of   *)
(*                          uniform convergence from a set A to V, where      *)
(*                          V is a uniformType.                               *)
(*      {uniform U -&gt; V} := {uniform` [set: U] -&gt; V}                          *)
(*  {uniform A, F --&gt; f} == F converges to f in {uniform A -&gt; V}.             *)
(*    {uniform, F --&gt; f} := {uniform setT, F --&gt; f}                           *)
(*         {ptws U -&gt; V} == The space U -&gt; V, equipped with the topology of   *)
(*                          pointwise convergence from U to V, where V is a   *)
(*                          topologicalType; notation for @fct_Pointwise U V. *)
(*       {ptws, F --&gt; f} == F converges to f in {ptws U -&gt; V}.                *)
(*  {family fam, U -&gt; V} == The space U -&gt; V, equipped with the supremum      *)
(*                          topology of {uniform A -&gt; f} for each A in 'fam'  *)
(*                          In particular {family compact, U -&gt; V} is the     *)
(*                          topology of compact convergence.                  *)
(* {family fam, F --&gt; f} == F converges to f in {family fam, U -&gt; V}.         *)
(*                                                                            *)
(* --&gt; We used these topological notions to prove Tychonoff's Theorem, which  *)
(*     states that any product of compact sets is compact according to the    *)
(*     product topology.                                                      *)
(* * Uniform spaces :                                                         *)
(*                      nbhs_ ent == neighbourhoods defined using entourages  *)
(*                    uniformType == interface type for uniform spaces: a     *)
(*                                   type equipped with entourages            *)
(*   UniformMixin efilter erefl einv esplit nbhse == builds the mixin for a   *)
(*                                   uniform space from the properties of     *)
(*                                   entourages and the compatibility between *)
(*                                   entourages and nbhs                      *)
(*                UniformType T m == packs the uniform space mixin into a     *)
(*                                   uniformType. T must have a canonical     *)
(*                                   structure of topologicalType             *)
(*      [uniformType of T for cT] == T-clone of the uniformType structure cT  *)
(*             [uniformType of T] == clone of a canonical structure of        *)
(*                                   uniformType on T                         *)
(*   topologyOfEntourageMixin umixin == builds the mixin for a topological    *)
(*                                   space from a mixin for a uniform space   *)
(*                      entourage == set of entourages in a uniform space     *)
(*                    split_ent E == when E is an entourage, split_ent E is   *)
(*                                   an entourage E' such that E' \o E' is    *)
(*                                   included in E when seen as a relation    *)
(*                   unif_continuous f &lt;-&gt; f is uniformly continuous.         *)
(*               weak_uniformType == the uniform space for weak topologies    *)
(*                sup_uniformType == the uniform space for sup topologies     *)
(*         countable_uniformity T == T's entourage has a countable base. This *)
(*                                   is equivalent to `T` being metrizable    *)
(*                        gauge E == For an entourage E, gauge E is a filter  *)
(*                                   which includes `iter n split_ent E`.     *)
(*                                   Critically, `gauge E` forms a uniform    *)
(*                                   space with a countable uniformity        *)
(*       gauge_psuedoMetricType E == the pseudoMetricType associated with the *)
(*                                   `gauge E`                                *)
(*                   discrete_ent == entourages for the discrete topology     *)
(*                                                                            *)
(* * PseudoMetric spaces :                                                    *)
(*                entourage_ ball == entourages defined using balls           *)
(*               pseudoMetricType == interface type for pseudo metric space   *)
(*                                   structure: a type equipped with balls.   *)
(*  PseudoMetricMixin brefl bsym btriangle nbhsb == builds the mixin for a    *)
(*                                   pseudo metric space from the properties  *)
(*                                   of balls and the compatibility between   *)
(*                                   balls and entourages.                    *)
(*           PseudoMetricType T m == packs the pseudo metric space mixin into *)
(*                                   a pseudoMetricType. T must have a        *)
(*                                   canonical structure of uniformType.      *)
(* [pseudoMetricType R of T for cT] == T-clone of the pseudoMetricType        *)
(*                                   structure cT, with R the ball radius.    *)
(*      [pseudoMetricType R of T] == clone of a canonical structure of        *)
(*                                   pseudoMetricType on T, with R the ball   *)
(*                                   radius.                                  *)
(*   uniformityOfBallMixin umixin == builds the mixin for a topological space *)
(*                                   from a mixin for a pseudoMetric space.   *)
(*                       ball x e == ball of center x and radius e.           *)
(*                nbhs_ball_ ball == nbhs defined using the given balls       *)
(*                      nbhs_ball == nbhs defined using balls in a            *)
(*                                   pseudometric space                       *)
(*                     close x y &lt;-&gt; x and y are arbitrarily close w.r.t. to  *)
(*                                   balls.                                   *)
(*          weak_pseudoMetricType == the metric space for weak topologies     *)
(*            quotient_topology Q == the quotient topology corresponding to   *)
(*                                   quotient Q : quotType T. where T has     *)
(*                                   type topologicalType                     *)
(*                  discrete_ball == singleton balls for thediscrete topology *)
(*                                                                            *)
(* * Complete uniform spaces :                                                *)
(*                      cauchy F &lt;-&gt; the set of sets F is a cauchy filter     *)
(*                                   (entourage definition)                   *)
(*                   completeType == interface type for a complete uniform    *)
(*                                   space structure.                         *)
(*       CompleteType T cvgCauchy == packs the proof that every proper cauchy *)
(*                                   filter on T converges into a             *)
(*                                   completeType structure; T must have a    *)
(*                                   canonical structure of uniformType.      *)
(*     [completeType of T for cT] == T-clone of the completeType structure    *)
(*                                   cT.                                      *)
(*            [completeType of T] == clone of a canonical structure of        *)
(*                                   completeType on T.                       *)
(*                                                                            *)
(* * Complete pseudometric spaces :                                           *)
(*                   cauchy_ex F &lt;-&gt; the set of sets F is a cauchy filter     *)
(*                                   (epsilon-delta definition).              *)
(*                      cauchy F &lt;-&gt; the set of sets F is a cauchy filter     *)
(*                                   (using the near notations).              *)
(*       completePseudoMetricType == interface type for a complete            *)
(*                                   pseudometric space structure.            *)
(* CompletePseudoMetricType T cvgCauchy == packs the proof that every proper  *)
(*                                   cauchy filter on T converges into a      *)
(*                                   completePseudoMetricType structure; T    *)
(*                                   must have a canonical structure of       *)
(*                                   pseudoMetricType.                        *)
(* [completePseudoMetricType of T for cT] == T-clone of the                   *)
(*                                   completePseudoMetricType structure cT.   *)
(* [completePseudoMetricType of T] == clone of a canonical structure of       *)
(*                                   completePseudoMetricType on T.           *)
(*                                                                            *)
(*                        ball_ N == balls defined by the norm/absolute       *)
(*                                   value N                                  *)
(*                        dense S == the set (S : set T) is dense in T, with  *)
(*                                   T of type topologicalType                *)
(*                                                                            *)
(* * Subspaces of topological spaces :                                        *)
(*                 subspace A == for (A : set T), this is a copy of T with    *)
(*                               a topology that ignores points outside A     *)
(*            incl_subspace x == with x of type subspace A with (A : set T),  *)
(*                               inclusion of subspace A into T               *)
(*                                                                            *)
(* * Arzela Ascoli' theorem :                                                 *)
(*            singletons T := [set [set x] | x in [set: T]].                  *)
(*      equicontinuous W x == the set (W : X -&gt; Y) is equicontinuous at x     *)
(*  pointwise_precompact W == For each (x : X), set of images [f x | f in W]  *)
(*                            is precompact                                   *)
(*                                                                            *)
(* We endow several standard types with the types of topological notions:     *)
(* - products: prod_topologicalType, prod_uniformType, prod_pseudoMetricType  *)
(*     sup_pseudoMetricType, weak_pseudoMetricType, product_pseudoMetricType  *)
(* - matrices: matrix_filtered, matrix_topologicalType, matrix_uniformType,   *)
(*     matrix_pseudoMetricType, matrix_completeType,                          *)
(*     matrix_completePseudoMetricType                                        *)
(* - nat: nat_filteredType, nat_topologicalType                               *)
(* - numFieldType: numField_filteredType, numField_topologicalType,           *)
(*     numField_uniformType, numField_pseudoMetricType (accessible with       *)
(*     "Import numFieldTopology.Exports.")                                    *)
(******************************************************************************)
</pre>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span> }" (<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">near</span>'  <span class="id">x</span> ,  <span class="id">P</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  '\<span class="id">near</span>'  <span class="id">x_0</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="kwd">at</span> <span class="id">level</span> 99, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="id">near</span>'  <span class="id">x</span> ,  <span class="id">P</span>", <span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">near</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span> ,  <span class="id">P</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">y_0</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">y</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  '\<span class="id">near</span>'  <span class="id">x_0</span>  &amp;  <span class="id">y</span>  '\<span class="id">near</span>'  <span class="id">y_0</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">z</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">y</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span>  '\<span class="id">near</span>'  <span class="id">z</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span>, <span class="id">y</span> <span class="kwd">at</span> <span class="id">level</span> 99, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="id">near</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span> ,  <span class="id">P</span>", <span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">filter</span>' '<span class="id">of</span>' <span class="id">x</span> ]" (<span class="id">format</span> "[ '<span class="id">filter</span>'  '<span class="id">of</span>'  <span class="id">x</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">F</span> `=&gt;` <span class="id">G</span>" (<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">format</span> "<span class="id">F</span>  `=&gt;`  <span class="id">G</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">F</span> --&gt; <span class="id">G</span>" (<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">format</span> "<span class="id">F</span>  --&gt;  <span class="id">G</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">lim</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" (<span class="id">format</span> "[ '<span class="id">lim</span>'  <span class="id">F</span>  '<span class="kwd">in</span>'  <span class="id">T</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">cvg</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" (<span class="id">format</span> "[ '<span class="id">cvg</span>'  <span class="id">F</span>  '<span class="kwd">in</span>'  <span class="id">T</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">x</span> \<span class="id">is_near</span> <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 10, <span class="id">format</span> "<span class="id">x</span>  \<span class="id">is_near</span>  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">E</span> @[ <span class="id">x</span> --&gt; <span class="id">F</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">x</span> <span class="id">name</span>, <span class="id">format</span> "<span class="id">E</span>  @[ <span class="id">x</span>  --&gt;  <span class="id">F</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">f</span> @ <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">format</span> "<span class="id">f</span>  @  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">E</span> `@[ <span class="id">x</span> --&gt; <span class="id">F</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">x</span> <span class="id">name</span>, <span class="id">format</span> "<span class="id">E</span>  `@[ <span class="id">x</span>  --&gt;  <span class="id">F</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">f</span> `@ <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">format</span> "<span class="id">f</span>  `@  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^°" (<span class="kwd">at</span> <span class="id">level</span> 1, <span class="id">format</span> "<span class="id">A</span> ^°").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" (<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">locally</span>'  <span class="id">P</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">x</span> ^'" (<span class="kwd">at</span> <span class="id">level</span> 2, <span class="id">format</span> "<span class="id">x</span> ^'").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">within</span>' <span class="id">A</span> , '<span class="id">continuous</span>' <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">within</span>'  <span class="id">A</span> ,  '<span class="id">continuous</span>'  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>`' <span class="id">A</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">uniform</span>`'  <span class="id">A</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">uniform</span>'  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">A</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "{ '<span class="id">uniform</span>'  <span class="id">A</span> ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "{ '<span class="id">uniform</span>' ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">ptws</span>'  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">ptws</span>' ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">family</span>'  <span class="id">fam</span> ,  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">family</span>'  <span class="id">fam</span> ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="kwd">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="kwd">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="kwd">Implicit</span> <span class="id">Defensive</span>.<br/>
<br/>
<span class="kwd">Obligation</span> <span class="kwd">Tactic</span> := <span class="id">idtac</span>.<br/>
<br/>
<span class="kwd">Import</span> <span class="id">Order.TTheory</span> <span class="id">GRing.Theory</span> <span class="id">Num.Theory</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ring_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="bigmaxmin">bigmaxmin</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="max">max</a></span> := <span class="id">Order.max</span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="min">min</a></span> := <span class="id">Order.min</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">order_scope</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="bigmaxmin.d">d</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#unit">unit</a></span>) (<span class="id"><a name="bigmaxmin.T">T</a></span> : <span class="id">orderType</span> <span class="id">d</span>) (<span class="id"><a name="bigmaxmin.x">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="bigmaxmin.I">I</a></span> : <span class="id">finType</span>) (<span class="id"><a name="bigmaxmin.P">P</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#pred">pred</a></span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="bigmaxmin.m">m</a></span> : <span class="id">T</span>) (<span class="id"><a name="bigmaxmin.F">F</a></span> : <span class="id">I</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmax_geP">bigmax_geP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> \/ <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= \<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#max">max</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id">i</span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">mx</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">mFi</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">leNgt</span> =&gt; /<span class="id">bigmax_ltP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmax_idl</span> <span class="id">le_maxr</span> <span class="id">mx</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigmaxD1</span> <span class="id">i</span>)// <span class="id">le_maxr</span> <span class="id">mFi</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmax_gtP">bigmax_gtP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> \/ <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; \<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#max">max</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id">i</span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">mx</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">mFi</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">ltNge</span> =&gt; /<span class="id">bigmax_leP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmax_idl</span> <span class="id">lt_maxr</span> <span class="id">mx</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigmaxD1</span> <span class="id">i</span>)// <span class="id">lt_maxr</span> <span class="id">mFi</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmin_leP">bigmin_leP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> \/ <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#min">min</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id">i</span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">xm</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">Fim</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">leNgt</span> =&gt; /<span class="id">bigmin_gtP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmin_idl</span> <span class="id">le_minl</span> <span class="id">xm</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigminD1</span> <span class="id">i</span>)// <span class="id">le_minl</span> <span class="id">Fim</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmin_ltP">bigmin_ltP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> \/ <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#min">min</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id">i</span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">xm</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">Fim</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">ltNge</span> =&gt; /<span class="id">bigmin_geP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmin_idl</span> <span class="id">lt_minl</span> <span class="id">xm</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigminD1</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Pi</span>) <span class="id">lt_minl</span> <span class="id">Fim</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin">bigmaxmin</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="monotonous">monotonous</a></span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id">pT</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#predType">predType</a></span> <span class="id">T</span>) (<span class="id">A</span> : <span class="id">pT</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span> &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id">x</span> <span class="id">y</span> / (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} \/ {<span class="kwd">in</span> <span class="id">A</span> &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id">x</span> <span class="id">y</span> /~ (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="and_prop_in">and_prop_in</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">p</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#mem_pred">mem_pred</a></span> <span class="id">T</span>) (<span class="id">P</span> <span class="id">Q</span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span> /\ <span class="id">Q</span> <span class="id">x</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>} /\ {<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">Q</span> <span class="id">x</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
<span class="id">split</span>=&gt; [<span class="id">cnd</span>|[<span class="id">cnd1</span> <span class="id">cnd2</span>] <span class="id">x</span> <span class="id">xin</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">x</span> <span class="id">xin</span>; <span class="id">case</span>: (<span class="id">cnd</span> <span class="id">x</span> <span class="id">xin</span>).<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">cnd1</span> | <span class="id">apply</span>: <span class="id">cnd2</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mem_inc_segment">mem_inc_segment</a></span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id">a</span> <span class="id">b</span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id">x</span> <span class="id">y</span> / (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id">f</span> : <span class="id">x</span> / <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &gt;-&gt; <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">f</span> <span class="id">a</span>, <span class="id">f</span> <span class="id">b</span>]}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
<span class="id">move</span>=&gt; <span class="id">fle</span> <span class="id">x</span> <span class="id">xab</span>; <span class="id">have</span> <span class="id">leab</span> : (<span class="id">a</span> &lt;= <span class="id">b</span>)%<span class="id">O</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">itvP</span> <span class="id">xab</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">in_itv</span>/= !<span class="id">fle</span> ?(<span class="id">itvP</span> <span class="id">xab</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mem_dec_segment">mem_dec_segment</a></span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id">a</span> <span class="id">b</span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id">x</span> <span class="id">y</span> /~ (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id">f</span> : <span class="id">x</span> / <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &gt;-&gt; <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">f</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">a</span>]}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
<span class="id">move</span>=&gt; <span class="id">fge</span> <span class="id">x</span> <span class="id">xab</span>; <span class="id">have</span> <span class="id">leab</span> : (<span class="id">a</span> &lt;= <span class="id">b</span>)%<span class="id">O</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">itvP</span> <span class="id">xab</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">in_itv</span>/= !<span class="id">fge</span> ?(<span class="id">itvP</span> <span class="id">xab</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Linear1">Linear1</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id">R</span> : <span class="id">ringType</span>) (<span class="id">U</span> : <span class="id">lmodType</span> <span class="id">R</span>) (<span class="id">V</span> : <span class="id">zmodType</span>) (<span class="id">s</span> : <span class="id">R</span> -&gt; <span class="id">V</span> -&gt; <span class="id">V</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_eqType">linear_eqType</a></span> := <span class="id">EqType</span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.V">V</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.s">s</a></span>} <span class="id"><a href="mathcomp.classical.boolp.html#gen_eqMixin">gen_eqMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_choiceType">linear_choiceType</a></span> := <span class="id">ChoiceType</span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.V">V</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.s">s</a></span>} <span class="id"><a href="mathcomp.classical.boolp.html#gen_choiceMixin">gen_choiceMixin</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1">Linear1</a></span>.<br/>
<span class="kwd">Section</span> <span class="id"><a name="Linear2">Linear2</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id">R</span> : <span class="id">ringType</span>) (<span class="id">U</span> : <span class="id">lmodType</span> <span class="id">R</span>) (<span class="id">V</span> : <span class="id">zmodType</span>) (<span class="id">s</span> : <span class="id">R</span> -&gt; <span class="id">V</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">s_law</span> : <span class="id">GRing.Scale.law</span> <span class="id">s</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_pointedType">linear_pointedType</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">PointedType</a></span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.V">V</a></span> | <span class="id">GRing.Scale.op</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s_law">s_law</a></span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">GRing.null_fun_linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.R">R</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.U">U</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.V">V</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s">s</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s_law">s_law</a></span>).<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2">Linear2</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Filtered">Filtered</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.nbhs_of">nbhs_of</a></span> <span class="id">U</span> <span class="id">T</span> := <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>).<br/>
<span class="kwd">Record</span> <span class="id"><a name="Filtered.class_of">class_of</a></span> <span class="id">U</span> <span class="id">T</span> := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.base">base</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class_of">Pointed.class_of</a></span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.nbhs_op">nbhs_op</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_of">nbhs_of</a></span> <span class="id">U</span> <span class="id">T</span><br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Filtered.ClassDef">ClassDef</a></span>.<br/>
<span class="kwd">Variable</span> <span class="id"><a name="Filtered.ClassDef.U">U</a></span> : <span class="kwd">Type</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Filtered.type">type</a></span> := <span class="id">Pack</span> { <span class="id"><a name="Filtered.sort">sort</a></span>; <span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="Filtered.ClassDef.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Filtered.ClassDef.cT">cT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.type">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.class">class</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="kwd">return</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.clone">clone</a></span> <span class="id">c</span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.T">T</a></span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="Filtered.ClassDef.xT">xT</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#T">T</a></span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.xclass">xclass</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">class</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.xT">xT</a></span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Pointed.class_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.pack">pack</a></span> <span class="id">m</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> <span class="id">b</span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id">bT</span>) <span class="id">b</span> =&gt; @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.T">T</a></span> (<span class="kwd">Class</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.eqType">eqType</a></span> := @<span class="id">Equality.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.choiceType">choiceType</a></span> := @<span class="id">Choice.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.fpointedType">fpointedType</a></span> := @<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Pack">Pointed.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Filtered.source">source</a></span> <span class="id">Z</span> <span class="id">Y</span> := <span class="id">Source</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.source_type">source_type</a></span> :&gt; <span class="kwd">Type</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : (<span class="id">source_type</span> -&gt; <span class="id">Z</span>) -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)<br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.source_filter">source_filter</a></span> <span class="id">Z</span> <span class="id">Y</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source">source</a></span> <span class="id">Z</span> <span class="id">Y</span>) : (<span class="id">F</span> -&gt; <span class="id">Z</span>) -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="id">X</span> <span class="id">f</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Filtered.Exports">Exports</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Pointed.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">nbhs_op</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">nbhs_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.eqType">eqType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.choiceType">choiceType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">fpointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.fpointedType">fpointedType</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.Exports.filteredType">filteredType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.type">type</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.Exports.FilteredType">FilteredType</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.pack">pack</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>).<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filteredType</span>' <span class="id">U</span> '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.clone">clone</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">filteredType</span>'  <span class="id">U</span>  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filteredType</span>' <span class="id">U</span> '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.clone">clone</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">filteredType</span>'  <span class="id">U</span>  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="Filtered.Exports.default_arrow_filter">default_arrow_filter</a></span> <span class="id">Y</span> (<span class="id">Z</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id">X</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source">source</a></span> <span class="id">Z</span> <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports.FilteredType">FilteredType</a></span> <span class="id">Y</span> (<span class="id">X</span> -&gt; <span class="id">Z</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source_filter">source_filter</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">X</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="Filtered.Exports.source_filter_filter">source_filter_filter</a></span> <span class="id">Y</span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="kwd">Prop</span> <span class="id">_</span> (<span class="id">_</span> -&gt; <span class="kwd">Prop</span>) (<span class="kwd">fun</span> <span class="id">x</span> : (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)) =&gt; <span class="id">x</span>).<br/>
<span class="kwd">Canonical</span> <span class="id">source_filter_filter</span>' <span class="id">Y</span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="kwd">Prop</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">_</span>) (<span class="kwd">fun</span> <span class="id">x</span> : (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)) =&gt; <span class="id">x</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports">Exports</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered">Filtered</a></span>.<br/>
<span class="kwd">Export</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports">Filtered.Exports</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs">nbhs</a></span> {<span class="id">U</span>} {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_op">Filtered.nbhs_op</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#class">Filtered.class</a></span> <span class="id">T</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> {<span class="id">U</span> <span class="id">T</span>} <span class="id">_</span> <span class="id">_</span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_from">filter_from</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> &amp; <span class="id">B</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="matrix_filtered">matrix_filtered</a></span> <span class="id">m</span> <span class="id">n</span> <span class="id">X</span> (<span class="id">Z</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) '<span class="id">M</span>[<span class="id">Z</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) (<span class="kwd">fun</span> <span class="id">mx</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id">mx</span> <span class="id">i</span> <span class="id">j</span>) (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">my</span> : '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> (<span class="id">my</span> <span class="id">i</span> <span class="id">j</span>)])).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_prod">filter_prod</a></span> {<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">U</span>)) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (<span class="kwd">fun</span> <span class="id">P</span> =&gt; <span class="id">F</span> <span class="id">P</span>.1 /\ <span class="id">G</span> <span class="id">P</span>.2) (<span class="kwd">fun</span> <span class="id">P</span> =&gt; <span class="id">P</span>.1 `*` <span class="id">P</span>.2).<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Near">Near</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all1</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span> : <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all2</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span> : <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all3</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>: <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="ph">ph</a></span> := (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_near1">prop_near1</a></span> {<span class="id">X</span>} {<span class="id">fX</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>} (<span class="id">x</span> : <span class="id">fX</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">P</span> (<span class="id">phP</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ph">ph</a></span> {<span class="id">all1</span> <span class="id">P</span>}) := <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> <span class="id">P</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_near2">prop_near2</a></span> {<span class="id">X</span> <span class="id">X</span>'} {<span class="id">fX</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>} {<span class="id">fX</span>' : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>'}<br/>
&nbsp;&nbsp;(<span class="id">x</span> : <span class="id">fX</span>) (<span class="id">x</span>' : <span class="id">fX</span>') := <span class="kwd">fun</span> <span class="id">P</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#ph">ph</a></span> {<span class="id">all2</span> <span class="id">P</span>} =&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>') (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">P</span> <span class="id">x</span>.1 <span class="id">x</span>.2).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Near">Near</a></span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span> }" := (@<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> <span class="id">P</span>)) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> , <span class="id">P</span>" := {<span class="id">near</span> <span class="id">x_0</span>, <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span>" := (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span>) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span> }" :=<br/>
&nbsp;&nbsp;(@<span class="id"><a href="mathcomp.analysis.topology.html#prop_near2">prop_near2</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">y</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> <span class="id">P</span>)) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">y_0</span> , <span class="id">P</span>" :=<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">x_0</span> &amp; <span class="id">y_0</span>, <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">z</span> , <span class="id">P</span>" :=<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">z</span> &amp; <span class="id">z</span>, <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span>" := (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">y</span>, <span class="id">P</span>) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_near2">prop_near2</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearE">nearE</a></span> {<span class="id">T</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_near">eq_near</a></span> {<span class="id">T</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id">P</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span> &lt;-&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">Q</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#predeqP">predeqP</a></span> -&gt;. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_of">filter_of</a></span> <span class="id">X</span> (<span class="id">fX</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>) (<span class="id">x</span> : <span class="id">fX</span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">fX</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filter</span>' '<span class="id">of</span>' <span class="id">x</span> ]" :=<br/>
&nbsp;&nbsp;(@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">x</span>)) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_of_filterE">filter_of_filterE</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filterE">nbhs_filterE</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NbhsFilter">NbhsFilter</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NbhsFilter.nbhs_simpl">nbhs_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of_filterE">filter_of_filterE</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>).<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NbhsFilter">NbhsFilter</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cvg_to">cvg_to</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> <span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">G</span> `&lt;=` <span class="id">F</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">F</span> `=&gt;` <span class="id">G</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">cvg_to</a></span> <span class="id">F</span> <span class="id">G</span>) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_refl">cvg_refl</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id">F</span> `=&gt;` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_refl">cvg_refl</a></span> {<span class="id">T</span> <span class="id">F</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">cvg_refl</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_trans">cvg_trans</a></span> <span class="id">T</span> (<span class="id">G</span> <span class="id">F</span> <span class="id">H</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;(<span class="id">F</span> `=&gt;` <span class="id">G</span>) -&gt; (<span class="id">G</span> `=&gt;` <span class="id">H</span>) -&gt; (<span class="id">F</span> `=&gt;` <span class="id">H</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">GH</span> <span class="id">P</span> /<span class="id">GH</span> /<span class="id">FG</span>. Qed.</div>
<br/>
<span class="kwd">Notation</span> "<span class="id">F</span> --&gt; <span class="id">G</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">cvg_to</a></span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] [<span class="id">filter</span> <span class="id">of</span> <span class="id">G</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="type_of_filter">type_of_filter</a></span> {<span class="id">T</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="lim_in">lim_in</a></span> {<span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="kwd">fun</span> <span class="id">l</span> : <span class="id">T</span> =&gt; <span class="id">F</span> --&gt; <span class="id">l</span>).<br/>
<span class="kwd">Notation</span> "[ '<span class="id">lim</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#lim_in">lim_in</a></span> <span class="id">_</span> <span class="id">T</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="lim">lim</a></span> <span class="id">F</span> := [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> [<span class="id">filteredType</span> <span class="id">_</span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.topology.html#type_of_filter">type_of_filter</a></span> <span class="id">_</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]]].<br/>
<span class="kwd">Notation</span> "[ '<span class="id">cvg</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" := (<span class="id">F</span> --&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="cvg">cvg</a></span> <span class="id">F</span> := [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> [<span class="id">filteredType</span> <span class="id">_</span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.topology.html#type_of_filter">type_of_filter</a></span> <span class="id">_</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]]].<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="FilteredTheory">FilteredTheory</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filtered_prod">filtered_prod</a></span> <span class="id">X1</span> <span class="id">X2</span> (<span class="id">Z1</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X1</span>)<br/>
&nbsp;&nbsp;(<span class="id">Z2</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X2</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> (<span class="id">X1</span> * <span class="id">X2</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> (<span class="id">X1</span> * <span class="id">X2</span>) (<span class="id">Z1</span> * <span class="id">Z2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.1) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.2)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_prod">cvg_prod</a></span> <span class="id">T</span> {<span class="id">U</span> <span class="id">U</span>' <span class="id">V</span> <span class="id">V</span>' : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>} (<span class="id">x</span> : <span class="id">U</span>) (<span class="id">l</span> : <span class="id">U</span>') (<span class="id">y</span> : <span class="id">V</span>) (<span class="id">k</span> : <span class="id">V</span>') :<br/>
&nbsp;&nbsp;<span class="id">x</span> --&gt; <span class="id">l</span> -&gt; <span class="id">y</span> --&gt; <span class="id">k</span> -&gt; (<span class="id">x</span>, <span class="id">y</span>) --&gt; (<span class="id">l</span>, <span class="id">k</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
<span class="id">move</span>=&gt; <span class="id">xl</span> <span class="id">yk</span> <span class="id">X</span> [[<span class="id">X1</span> <span class="id">X2</span>] /= [<span class="id">HX1</span> <span class="id">HX2</span>] <span class="id">H</span>]; <span class="kwd">exists</span> (<span class="id">X1</span>, <span class="id">X2</span>) =&gt; //=.<br/>
<span class="id">split</span>; [<span class="id">exact</span>: <span class="id">xl</span> | <span class="id">exact</span>: <span class="id">yk</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_ex">cvg_ex</a></span> {<span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] &lt;-&gt; (<span class="kwd">exists</span> <span class="id">l</span> : <span class="id">T</span>, <span class="id">F</span> --&gt; <span class="id">l</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [<span class="id">cvg</span>|/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>//]; <span class="kwd">exists</span> [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgP">cvgP</a></span> {<span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">l</span> -&gt; [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fl</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> <span class="id">l</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_toP">cvg_toP</a></span> {<span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] = <span class="id">l</span> -&gt; <span class="id">F</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /[<span class="id">swap</span>]-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="dvgP">dvgP</a></span> {<span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;~ [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] = <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#lim_in">lim_in</a></span> /=; <span class="id">case</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#xgetP">xgetP</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgNpoint">cvgNpoint</a></span> {<span class="id">U</span>} (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;[<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] != <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span> -&gt; [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#contra_neqP">contra_neqP</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">dvgP</a></span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#FilteredTheory">FilteredTheory</a></span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span> {<span class="id">U</span> <span class="id">T</span> <span class="id">F</span>} <span class="id">l</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">dvgP</a></span> {<span class="id">U</span>} <span class="id">T</span> {<span class="id">F</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_nearE">nbhs_nearE</a></span> {<span class="id">U</span>} {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> <span class="id">P</span> = \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_nbhs">near_nbhs</a></span> {<span class="id">U</span>} {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) = \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near2_curry">near2_curry</a></span> {<span class="id">U</span> <span class="id">V</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id">P</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">G</span>, <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>} = {<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>.1 <span class="id">x</span>.2}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near2_pair">near2_pair</a></span> {<span class="id">U</span> <span class="id">V</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">U</span> * <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">G</span>, <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">P</span> (<span class="id">x</span>, <span class="id">y</span>)} = {<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
 <span class="kwd">by</span> <span class="id">symmetry</span>; <span class="id">congr</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; -[]. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="near2E">near2E</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near2_curry">near2_curry</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near2_pair">near2_pair</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_of_nearI">filter_of_nearI</a></span> (<span class="id">X</span> : <span class="kwd">Type</span>) (<span class="id">fX</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;(<span class="id">x</span> : <span class="id">fX</span>) (<span class="id">ph</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">fX</span> <span class="id">x</span>) : <span class="kwd">forall</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">X</span> <span class="id">fX</span> <span class="id">x</span> <span class="id">ph</span> <span class="id">P</span> = @<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id">X</span> <span class="id">fX</span> <span class="id">x</span> <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NearNbhs">NearNbhs</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NearNbhs.near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_nbhs">near_nbhs</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_nearE">nbhs_nearE</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_of_nearI">filter_of_nearI</a></span>).<br/>
<span class="kwd">Ltac</span> <span class="id">near_simpl</span> := <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#NearNbhs.near_simpl">near_simpl</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearNbhs">NearNbhs</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_swap">near_swap</a></span> {<span class="id">U</span> <span class="id">V</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id">P</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span> &amp; <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; -[[/=<span class="id">A</span> <span class="id">B</span>] [<span class="id">FA</span> <span class="id">FB</span>] <span class="id">ABP</span>];<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span>, <span class="id">A</span>) =&gt; // -[<span class="id">x</span> <span class="id">y</span>] [/=<span class="id">Bx</span> <span class="id">Ay</span>]; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">y</span>, <span class="id">x</span>)).<br/>
Qed.</div>
<br/>
<h1> Filters </h1>
<br/>
<h2> Definitions </h2>
<br/>
<span class="kwd">Class</span> <span class="id"><a name="Filter">Filter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id"><a name="filterT">filterT</a></span> : <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> ;<br/>
&nbsp;&nbsp;<span class="id"><a name="filterI">filterI</a></span> : <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="filterS">filterS</a></span> : <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">P</span> `&lt;=` <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span><br/>
}.<br/>
<span class="id">Global</span> <span class="kwd">Hint</span> <span class="id">Mode</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> - ! : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Class</span> <span class="id">ProperFilter</span>' {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id"><a name="filter_not_empty">filter_not_empty</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#not">not</a></span> (<span class="id">F</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#False">False</a></span>)) ;<br/>
&nbsp;&nbsp;<span class="id">filter_filter</span>' : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span><br/>
}.<br/>
<span class="id">Global</span> <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">filter_filter</span>'.<br/>
<span class="id">Global</span> <span class="kwd">Hint</span> <span class="id">Mode</span> <span class="id">ProperFilter</span>' - ! : <span class="id">typeclass_instances</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Notation</span> <span class="id"><a name="ProperFilter">ProperFilter</a></span> := <span class="id">ProperFilter</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_setT">filter_setT</a></span> (<span class="id">T</span>' : <span class="kwd">Type</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>'].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
 <span class="kwd">by</span> <span class="id">constructor</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterP_strong">filterP_strong</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="kwd">exists</span> <span class="id">FQ</span>  : <span class="id">F</span> <span class="id">Q</span>, <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">T</span>, <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">P</span> <span class="id">x</span>) &lt;-&gt; <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">P</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Q</span> [<span class="id">FQ</span> <span class="id">QP</span>]]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">QP</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="filter_on">filter_on</a></span> <span class="id">T</span> := <span class="id">FilterType</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="filter">filter</a></span> :&gt; (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">filter</span><br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_class">filter_class</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">_</span> <span class="id">class</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">class</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> {<span class="id">T</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
#[<span class="id">global</span>] <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">filter_class</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filter_filter</span>' : <span class="id">ProperFilter</span> &gt;-&gt; <span class="id">Filter</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="pfilter_on">pfilter_on</a></span> <span class="id">T</span> := <span class="id">PFilterPack</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="pfilter">pfilter</a></span> :&gt; (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">pfilter</span><br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="pfilter_class">pfilter_class</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> <span class="id">_</span> <span class="id">class</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">class</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> {<span class="id">T</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
#[<span class="id">global</span>] <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">pfilter_class</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="pfilter_filter_on">pfilter_filter_on</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">F</span> (<span class="id"><a href="mathcomp.analysis.topology.html#pfilter_class">pfilter_class</a></span> <span class="id">F</span>).<br/>
<span class="kwd">Coercion</span> <span class="id">pfilter_filter_on</span> : <span class="id">pfilter_on</span> &gt;-&gt; <span class="id">filter_on</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="PFilterType">PFilterType</a></span> {<span class="id">T</span>} (<span class="id">F</span> : (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;{<span class="id">fF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">fN0</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#not">not</a></span> (<span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>)) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> <span class="id">F</span> (<span class="id">Build_ProperFilter</span>' <span class="id">fN0</span> <span class="id">fF</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#PFilterType">PFilterType</a></span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">fF</span>} <span class="id">fN0</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_eqType">filter_on_eqType</a></span> <span class="id">T</span> := <span class="id">EqType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) <span class="id"><a href="mathcomp.classical.boolp.html#gen_eqMixin">gen_eqMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_choiceType">filter_on_choiceType</a></span> <span class="id">T</span> :=<br/>
&nbsp;&nbsp;<span class="id">ChoiceType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) <span class="id"><a href="mathcomp.classical.boolp.html#gen_choiceMixin">gen_choiceMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_PointedType">filter_on_PointedType</a></span> <span class="id">T</span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">PointedType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_setT">filter_setT</a></span> <span class="id">T</span>)).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_FilteredType">filter_on_FilteredType</a></span> <span class="id">T</span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id">T</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_on_Filter">filter_on_Filter</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">F</span>. Qed.</div>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="pfilter_on_ProperFilter">pfilter_on_ProperFilter</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">F</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filter_onE">nbhs_filter_onE</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs_simpl">nbhs_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter_onE">nbhs_filter_onE</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_filter_onE">near_filter_onE</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_filter_onE">near_filter_onE</a></span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="trivial_filter_on">trivial_filter_on</a></span> <span class="id">T</span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> [<span class="id">set</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>] <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Next Obligation.</span></div>
<div class="proofscript" id="proof32">
<span class="id">split</span>=&gt; // [<span class="id">_</span> <span class="id">_</span> -&gt; -&gt;|<span class="id">Q</span> <span class="id">R</span> <span class="id">sQR</span> <span class="id">QT</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIT">setIT</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; // ? <span class="id">_</span>; <span class="id">apply</span>/<span class="id">sQR</span>; <span class="id">rewrite</span> <span class="id">QT</span>.<br/>
Qed.</div>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#trivial_filter_on">trivial_filter_on</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_nbhsT">filter_nbhsT</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">filter_nbhsT</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearT">nearT</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; \<span class="id">near</span> <span class="id">F</span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#True">True</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nearT</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_not_empty_ex">filter_not_empty_ex</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; ~ <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>) <span class="id">ex</span> /<span class="id">ex</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Build_ProperFilter">Build_ProperFilter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id">filter_ex</span> : <span class="kwd">forall</span> <span class="id">P</span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>)<br/>
&nbsp;&nbsp;(<span class="id">filter_filter</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) :=<br/>
&nbsp;&nbsp;<span class="id">Build_ProperFilter</span>' (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty_ex">filter_not_empty_ex</a></span> <span class="id">filter_ex</span>) (<span class="id">filter_filter</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_ex_subproof">filter_ex_subproof</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> -&gt; (<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
<span class="id">move</span>=&gt; <span class="id">NFset0</span> <span class="id">P</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#contra_notP">contra_notP</a></span> <span class="id">NFset0</span> =&gt; <span class="id">nex</span>; <span class="id">suff</span> &lt;- : <span class="id">P</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> <span class="kwd">by</span> [].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#funeqE">funeqE</a></span> =&gt; <span class="id">x</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; // <span class="id">Px</span>; <span class="id">apply</span>: <span class="id">nex</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_ex">filter_ex</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex_subproof">filter_ex_subproof</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> <span class="id">F</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_getP">filter_getP</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">P</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof37')">Proof.</span></div>
<div class="proofscript" id="proof37">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="in_filter">in_filter</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">InFilter</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="prop_in_filter_proj">prop_in_filter_proj</a></span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="prop_in_filterP_proj">prop_in_filterP_proj</a></span> : <span class="id">F</span> <span class="id">prop_in_filter_proj</span><br/>
}.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Type</span> <span class="id"><a name="PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Axiom</span> <span class="id"><a name="PropInFilterSig.t">t</a></span> : <span class="kwd">forall</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)), <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span> -&gt; <span class="id">T</span> -&gt; <span class="kwd">Prop</span>.<br/>
<span class="kwd">Axiom</span> <span class="id"><a name="PropInFilterSig.tE">tE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig.t">t</a></span> = <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Module</span> <span class="id"><a name="PropInFilter">PropInFilter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="PropInFilter.t">t</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span>.<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="PropInFilter.tE">tE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilter.t">t</a></span> = <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof38')">Proof.</span></div>
<div class="proofscript" id="proof38">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilter">PropInFilter</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="prop_of">prop_of</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_ofE">prop_ofE</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#tE">PropInFilter.tE</a></span>.<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> \<span class="id">is_near</span> <span class="id">F</span>" := (@<span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span> <span class="id">_</span> <span class="id">F</span> <span class="id">_</span> <span class="id">x</span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="is_nearE">is_nearE</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prop_ofP">prop_ofP</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">iF</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) : <span class="id">F</span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">iF</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof39')">Proof.</span></div>
<div class="proofscript" id="proof39">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="in_filterT">in_filterT</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="in_filterI">in_filterI</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) (<span class="id">P</span> <span class="id">Q</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span> <span class="id">P</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span> <span class="id">Q</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_near_of">filter_near_of</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">P</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof40')">Proof.</span></div>
<div class="proofscript" id="proof40">
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">P</span> =&gt; [<span class="id">P</span> <span class="id">FP</span>] <span class="id">FF</span> /=; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fact</span> <span class="id"><a name="near_key">near_key</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#unit">unit</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof41')">Proof.</span></div>
<div class="proofscript" id="proof41">
 <span class="id">exact</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mark_near">mark_near</a></span> (<span class="id">P</span> : <span class="kwd">Prop</span>) : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> <span class="id">P</span> -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof42')">Proof.</span></div>
<div class="proofscript" id="proof42">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_acc">near_acc</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">P</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">FQ</span> : \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">Q</span> <span class="id">x</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filterI">in_filterI</a></span> <span class="id">FF</span> <span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">FQ</span>)) <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof43')">Proof.</span></div>
<div class="proofscript" id="proof43">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span> =&gt; <span class="id">x</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; -[<span class="id">Px</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_skip_subproof">near_skip_subproof</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">P</span> <span class="id">Q</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">G</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filterI">in_filterI</a></span> <span class="id">FF</span> <span class="id">P</span> <span class="id">Q</span>) <span class="id">x</span> -&gt; <span class="id">G</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof44')">Proof.</span></div>
<div class="proofscript" id="proof44">
<span class="id">rewrite</span> !<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span> =&gt; <span class="id">FG</span> <span class="id">x</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; -[<span class="id">Px</span> <span class="id">Qx</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> /= := <span class="id">FG</span> <span class="id">x</span>; <span class="id">apply</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">x</span>) := <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_near_of">filter_near_of</a></span> =&gt; <span class="id">x</span> ?.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">just_discharge_near</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;<span class="id">tryif</span> <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> <span class="id">Hx</span> : <span class="id">x</span> \<span class="id">is_near</span> <span class="id">_</span> |- <span class="id">_</span> =&gt; <span class="id">move</span>: (<span class="id">x</span>) (<span class="id">Hx</span>); <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#mark_near">mark_near</a></span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">idtac</span> <span class="kwd">else</span> <span class="id">fail</span> "<span class="id">the</span> <span class="id">variable</span>" <span class="id">x</span> "<span class="id">is</span> <span class="id">not</span> <span class="id">a</span> ""<span class="id">near</span>"" <span class="id">variable</span>".<br/>
<span class="kwd">Ltac</span> <span class="id">near_skip</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id">_</span>, @<span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span> <span class="id">_</span> <span class="id">_</span> ?<span class="id">P</span> <span class="id">_</span> -&gt; <span class="id">_</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tryif</span> <span class="id">is_evar</span> <span class="id">P</span> <span class="kwd">then</span> <span class="id">fail</span> "<span class="id">nothing</span> <span class="id">to</span> <span class="id">skip</span>" <span class="kwd">else</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#near_skip_subproof">near_skip_subproof</a></span> <span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>:" <span class="id">ident</span>(<span class="id">x</span>) :=<br/>
&nbsp;&nbsp;<span class="id">just_discharge_near</span> <span class="id">x</span>;<br/>
&nbsp;&nbsp;<span class="id">tryif</span> <span class="id">do</span> ![<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#near_acc">near_acc</a></span>; <span class="id">first</span> <span class="id">shelve</span>|<span class="id">near_skip</span>]<br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">fail</span> "<span class="id">the</span> <span class="id">goal</span> <span class="id">depends</span> <span class="id">on</span> <span class="id">variables</span> <span class="id">introduced</span> <span class="id">after</span>" <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">under_near</span> <span class="id">i</span> <span class="id">tac</span> := <span class="id">near</span>=&gt; <span class="id">i</span>; <span class="id">tac</span>; <span class="id">near</span>: <span class="id">i</span>.<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">i</span>) "<span class="id">do</span>" <span class="id">tactic3</span>(<span class="id">tac</span>) := <span class="id">under_near</span> <span class="id">i</span> <span class="id">ltac</span>:(<span class="id">tac</span>).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">i</span>) "<span class="id">do</span>" "[" <span class="id">tactic4</span>(<span class="id">tac</span>) "]" := <span class="id">near</span>=&gt; <span class="id">i</span> <span class="id">do</span> <span class="id">tac</span>.<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" "<span class="id">do</span>" <span class="id">tactic3</span>(<span class="id">tac</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">i</span> := <span class="id">fresh</span> "<span class="id">i</span>" <span class="kwd">in</span> <span class="id">under_near</span> <span class="id">i</span> <span class="id">ltac</span>:(<span class="id">tac</span>).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" "<span class="id">do</span>" "[" <span class="id">tactic4</span>(<span class="id">tac</span>) "]" := <span class="id">near</span> <span class="id">do</span> <span class="id">tac</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">end_near</span> := <span class="id">do</span> ?<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#in_filterT">in_filterT</a></span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">done</span> :=<br/>
&nbsp;&nbsp;<span class="id">trivial</span>; <span class="id">hnf</span>; <span class="id">intros</span>; <span class="id">solve</span><br/>
&nbsp;&nbsp;&nbsp;[ <span class="id">do</span> ![<span class="id">solve</span> [<span class="id">trivial</span> | <span class="id">apply</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#sym_equal">sym_equal</a></span>; <span class="id">trivial</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">discriminate</span> | <span class="id">contradiction</span> | <span class="id">split</span>]<br/>
&nbsp;&nbsp;&nbsp;| <span class="id">case</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#not_locked_false_eq_true">not_locked_false_eq_true</a></span>; <span class="id">assumption</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> <span class="id">H</span> : ~ <span class="id">_</span> |- <span class="id">_</span> =&gt; <span class="id">solve</span> [<span class="id">case</span> <span class="id">H</span>; <span class="id">trivial</span>] <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- ?<span class="id">x</span> \<span class="id">is_near</span> <span class="id">_</span> =&gt; <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofP">prop_ofP</a></span> <span class="kwd">end</span> ].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="have_near">have_near</a></span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">fT</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id">x</span> : <span class="id">fT</span>) (<span class="id">P</span> : <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) -&gt; (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span>) -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof45')">Proof.</span></div>
<div class="proofscript" id="proof45">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">nP</span>; <span class="id">have</span> [] := @<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">FF</span> (<span class="kwd">fun</span>=&gt; <span class="id">P</span>). Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> {<span class="id">U</span> <span class="id">fT</span>} <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" <span class="id">constr</span>(<span class="id">F</span>) "=&gt;" <span class="id">ident</span>(<span class="id">x</span>) :=<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">F</span>); <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near">near</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) <span class="id">P</span> (<span class="id">FP</span> : <span class="id">F</span> <span class="id">P</span>) (<span class="id">x</span> : <span class="id">T</span>)<br/>
&nbsp;&nbsp;(<span class="id">Px</span> : <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">FP</span>) <span class="id">x</span>) : <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof46')">Proof.</span></div>
<div class="proofscript" id="proof46">
 <span class="kwd">by</span> <span class="id">move</span>: <span class="id">Px</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> {<span class="id">T</span> <span class="id">F</span> <span class="id">P</span>} <span class="id">FP</span> <span class="id">x</span> <span class="id">Px</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearW">nearW</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id">P</span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof47')">Proof.</span></div>
<div class="proofscript" id="proof47">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterE">filterE</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof48')">Proof.</span></div>
<div class="proofscript" id="proof48">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">FT</span> <span class="id">_</span> +] <span class="id">P</span> <span class="id">fP</span> =&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>); <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app">filter_app</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof49')">Proof.</span></div>
<div class="proofscript" id="proof49">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> <span class="id">FP</span>; <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">do</span> <span class="id">suff</span>: <span class="id">P</span> <span class="id">x</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app2">filter_app2</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">R</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>,  <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof50')">Proof.</span></div>
<div class="proofscript" id="proof50">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ???? <span class="id">PQR</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">FP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app3">filter_app3</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">R</span> <span class="id">S</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span> -&gt; <span class="id">S</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span> -&gt; <span class="id">F</span> <span class="id">S</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof51')">Proof.</span></div>
<div class="proofscript" id="proof51">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ????? <span class="id">PQR</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app2">filter_app2</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">FP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterS2">filterS2</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">R</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof52')">Proof.</span></div>
<div class="proofscript" id="proof52">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app2">filter_app2</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterS3">filterS3</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">R</span> <span class="id">S</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span> -&gt; <span class="id">S</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span> -&gt; <span class="id">F</span> <span class="id">S</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof53')">Proof.</span></div>
<div class="proofscript" id="proof53">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app3">filter_app3</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_const">filter_const</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">F</span>} {<span class="id">FF</span>: @<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">T</span> <span class="id">F</span>} (<span class="id">P</span> : <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="kwd">fun</span>=&gt; <span class="id">P</span>) -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof54')">Proof.</span></div>
<div class="proofscript" id="proof54">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="id">case</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">FP</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="in_filter_from">in_filter_from</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">i</span> : <span class="id">I</span>) :<br/>
&nbsp;&nbsp;<span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof55')">Proof.</span></div>
<div class="proofscript" id="proof55">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_andP">near_andP</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} <span class="id">F</span> (<span class="id">b1</span> <span class="id">b2</span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b1</span> <span class="id">x</span> /\ <span class="id">b2</span> <span class="id">x</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b1</span> <span class="id">x</span>) /\ (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b2</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof56')">Proof.</span></div>
<div class="proofscript" id="proof56">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>=&gt; [<span class="id">H</span>|[<span class="id">H1</span> <span class="id">H2</span>]]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">H</span> =&gt; ? [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">H1</span> <span class="id">H2</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearP_dep">nearP_dep</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id">P</span> : <span class="id">T</span> -&gt; <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>) -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, \<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof57')">Proof.</span></div>
<div class="proofscript" id="proof57">
<span class="id">move</span>=&gt; [[<span class="id">Q</span> <span class="id">R</span>] [/=<span class="id">FQ</span> <span class="id">GR</span>]] <span class="id">QRP</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FQ</span> =&gt; <span class="id">x</span> <span class="id">Q1x</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">GR</span> =&gt; <span class="id">y</span> <span class="id">Q2y</span>; <span class="id">apply</span>: (<span class="id">QRP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter2P">filter2P</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>))<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists2</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> * <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>, <span class="id">F</span> <span class="id">Q</span>.1 /\ <span class="id">G</span> <span class="id">Q</span>.2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="kwd">forall</span> (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">y</span> : <span class="id">U</span>), <span class="id">Q</span>.1 <span class="id">x</span> -&gt; <span class="id">Q</span>.2 <span class="id">y</span> -&gt; <span class="id">P</span> (<span class="id">x</span>, <span class="id">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&lt;-&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof58')">Proof.</span></div>
<div class="proofscript" id="proof58">
<span class="id">split</span>=&gt; [][[<span class="id">A</span> <span class="id">B</span>] /=[<span class="id">FA</span> <span class="id">GB</span>] <span class="id">ABP</span>]; <span class="kwd">exists</span> (<span class="id">A</span>, <span class="id">B</span>) =&gt; //=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">a</span> <span class="id">b</span>] [/=<span class="id">Aa</span> <span class="id">Bb</span>]; <span class="id">apply</span>: <span class="id">ABP</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">a</span> <span class="id">b</span> <span class="id">Aa</span> <span class="id">Bb</span>; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_ex2">filter_ex2</a></span> {<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>))<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span>} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">G</span> <span class="id">Q</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span> : <span class="id">T</span>, <span class="kwd">exists2</span> <span class="id">y</span> : <span class="id">U</span>, <span class="id">P</span> <span class="id">x</span> &amp; <span class="id">Q</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof59')">Proof.</span></div>
<div class="proofscript" id="proof59">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">x</span> <span class="id">Px</span>] /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">y</span> <span class="id">Qy</span>]; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">y</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex2">filter_ex2</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span> <span class="id">FF</span> <span class="id">FG</span> <span class="id">_</span> <span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromP">filter_fromP</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">F</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof60')">Proof.</span></div>
<div class="proofscript" id="proof60">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> <span class="id">i</span> ?; <span class="id">apply</span>/<span class="id">FB</span>/<span class="id"><a href="mathcomp.analysis.topology.html#in_filter_from">in_filter_from</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> <span class="id">P</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BjP</span>]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">BjP</span>); <span class="id">apply</span>: <span class="id">FB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromTP">filter_fromTP</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">B</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">F</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof61')">Proof.</span></div>
<div class="proofscript" id="proof61">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_fromP">filter_fromP</a></span>; <span class="id">split</span>=&gt; [<span class="id">P</span> <span class="id">i</span>|<span class="id">P</span> <span class="id">i</span> <span class="id">_</span>]; <span class="id">apply</span>: <span class="id">P</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_from_filter">filter_from_filter</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id">i</span> : <span class="id">I</span>, <span class="id">D</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">D</span> <span class="id">j</span> -&gt; <span class="kwd">exists2</span> <span class="id">k</span>, <span class="id">D</span> <span class="id">k</span> &amp; <span class="id">B</span> <span class="id">k</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof62')">Proof.</span></div>
<div class="proofscript" id="proof62">
<span class="id">move</span>=&gt; [<span class="id">i0</span> <span class="id">Di0</span>] <span class="id">Binter</span>; <span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>] [<span class="id">j</span> <span class="id">Dj</span> <span class="id">BjQ</span>]; <span class="id">have</span> [<span class="id">k</span> <span class="id">Dk</span> <span class="id">BkPQ</span>]:= <span class="id">Binter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Di</span> <span class="id">Dj</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">k</span> =&gt; // <span class="id">x</span> /<span class="id">BkPQ</span> [/<span class="id">BiP</span> ? /<span class="id">BjQ</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">subPQ</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromT_filter">filter_fromT_filter</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id">_</span> : <span class="id">I</span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#True">True</a></span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="kwd">exists</span> <span class="id">k</span>, <span class="id">B</span> <span class="id">k</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof63')">Proof.</span></div>
<div class="proofscript" id="proof63">
<span class="id">move</span>=&gt; [<span class="id">i0</span> <span class="id">_</span>] <span class="id">BI</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i0</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="id">have</span> [<span class="id">k</span>] := <span class="id">BI</span> <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">k</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_from_proper">filter_from_proper</a></span> {<span class="id">I</span> <span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">B</span> <span class="id">i</span> !=<span class="id">set0</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof64')">Proof.</span></div>
<div class="proofscript" id="proof64">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">BN0</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>=&gt; <span class="id">P</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> [<span class="id">x</span> <span class="id">Bix</span>] := <span class="id">BN0</span> <span class="id">_</span> <span class="id">Di</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">BiP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_bigI">filter_bigI</a></span> <span class="id">T</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : {<span class="id">fset</span> <span class="id">I</span>}) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">i</span> | <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>]) <span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof65')">Proof.</span></div>
<div class="proofscript" id="proof65">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FfD</span>.<br/>
<span class="id">suff</span>: <span class="id">F</span> [<span class="id">set</span> <span class="id">p</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">enum_fset</span> <span class="id">D</span> -&gt; <span class="id">f</span> <span class="id">i</span> <span class="id">p</span>] <span class="kwd">by</span> [].<br/>
<span class="id">have</span> {<span class="id">FfD</span>} : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">enum_fset</span> <span class="id">D</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">i</span>) <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">FfD</span>.<br/>
<span class="id">elim</span>: (<span class="id">enum_fset</span> <span class="id">D</span>) =&gt; [|<span class="id">i</span> <span class="id">s</span> <span class="id">ihs</span>] <span class="id">FfD</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">f</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">s</span> -&gt; <span class="id">f</span> <span class="id">i</span> <span class="id">p</span>])).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">fip</span> <span class="id">fsp</span>] <span class="id">j</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orP">orP</a></span> [/<span class="id">eqP</span>-&gt;|] //; <span class="id">apply</span>: <span class="id">fsp</span>.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">FfD</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">eq_refl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ihs</span> =&gt; <span class="id">j</span> <span class="id">sj</span>; <span class="id">apply</span>: <span class="id">FfD</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">sj</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orbC">orbC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_forall">filter_forall</a></span> <span class="id">T</span> (<span class="id">I</span> : <span class="id">finType</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span> : <span class="id">I</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof66')">Proof.</span></div>
<div class="proofscript" id="proof66">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fIF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#filter_bigI">filter_bigI</a></span> <span class="id">T</span> <span class="id">I</span> [<span class="id">fset</span> <span class="id">x</span> <span class="kwd">in</span> <span class="id">I</span>]%<span class="id">fset</span> <span class="id">f</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">fIx</span> <span class="id">i</span>; <span class="id">have</span> := <span class="id">fIx</span> <span class="id">i</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>/=; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>/= =&gt; <span class="id">_</span>; <span class="id">apply</span>: (<span class="id">fIF</span> <span class="id">i</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_imply">filter_imply</a></span> [<span class="id">T</span> : <span class="kwd">Type</span>] [<span class="id">P</span> : <span class="kwd">Prop</span>] [<span class="id">f</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>] [<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)] :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="id">P</span> -&gt; \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">F</span>) -&gt; \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> -&gt; <span class="id">f</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof67')">Proof.</span></div>
<div class="proofscript" id="proof67">
<span class="id">move</span>=&gt; ? <span class="id">PF</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#asboolP">asboolP</a></span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">asboolP</a></span>=&gt; [/<span class="id">PF</span>|<span class="id">_</span>]; <span class="kwd">by</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>|<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nearW">nearW</a></span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<h2> Limits expressed with filters </h2>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fmap">fmap</a></span> {<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | <span class="id">F</span> (<span class="id">f</span> @^-1` <span class="id">P</span>)].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmapE">fmapE</a></span> {<span class="id">U</span> <span class="id">V</span> : <span class="kwd">Type</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">f</span> <span class="id">F</span> <span class="id">P</span> = <span class="id">F</span> (<span class="id">f</span> @^-1` <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof68')">Proof.</span></div>
<div class="proofscript" id="proof68">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Notation</span> "<span class="id">E</span> @[ <span class="id">x</span> --&gt; <span class="id">F</span> ]" :=<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">E</span>) [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">f</span> @ <span class="id">F</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">f</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmap_filter">fmap_filter</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof69')">Proof.</span></div>
<div class="proofscript" id="proof69">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">constructor</span> =&gt; [|<span class="id">P</span> <span class="id">Q</span>|<span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span>]; <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#fmapE">fmapE</a></span> ?<span class="id">filter_ofE</span> //=.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>=&gt; ?/<span class="id">PQ</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmap_proper_filter">fmap_proper_filter</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof70')">Proof.</span></div>
<div class="proofscript" id="proof70">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>';<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#fmapE">fmapE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">fmap_proper_filter</span>' := <span class="id"><a href="mathcomp.analysis.topology.html#fmap_proper_filter">fmap_proper_filter</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fmapi">fmapi</a></span> {<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>].<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">E</span> `@[ <span class="id">x</span> --&gt; <span class="id">F</span> ]" :=<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">E</span>) [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">f</span> `@ <span class="id">F</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> <span class="id">f</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmapiE">fmapiE</a></span> {<span class="id">U</span> <span class="id">V</span> : <span class="kwd">Type</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> <span class="id">f</span> <span class="id">F</span> <span class="id">P</span> = \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof71')">Proof.</span></div>
<div class="proofscript" id="proof71">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmapi_filter">fmapi_filter</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> {<span class="id">near</span> <span class="id">F</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#is_totalfun">is_totalfun</a></span> <span class="id">f</span>} -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id">f</span> `@ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof72')">Proof.</span></div>
<div class="proofscript" id="proof72">
<span class="id">move</span>=&gt; <span class="id">f_totalfun</span> <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_Filter">Build_Filter</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">f_totalfun</span> =&gt; <span class="id">x</span> [[<span class="id">y</span> <span class="id">Hy</span>] <span class="id">H</span>]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
- <span class="id">move</span>=&gt; /= <span class="id">P</span> <span class="id">Q</span> <span class="id">FP</span> <span class="id">FQ</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">y</span> [<span class="id">fxy</span> <span class="id">Py</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FP</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">z</span> [<span class="id">fxz</span> <span class="id">Qz</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FQ</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">fx_prop</span>] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">f_totalfun</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> [<span class="id">y</span>](<span class="id">fx_prop</span> <span class="id">_</span> <span class="id">z</span>).<br/>
- <span class="id">move</span>=&gt; /= <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> <span class="id">FP</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [//|<span class="id">y</span> [<span class="id">fxy</span> /<span class="id">subPQ</span> <span class="id">Qy</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FP</span> <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">fmapi</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmapi_proper_filter">fmapi_proper_filter</a></span><br/>
&nbsp;&nbsp;<span class="id">T</span> <span class="id">U</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> {<span class="id">near</span> <span class="id">F</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#is_totalfun">is_totalfun</a></span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">f</span> `@ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof73')">Proof.</span></div>
<div class="proofscript" id="proof73">
<span class="id">move</span>=&gt; <span class="id">f_totalfun</span> <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span>/= =&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">x</span> [<span class="id">y</span> [??]]]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">filter_map_proper_filter</span>' := <span class="id"><a href="mathcomp.analysis.topology.html#fmapi_proper_filter">fmapi_proper_filter</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_id">cvg_id</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id">x</span> @[<span class="id">x</span> --&gt; <span class="id">F</span>] --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof74')">Proof.</span></div>
<div class="proofscript" id="proof74">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_id">cvg_id</a></span> {<span class="id">T</span> <span class="id">F</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmap_comp">fmap_comp</a></span> {<span class="id">A</span> <span class="id">B</span> <span class="id">C</span>} (<span class="id">f</span> : <span class="id">B</span> -&gt; <span class="id">C</span>) (<span class="id">g</span> : <span class="id">A</span> -&gt; <span class="id">B</span>) <span class="id">F</span>:<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="id">f</span> \<span class="id">o</span> <span class="id">g</span>)%<span class="id">FUN</span> @ <span class="id">F</span> = <span class="id">f</span> @ (<span class="id">g</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof75')">Proof.</span></div>
<div class="proofscript" id="proof75">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="appfilter">appfilter</a></span> <span class="id">U</span> <span class="id">V</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> = [<span class="id">set</span> <span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">_</span> | \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof76')">Proof.</span></div>
<div class="proofscript" id="proof76">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_app">cvg_app</a></span> <span class="id">U</span> <span class="id">V</span> (<span class="id">F</span> <span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">f</span> @ <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof77')">Proof.</span></div>
<div class="proofscript" id="proof77">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">P</span> /=; <span class="id">exact</span>: <span class="id">FG</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_app">cvg_app</a></span> {<span class="id">U</span> <span class="id">V</span> <span class="id">F</span> <span class="id">G</span>} <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgi_app">cvgi_app</a></span> <span class="id">U</span> <span class="id">V</span> (<span class="id">F</span> <span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">f</span> `@ <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof78')">Proof.</span></div>
<div class="proofscript" id="proof78">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">P</span> /=; <span class="id">exact</span>: <span class="id">FG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_comp">cvg_comp</a></span> <span class="id">T</span> <span class="id">U</span> <span class="id">V</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">U</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">H</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">G</span> `=&gt;` <span class="id">H</span> -&gt; <span class="id">g</span> \<span class="id">o</span> <span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">H</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof79')">Proof.</span></div>
<div class="proofscript" id="proof79">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gGH</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">gGH</span> =&gt; <span class="id">P</span> /<span class="id">fFG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgi_comp">cvgi_comp</a></span> <span class="id">T</span> <span class="id">U</span> <span class="id">V</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id">H</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">G</span> -&gt; <span class="id">g</span> `@ <span class="id">G</span> `=&gt;` <span class="id">H</span> -&gt; <span class="id">g</span> \<span class="id">o</span> <span class="id">f</span> `@ <span class="id">F</span> `=&gt;` <span class="id">H</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof80')">Proof.</span></div>
<div class="proofscript" id="proof80">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gGH</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">gGH</span> =&gt; <span class="id">P</span> /<span class="id">fFG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_eq_cvg">near_eq_cvg</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">g</span> @ <span class="id">F</span> `=&gt;` <span class="id">f</span> @ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof81')">Proof.</span></div>
<div class="proofscript" id="proof81">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">eq_fg</span> <span class="id">P</span> /=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">eq_fg</span> =&gt; <span class="id">x</span> /= &lt;-. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_cvg">eq_cvg</a></span> (<span class="id">T</span> <span class="id">T</span>' : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">T</span>') (<span class="id">x</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;<span class="id">f</span> =1 <span class="id">g</span> -&gt; (<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">x</span>) = (<span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof82')">Proof.</span></div>
<div class="proofscript" id="proof82">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span>-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_is_cvg">eq_is_cvg</a></span> (<span class="id">T</span> <span class="id">T</span>' : <span class="kwd">Type</span>) (<span class="id">fT</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>') (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">T</span>') :<br/>
&nbsp;&nbsp;<span class="id">f</span> =1 <span class="id">g</span> -&gt; [<span class="id">cvg</span> (<span class="id">f</span> @ <span class="id">F</span>) <span class="kwd">in</span> <span class="id">fT</span>] = [<span class="id">cvg</span> (<span class="id">g</span> @ <span class="id">F</span>) <span class="kwd">in</span> <span class="id">fT</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof83')">Proof.</span></div>
<div class="proofscript" id="proof83">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span>-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="neari_eq_loc">neari_eq_loc</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> =2 <span class="id">g</span>} -&gt; <span class="id">g</span> `@ <span class="id">F</span> `=&gt;` <span class="id">f</span> `@ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof84')">Proof.</span></div>
<div class="proofscript" id="proof84">
<span class="id">move</span>=&gt; <span class="id">eq_fg</span> <span class="id">P</span> /=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">eq_fg</span> =&gt; <span class="id">x</span> <span class="id">eq_fg</span> [<span class="id">y</span> [<span class="id">fxy</span> <span class="id">Py</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">rewrite</span> -<span class="id">eq_fg</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_near_const">cvg_near_const</a></span> (<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">y</span>) -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof85')">Proof.</span></div>
<div class="proofscript" id="proof85">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span> <span class="id">fFG</span> <span class="id">P</span> /= <span class="id">GP</span>; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">G</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">fFG</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">x</span> /= -&gt;.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="globally">globally</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">P</span> <span class="id">x</span>].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> {<span class="id">T</span>} <span class="id">A</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="globally0">globally0</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> <span class="id">A</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof86')">Proof.</span></div>
<div class="proofscript" id="proof86">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="globally_filter">globally_filter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof87')">Proof.</span></div>
<div class="proofscript" id="proof87">
<span class="id">constructor</span> =&gt; //= <span class="id">P</span> <span class="id">Q</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">PQ</span> <span class="id">AP</span> <span class="id">x</span> /<span class="id">AP</span> /<span class="id">PQ</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">AP</span> <span class="id">AQ</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">AP</span>|<span class="id">apply</span>: <span class="id">AQ</span>].<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="globally_properfilter">globally_properfilter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id">a</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> (<span class="id">A</span> <span class="id">a</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof88')">Proof.</span></div>
<div class="proofscript" id="proof88">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Aa</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>' =&gt; /(<span class="id">_</span> <span class="id">a</span>). Qed.</div>
<br/>
<h2> Specific filters </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="frechet_filter">frechet_filter</a></span>.<br/>
<span class="kwd">Variable</span> <span class="id"><a name="frechet_filter.T">T</a></span> : <span class="kwd">Type</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="frechet_filter">frechet_filter</a></span> := [<span class="id">set</span> <span class="id">S</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter.T">T</a></span> | <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">finite_set</a></span> (~` <span class="id">S</span>)].<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="frechet_properfilter">frechet_properfilter</a></span> : <span class="id"><a href="mathcomp.classical.cardinality.html#infinite_set">infinite_set</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter.T">T</a></span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof89')">Proof.</span></div>
<div class="proofscript" id="proof89">
<span class="id">move</span>=&gt; <span class="id">infT</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setC0">setC0</a></span>; <span class="id">exact</span>: <span class="id">infT</span>.<br/>
<span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setCT">setCT</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setCI">setCI</a></span> <span class="id"><a href="mathcomp.classical.cardinality.html#finite_setU">finite_setU</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span>; <span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.cardinality.html#sub_finite_set">sub_finite_set</a></span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#subsetC">subsetC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="frechet_properfilter_nat">frechet_properfilter_nat</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof90')">Proof.</span></div>
<div class="proofscript" id="proof90">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#frechet_properfilter">frechet_properfilter</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#infinite_nat">infinite_nat</a></span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="at_point">at_point</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="kwd">Type</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="at_point">at_point</a></span> (<span class="id">a</span> : <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) : <span class="kwd">Prop</span> := <span class="id">P</span> <span class="id">a</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="at_point_filter">at_point_filter</a></span> (<span class="id">a</span> : <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span> <span class="id">a</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof91')">Proof.</span></div>
<div class="proofscript" id="proof91">
 <span class="kwd">by</span> <span class="id">constructor</span>=&gt; //; <span class="id">constructor</span>=&gt; // <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> /<span class="id">subPQ</span>. Qed.</div>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">at_point</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span>.<br/>
<br/>
<div class="doc">Filters for pairs </div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_prod_filter">filter_prod_filter</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof92')">Proof.</span></div>
<div class="proofscript" id="proof92">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>); <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">Q</span>] [<span class="id">P</span>' <span class="id">Q</span>'] /= [<span class="id">FP</span> <span class="id">GQ</span>] [<span class="id">FP</span>' <span class="id">GQ</span>'].<br/>
<span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">P</span>', <span class="id">Q</span> `&amp;` <span class="id">Q</span>') =&gt; /=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] [/= [??] []].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="prod_filter_on">prod_filter_on</a></span> <span class="id">T</span> <span class="id">U</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id">G</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_filter">filter_prod_filter</a></span> <span class="id">_</span> <span class="id">_</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_prod_proper">filter_prod_proper</a></span> {<span class="id">T1</span> <span class="id">T2</span> : <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id">F</span> : (<span class="id">T1</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>} {<span class="id">G</span> : (<span class="id">T2</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span>} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof93')">Proof.</span></div>
<div class="proofscript" id="proof93">
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span> =&gt; -[<span class="id">A</span> <span class="id">B</span>] [/=<span class="id">FA</span> <span class="id">GB</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> [[<span class="id">x</span> ?] [<span class="id">y</span> ?]] := (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">FA</span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">GB</span>); <span class="kwd">exists</span> (<span class="id">x</span>, <span class="id">y</span>).<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">filter_prod_proper</span>' := @<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_proper">filter_prod_proper</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_prod1">filter_prod1</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">_</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof94')">Proof.</span></div>
<div class="proofscript" id="proof94">
<span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>)=&gt; //= [|[?? []//]].<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
Qed.</div>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_prod2">filter_prod2</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span>) -&gt; \<span class="kwd">forall</span> <span class="id">_</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof95')">Proof.</span></div>
<div class="proofscript" id="proof95">
<span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>, <span class="id">P</span>)=&gt; //= [|[?? []//]].<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="in_filter_prod">in_filter_prod</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;(<span class="id">P</span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span>) (<span class="id">Q</span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">G</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>) :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span>.1 /\ <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span> <span class="id">x</span>.2) <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof96')">Next Obligation.</span></div>
<div class="proofscript" id="proof96">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span> <span class="id">P</span> <span class="id">Q</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span>) =&gt; //=; <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofP">prop_ofP</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_pair">near_pair</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span>) (<span class="id">Q</span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">G</span>) <span class="id">x</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span>.1 -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span> <span class="id">x</span>.2 -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filter_prod">in_filter_prod</a></span> <span class="id">P</span> <span class="id">Q</span>) <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof97')">Proof.</span></div>
<div class="proofscript" id="proof97">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">x</span>=&gt; <span class="id">x</span> <span class="id">y</span>; <span class="id">do</span> ?<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /=; <span class="id">split</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fst">cvg_fst</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} :<br/>
&nbsp;&nbsp;(@<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#fst">fst</a></span> <span class="id">T</span> <span class="id">U</span>) @ <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span> --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof98')">Proof.</span></div>
<div class="proofscript" id="proof98">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod1">filter_prod1</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_snd">cvg_snd</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span>} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(@<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">snd</a></span> <span class="id">T</span> <span class="id">U</span>) @ <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span> --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof99')">Proof.</span></div>
<div class="proofscript" id="proof99">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod2">filter_prod2</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_map">near_map</a></span> {<span class="id">T</span> <span class="id">U</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">f</span> @ <span class="id">F</span>, <span class="id">P</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof100')">Proof.</span></div>
<div class="proofscript" id="proof100">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_map2">near_map2</a></span> {<span class="id">T</span> <span class="id">T</span>' <span class="id">U</span> <span class="id">U</span>'} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T</span>' -&gt; <span class="id">U</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) (<span class="id">P</span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>') :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">f</span> @ <span class="id">F</span> &amp; <span class="id">y</span>' \<span class="id">near</span> <span class="id">g</span> @ <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span> <span class="id">y</span>') =<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>     &amp; <span class="id">x</span>' \<span class="id">near</span> <span class="id">G</span>     , <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>')).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof101')">Proof.</span></div>
<div class="proofscript" id="proof101">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; -[[<span class="id">A</span> <span class="id">B</span>] /= [<span class="id">fFA</span> <span class="id">fGB</span>] <span class="id">ABP</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">A</span>, <span class="id">g</span> @^-1` <span class="id">B</span>) =&gt; //= -[<span class="id">x</span> <span class="id">y</span> /=] <span class="id">xyAB</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">apply</span>: <span class="id">xyAB</span>.<br/>
<span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>, <span class="id">g</span> @` <span class="id">B</span>) =&gt; //=; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; -<span class="id">_</span> [/= [<span class="id">x</span> <span class="id">Ax</span> &lt;-] [<span class="id">x</span>' <span class="id">Bx</span>' &lt;-]]; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
<span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> /=; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fFA</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fGB</span> =&gt; <span class="id">x</span> <span class="id">Bx</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_mapi">near_mapi</a></span> {<span class="id">T</span> <span class="id">U</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">f</span> `@ <span class="id">F</span>, <span class="id">P</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof102')">Proof.</span></div>
<div class="proofscript" id="proof102">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_pair_set">filter_pair_set</a></span> (<span class="id">T</span> <span class="id">T</span>' : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">F</span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">P</span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>') (<span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">T</span>')),<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span> <span class="id">x</span>', <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">P</span>' <span class="id">x</span>' -&gt; <span class="id">Q</span> (<span class="id">x</span>, <span class="id">x</span>')) -&gt; <span class="id">F</span> <span class="id">P</span> /\ <span class="id">F</span>' <span class="id">P</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">F</span>' <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof103')">Proof.</span></div>
<div class="proofscript" id="proof103">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FF</span>' <span class="id">P</span> <span class="id">P</span>' <span class="id">Q</span> <span class="id">PQ</span> [<span class="id">FP</span> <span class="id">FP</span>'];<br/>
&nbsp;&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">do</span> [<span class="id">have</span> := <span class="id">PQ</span> <span class="id">x</span>.1 <span class="id">x</span>.2; <span class="id">rewrite</span> -<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">surjective_pairing</a></span>; <span class="id">apply</span>];<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_fst">cvg_fst</a></span> | <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_snd">cvg_snd</a></span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_pair_near_of">filter_pair_near_of</a></span> (<span class="id">T</span> <span class="id">T</span>' : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">F</span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">P</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id">P</span>' : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span>' <span class="id">F</span>') (<span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">T</span>')),<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span> <span class="id">x</span>', <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span>' <span class="id">x</span>' -&gt; <span class="id">Q</span> (<span class="id">x</span>, <span class="id">x</span>')) -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">F</span>' <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof104')">Proof.</span></div>
<div class="proofscript" id="proof104">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FF</span>' [<span class="id">P</span> <span class="id">FP</span>] [<span class="id">P</span>' <span class="id">FP</span>'] <span class="id">Q</span> <span class="id">PQ</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> <span class="kwd">in</span> <span class="id">FP</span> <span class="id">FP</span>' <span class="id">PQ</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id">P</span>') =&gt; //= -[<span class="id">t</span> <span class="id">t</span>'] [] /=; <span class="id">exact</span>: <span class="id">PQ</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">x</span>) <span class="id">ident</span>(<span class="id">y</span>) :=<br/>
&nbsp;&nbsp;(<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_pair_near_of">filter_pair_near_of</a></span> =&gt; <span class="id">x</span> <span class="id">y</span> ? ?).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" <span class="id">constr</span>(<span class="id">F</span>) "=&gt;" <span class="id">ident</span>(<span class="id">x</span>) <span class="id">ident</span>(<span class="id">y</span>) :=<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">F</span>); <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NearMap">NearMap</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NearMap.near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_map">near_map</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_mapi">near_mapi</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_map2">near_map2</a></span>).<br/>
<span class="kwd">Ltac</span> <span class="id">near_simpl</span> := <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#NearMap.near_simpl">near_simpl</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearMap">NearMap</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_pair">cvg_pair</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">V</span> <span class="id">F</span>} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)} {<span class="id">H</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} {<span class="id">FH</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">H</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">H</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">f</span> <span class="id">x</span>, <span class="id">g</span> <span class="id">x</span>) @[<span class="id">x</span> --&gt; <span class="id">F</span>] --&gt; (<span class="id">G</span>, <span class="id">H</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof105')">Proof.</span></div>
<div class="proofscript" id="proof105">
<span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gFH</span> <span class="id">P</span>; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span> =&gt; -[[<span class="id">A</span> <span class="id">B</span>] /=[<span class="id">GA</span> <span class="id">HB</span>] <span class="id">ABP</span>]; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">split</span>=&gt; //=; <span class="id">near</span>: <span class="id">x</span>; [<span class="id">apply</span>: <span class="id">fFG</span>|<span class="id">apply</span>: <span class="id">gFH</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_comp2">cvg_comp2</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">V</span> <span class="id">W</span>}<br/>
&nbsp;&nbsp;{<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)} {<span class="id">H</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)} {<span class="id">I</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">W</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} {<span class="id">FH</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">H</span>}<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">h</span> : <span class="id">U</span> -&gt; <span class="id">V</span> -&gt; <span class="id">W</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">H</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#fst">fst</a></span> <span class="id">x</span>) (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">snd</a></span> <span class="id">x</span>) @[<span class="id">x</span> --&gt; (<span class="id">G</span>, <span class="id">H</span>)] --&gt; <span class="id">I</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>) @[<span class="id">x</span> --&gt; <span class="id">F</span>] --&gt; <span class="id">I</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof106')">Proof.</span></div>
<div class="proofscript" id="proof106">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gFH</span> <span class="id">hGHI</span> <span class="id">P</span> /= <span class="id">IP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_pair">cvg_pair</a></span> (<span class="id">hGHI</span> <span class="id">_</span> <span class="id">IP</span>). Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp2">cvg_comp2</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">V</span> <span class="id">W</span> <span class="id">F</span> <span class="id">G</span> <span class="id">H</span> <span class="id">I</span> <span class="id">FF</span> <span class="id">FG</span> <span class="id">FH</span> <span class="id">f</span> <span class="id">g</span> <span class="id">h</span>} <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cvg_to_comp_2">cvg_to_comp_2</a></span> := @<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp2">cvg_comp2</a></span>.<br/>
<br/>
<br/>
<div class="doc">Restriction of a filter to a domain </div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="within">within</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="kwd">Type</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="within">within</a></span> <span class="id">D</span> <span class="id">F</span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) := {<span class="id">near</span> <span class="id">F</span>, <span class="id">D</span> `&lt;=` <span class="id">P</span>}.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_withinE">near_withinE</a></span> <span class="id">D</span> <span class="id">F</span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = {<span class="id">near</span> <span class="id">F</span>, <span class="id">D</span> `&lt;=` <span class="id">P</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof107')">Proof.</span></div>
<div class="proofscript" id="proof107">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinT">withinT</a></span> <span class="id">F</span> <span class="id">D</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof108')">Proof.</span></div>
<div class="proofscript" id="proof108">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_withinT">near_withinT</a></span> <span class="id">F</span> <span class="id">D</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>, <span class="id">D</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof109')">Proof.</span></div>
<div class="proofscript" id="proof109">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#withinT">withinT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_within">cvg_within</a></span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} <span class="id">D</span> : <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span> --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof110')">Proof.</span></div>
<div class="proofscript" id="proof110">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinET">withinET</a></span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} : <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">F</span> = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof111')">Proof.</span></div>
<div class="proofscript" id="proof111">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">split</span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nearW">nearW</a></span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="within_filter">within_filter</a></span> <span class="id">T</span> <span class="id">D</span> <span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">T</span> <span class="id">D</span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof112')">Proof.</span></div>
<div class="proofscript" id="proof112">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">constructor</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> =&gt; <span class="id">x</span> <span class="id">DP</span> <span class="id">DQ</span> <span class="id">Dx</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">DP</span>|<span class="id">apply</span>: <span class="id">DQ</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">x</span> <span class="id">DP</span> /<span class="id">DP</span> /<span class="id">subPQ</span>.<br/>
Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">within</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="within_filter_on">within_filter_on</a></span> <span class="id">T</span> <span class="id">D</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#within_filter">within_filter</a></span> <span class="id">_</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="subset_filter">subset_filter</a></span> {<span class="id">T</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> {<span class="id">x</span> | <span class="id">D</span> <span class="id">x</span>} | <span class="id">F</span> [<span class="id">set</span> <span class="id">x</span> | <span class="kwd">forall</span> <span class="id">Dx</span> : <span class="id">D</span> <span class="id">x</span>, <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">exist</a></span> <span class="id">_</span> <span class="id">x</span> <span class="id">Dx</span>)]].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> {<span class="id">T</span>} <span class="id">F</span> <span class="id">D</span> <span class="id">_</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="subset_filter_filter">subset_filter_filter</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> <span class="id">F</span> <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof113')">Proof.</span></div>
<div class="proofscript" id="proof113">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">constructor</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span>/=.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span>=&gt; <span class="id">x</span> <span class="id">PD</span> <span class="id">QD</span> <span class="id">Dx</span>; <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">R</span> <span class="id">PD</span> <span class="id">Dx</span>; <span class="id">apply</span>: <span class="id">subPQ</span>.<br/>
Qed.</div>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">subset_filter</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="subset_filter_proper">subset_filter_proper</a></span> {<span class="id">T</span> <span class="id">F</span>} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">F</span> <span class="id">P</span> -&gt; ~ ~ <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">D</span> <span class="id">x</span> /\ <span class="id">P</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> <span class="id">F</span> <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof114')">Proof.</span></div>
<div class="proofscript" id="proof114">
<span class="id">move</span>=&gt; <span class="id">DAP</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>'; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> =&gt; <span class="id">subFD</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /(<span class="id">_</span> <span class="id">subFD</span>) := <span class="id">DAP</span> (~` <span class="id">D</span>); <span class="id">apply</span> =&gt; -[<span class="id">x</span> [<span class="id">dx</span> /(<span class="id">_</span> <span class="id">dx</span>)]].<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="NearSet">NearSet</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">choiceType</span>} {<span class="id">Y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>}.<br/>
<span class="kwd">Context</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>)) (<span class="id">PF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="powerset_filter_from">powerset_filter_from</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>)) := <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">M</span> | [/\ <span class="id">M</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">E1</span> <span class="id">E2</span>, <span class="id">M</span> <span class="id">E1</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E2</span> -&gt; <span class="id">E2</span> `&lt;=` <span class="id">E1</span> -&gt; <span class="id">M</span> <span class="id">E2</span>) &amp; <span class="id">M</span> !=<span class="id">set0</span> ] ]<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="powerset_filter_from_filter">powerset_filter_from_filter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof115')">Proof.</span></div>
<div class="proofscript" id="proof115">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id"><a href="mathcomp.classical.boolp.html#xpredp0">xpredp0</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">W</span> [<span class="id">_</span> <span class="id">_</span> [<span class="id">N</span> +]]]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subset0">subset0</a></span> =&gt; /[<span class="id">swap</span>] -&gt;; <span class="id">apply</span>.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span>; <span class="id">split</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">M</span> <span class="id">N</span> /= [<span class="id">entM</span> <span class="id">subM</span> [<span class="id">M0</span> <span class="id">MM0</span>]] [<span class="id">entN</span> <span class="id">subN</span> [<span class="id">N0</span> <span class="id">NN0</span>]].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">E</span> | <span class="kwd">exists</span> <span class="id">P</span> <span class="id">Q</span>, [/\ <span class="id">M</span> <span class="id">P</span>, <span class="id">N</span> <span class="id">Q</span> &amp; <span class="id">E</span> = <span class="id">P</span> `&amp;` <span class="id">Q</span>] ]; <span class="id">first</span> <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [? [? [? ? -&gt;]]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">exact</span>: <span class="id">entM</span> | <span class="id">exact</span>: <span class="id">entN</span>].<br/>
- <span class="id">move</span>=&gt; ? <span class="id">E2</span> [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">MP</span> <span class="id">MQ</span> -&gt;]]] <span class="id">entE2</span> <span class="id">E2subPQ</span>; <span class="kwd">exists</span> <span class="id">E2</span>, <span class="id">E2</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">setIid</a></span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subM</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MP</span>) =&gt; // ? /<span class="id">E2subPQ</span> [].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subN</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MQ</span>) =&gt; // ? /<span class="id">E2subPQ</span> [].<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">M0</span> `&amp;` <span class="id">N0</span>), <span class="id">M0</span>, <span class="id">N0</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">E</span> /= [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">MP</span> <span class="id">MQ</span> -&gt;]]]; <span class="id">have</span> <span class="id">entPQ</span> : <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">exact</span>: <span class="id">entM</span> | <span class="id">exact</span>: <span class="id">entN</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: (<span class="id">subM</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MP</span>) | <span class="id">apply</span>: (<span class="id">subN</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MQ</span>)] =&gt; // ? [].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_small_set">near_small_set</a></span> : \<span class="kwd">forall</span> <span class="id">E</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof116')">Proof.</span></div>
<div class="proofscript" id="proof116">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="small_set_sub">small_set_sub</a></span> (<span class="id">E</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">E</span>' \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id">E</span>' `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof117')">Proof.</span></div>
<div class="proofscript" id="proof117">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">E</span>' | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span>' /\ <span class="id">E</span>' `&lt;=` <span class="id">E</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
<span class="id">split</span>; [<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span>' [] | | <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [] ? <span class="id">sub</span> ? ?; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_powerset_filter_fromP">near_powerset_filter_fromP</a></span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">A</span> <span class="id">B</span>, <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">P</span> <span class="id">B</span> -&gt; <span class="id">P</span> <span class="id">A</span>) -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">U</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id">P</span> <span class="id">U</span>) &lt;-&gt; <span class="kwd">exists2</span> <span class="id">U</span>, <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">U</span> &amp; <span class="id">P</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof118')">Proof.</span></div>
<div class="proofscript" id="proof118">
<span class="id">move</span>=&gt; <span class="id">Psub</span>; <span class="id">split</span>=&gt; [[<span class="id">M</span> [<span class="id">FM</span> ? [<span class="id">U</span> <span class="id">MU</span>]]] <span class="id">MsubP</span>|[<span class="id">U</span> <span class="id">FU</span> <span class="id">PU</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">U</span>; [<span class="id">exact</span>: <span class="id">FM</span> | <span class="id">exact</span>: <span class="id">MsubP</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">V</span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">V</span> /\ <span class="id">V</span> `&lt;=` <span class="id">U</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">V</span> [<span class="id">_</span>] /<span class="id">Psub</span>; <span class="id">exact</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">E</span> [] //| |]; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">split</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [<span class="id">F1</span> <span class="id">E1U</span> <span class="id">F2</span> <span class="id">E2subE1</span>]; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">E1U</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="powerset_filter_fromP">powerset_filter_fromP</a></span> <span class="id">C</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">C</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span> [<span class="id">set</span> <span class="id">W</span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof119')">Proof.</span></div>
<div class="proofscript" id="proof119">
<span class="id">move</span>=&gt; <span class="id">FC</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">W</span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>] =&gt; //; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">_</span> <span class="id">AC</span>] <span class="id">FB</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span>/(<span class="id">_</span> <span class="id">AC</span>).<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet">NearSet</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="PrincipalFilters">PrincipalFilters</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="principal_filter">principal_filter</a></span> {<span class="id">X</span> : <span class="kwd">Type</span>} (<span class="id">x</span> : <span class="id">X</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="principal_filterP">principal_filterP</a></span> {<span class="id">X</span>} (<span class="id">x</span> : <span class="id">X</span>) (<span class="id">W</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span> <span class="id">x</span> <span class="id">W</span> &lt;-&gt; <span class="id">W</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof120')">Proof.</span></div>
<div class="proofscript" id="proof120">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [|? ? -&gt;]; [<span class="id">exact</span>|]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="principal_filter_proper">principal_filter_proper</a></span> {<span class="id">X</span>} (<span class="id">x</span> : <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof121')">Proof.</span></div>
<div class="proofscript" id="proof121">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#globally_properfilter">globally_properfilter</a></span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="bool_discrete_filter">bool_discrete_filter</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PrincipalFilters">PrincipalFilters</a></span>.<br/>
<br/>
<h1> Topological spaces </h1>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Topological">Topological</a></span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="Topological.mixin_of">mixin_of</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">nbhs</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.open">open</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.nbhs_pfilter">nbhs_pfilter</a></span> : <span class="kwd">forall</span> <span class="id">p</span> : <span class="id">T</span>, <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">nbhs</span> <span class="id">p</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.nbhsE">nbhsE</a></span> : <span class="kwd">forall</span> <span class="id">p</span> : <span class="id">T</span>, <span class="id">nbhs</span> <span class="id">p</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="kwd">exists</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, [/\ <span class="id">open</span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>] ] ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.openE">openE</a></span> : <span class="id">open</span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="id">A</span> `&lt;=` <span class="id">nbhs</span>^~ <span class="id">A</span> ]<br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="Topological.class_of">class_of</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.base">base</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">Filtered.class_of</a></span> <span class="id">T</span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.mixin">mixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_op">Filtered.nbhs_op</a></span> <span class="id">base</span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Topological.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Topological.type">type</a></span> := <span class="id">Pack</span> { <span class="id"><a name="Topological.sort">sort</a></span>; <span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="Topological.ClassDef.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Topological.ClassDef.cT">cT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.type">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.class">class</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="kwd">return</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.clone">clone</a></span> <span class="id">c</span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="Topological.ClassDef.xT">xT</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#T">T</a></span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.xclass">xclass</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#Topological.class">class</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.xT">xT</a></span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Filtered.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.pack">pack</a></span> <span class="id">nbhs</span>' (<span class="id">m</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">nbhs</span>') :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> (<span class="id">b</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">Filtered.class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">Filtered.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">m</span>'   <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_op">Filtered.nbhs_op</a></span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> (@<span class="kwd">Class</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.eqType">eqType</a></span> := @<span class="id">Equality.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.choiceType">choiceType</a></span> := @<span class="id">Choice.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.pointedType">pointedType</a></span> := @<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Pack">Pointed.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.filteredType">filteredType</a></span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Filtered.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Topological.Exports">Exports</a></span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Filtered.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.eqType">eqType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.choiceType">choiceType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.pointedType">pointedType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.filteredType">filteredType</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.topologicalType">topologicalType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.type">type</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.TopologicalType">TopologicalType</a></span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.pack">pack</a></span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>).<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.TopologicalMixin">TopologicalMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Mixin">Mixin</a></span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">topologicalType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.clone">clone</a></span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">topologicalType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">topologicalType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.clone">clone</a></span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">topologicalType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports">Exports</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological">Topological</a></span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports">Topological.Exports</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Topological1">Topological1</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open">open</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#open">Topological.open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#class">Topological.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_nbhs">open_nbhs</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> /\ <span class="id">A</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="basis">basis</a></span> (<span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>)) :=<br/>
&nbsp;&nbsp;<span class="id">B</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> /\ <span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> [<span class="id">set</span> <span class="id">U</span> | <span class="id">B</span> <span class="id">U</span> /\ <span class="id">U</span> <span class="id">x</span>] <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> --&gt; <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="second_countable">second_countable</a></span> := <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> <span class="id">B</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#basis">basis</a></span> <span class="id">B</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="nbhs_pfilter">nbhs_pfilter</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof122')">Proof.</span></div>
<div class="proofscript" id="proof122">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">Topological.nbhs_pfilter</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> <span class="id">p</span> =&gt; ? []. Qed.</div>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">nbhs</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filter">nbhs_filter</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof123')">Proof.</span></div>
<div class="proofscript" id="proof123">
 <span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">nbhs_pfilter</a></span>). Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nbhs_filter_on">nbhs_filter_on</a></span> (<span class="id">x</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter">nbhs_filter</a></span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhsE">nbhsE</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="kwd">exists2</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">B</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof124')">Proof.</span></div>
<div class="proofscript" id="proof124">
<span class="id">have</span> -&gt; : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="kwd">exists</span> <span class="id">B</span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>] ].<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">Topological.nbhsE</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [[<span class="id">B</span> [?]]|[<span class="id">B</span>[]]]; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsE">open_nbhsE</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> = (<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof125')">Proof.</span></div>
<div class="proofscript" id="proof125">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; [[? ?]|[? [<span class="id">B</span> [? ?] <span class="id">BA</span>]]]; <span class="id">split</span> =&gt; //;<br/>
&nbsp;&nbsp;[<span class="kwd">exists</span> <span class="id">A</span> | <span class="id">exact</span>: <span class="id">BA</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="interior">interior</a></span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>)^~ <span class="id">A</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^°" := (<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interior_subset">interior_subset</a></span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id">A</span>^° `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof126')">Proof.</span></div>
<div class="proofscript" id="proof126">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[? [? ?]]; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openE">openE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="id">A</span> `&lt;=` <span class="id">A</span>^°].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof127')">Proof.</span></div>
<div class="proofscript" id="proof127">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openE">Topological.openE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_singleton">nbhs_singleton</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof128')">Proof.</span></div>
<div class="proofscript" id="proof128">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [? [<span class="id">_</span> ?]]; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_interior">nbhs_interior</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof129')">Proof.</span></div>
<div class="proofscript" id="proof129">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>] <span class="id">sBA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // <span class="id">q</span> <span class="id">Bq</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sBA</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Bop</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open0">open0</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof130')">Proof.</span></div>
<div class="proofscript" id="proof130">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openT">openT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof131')">Proof.</span></div>
<div class="proofscript" id="proof131">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openI">openI</a></span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof132')">Proof.</span></div>
<div class="proofscript" id="proof132">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span> <span class="id">Bop</span> <span class="id">p</span> [<span class="id">Ap</span> <span class="id">Bp</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">apply</span>: <span class="id">Aop</span>|<span class="id">apply</span>: <span class="id">Bop</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigcup_open">bigcup_open</a></span> (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof133')">Proof.</span></div>
<div class="proofscript" id="proof133">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">fop</span> <span class="id">p</span> [<span class="id">i</span> <span class="id">Di</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">fop</span> <span class="id">fiop</span> := <span class="id">Di</span>; <span class="id">move</span>/<span class="id">fiop</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ??; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openU">openU</a></span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof134')">Proof.</span></div>
<div class="proofscript" id="proof134">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span> <span class="id">Bop</span> <span class="id">p</span> [/<span class="id">Aop</span>|/<span class="id">Bop</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ??; [<span class="id">left</span>|<span class="id">right</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_subsetE">open_subsetE</a></span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; (<span class="id">A</span> `&lt;=` <span class="id">B</span>) = (<span class="id">A</span> `&lt;=` <span class="id">B</span>^°).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof135')">Proof.</span></div>
<div class="proofscript" id="proof135">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAB</span> <span class="id">p</span> <span class="id">Ap</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sAB</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Aop</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAB</span> <span class="id">p</span> /<span class="id">sAB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">interior_subset</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_interior">open_interior</a></span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof136')">Proof.</span></div>
<div class="proofscript" id="proof136">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">p</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>]].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_subsetE">open_subsetE</a></span> //; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interior_bigcup">interior_bigcup</a></span> <span class="id">I</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">f</span> <span class="id">i</span>)^° `&lt;=` (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span>)^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof137')">Proof.</span></div>
<div class="proofscript" id="proof137">
<span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">i</span> <span class="id">Di</span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>] <span class="id">sBfi</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // ? /<span class="id">sBfi</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsT">open_nbhsT</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof138')">Proof.</span></div>
<div class="proofscript" id="proof138">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openT">openT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsI">open_nbhsI</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof139')">Proof.</span></div>
<div class="proofscript" id="proof139">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Aop</span> <span class="id">Ap</span>] [<span class="id">Bop</span> <span class="id">Bp</span>]; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span>|<span class="id">split</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhs_nbhs">open_nbhs_nbhs</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof140')">Proof.</span></div>
<div class="proofscript" id="proof140">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; <span class="id">p_A</span>; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interiorI">interiorI</a></span> (<span class="id">A</span> <span class="id">B</span>:<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>): (<span class="id">A</span> `&amp;` <span class="id">B</span>)^° = <span class="id">A</span>^° `&amp;` <span class="id">B</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof141')">Proof.</span></div>
<div class="proofscript" id="proof141">
<span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; //= <span class="id">x</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>; <span class="id">split</span> =&gt; [[<span class="id">B0</span> ?] | []].<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">subsetI</a></span> =&gt; // -[? ?]; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">B0</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; -[<span class="id">B0</span> ? ?] [<span class="id">B1</span> ? ?]; <span class="kwd">exists</span> (<span class="id">B0</span> `&amp;` <span class="id">B1</span>);<br/>
&nbsp;&nbsp;[<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsI">open_nbhsI</a></span> | <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">subsetI</a></span>; <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subIset">subIset</a></span>; [<span class="id">left</span>|<span class="id">right</span>]].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1">Topological1</a></span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>)) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter">nbhs_filter</a></span>] : <span class="id">typeclass_instances</span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>)) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">nbhs_pfilter</a></span>] : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">A</span> ^°" := (<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id">A</span>) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Notation</span> <span class="id"><a name="continuous">continuous</a></span> <span class="id">f</span> := (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">f</span>%<span class="id">function</span> @ <span class="id">x</span> --&gt; <span class="id">f</span>%<span class="id">function</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_fun">near_fun</a></span> (<span class="id">T</span> <span class="id">T</span>' : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">T</span>') (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">P</span> : <span class="id">T</span>' -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">f</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">y</span>) -&gt; (\<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof142')">Proof.</span></div>
<div class="proofscript" id="proof142">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_fun">near_fun</a></span> {<span class="id">T</span> <span class="id">T</span>'} <span class="id">f</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuousP">continuousP</a></span> (<span class="id">S</span> <span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">f</span> : <span class="id">S</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof143')">Proof.</span></div>
<div class="proofscript" id="proof143">
<span class="id">split</span>=&gt; <span class="id">fcont</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">A</span> <span class="id">Aop</span> ? /<span class="id">Aop</span> /<span class="id">fcont</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">s</span> <span class="id">A</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span> /= !<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bfs</span>] <span class="id">sBA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">B</span>); [<span class="id">split</span>=&gt; //; <span class="id">apply</span>/<span class="id">fcont</span>|<span class="id">move</span>=&gt; ? /<span class="id">sBA</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_comp">continuous_comp</a></span> (<span class="id">R</span> <span class="id">S</span> <span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">f</span> : <span class="id">R</span> -&gt; <span class="id">S</span>) (<span class="id">g</span> : <span class="id">S</span> -&gt; <span class="id">T</span>) <span class="id">x</span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; {<span class="kwd">for</span> (<span class="id">f</span> <span class="id">x</span>), <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">g</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="id">g</span> \<span class="id">o</span> <span class="id">f</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof144')">Proof.</span></div>
<div class="proofscript" id="proof144">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_comp">open_comp</a></span>  {<span class="id">T</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">f</span> @^-1` <span class="id">D</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">D</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> @^-1` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof145')">Proof.</span></div>
<div class="proofscript" id="proof145">
<span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">fcont</span> <span class="id">Dop</span> <span class="id">x</span> /= <span class="id">Dfx</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">fcont</span>; [<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>|<span class="id">apply</span>: <span class="id">Dop</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fmap">cvg_fmap</a></span> {<span class="id">T</span>: <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} {<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) <span class="id">x</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; <span class="id">F</span> --&gt; <span class="id">x</span> -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">f</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof146')">Proof.</span></div>
<div class="proofscript" id="proof146">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">cf</span> <span class="id">fx</span> <span class="id">P</span> /<span class="id">cf</span> /<span class="id">fx</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_join">near_join</a></span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="id">near</span> <span class="id">x</span>, \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof147')">Proof.</span></div>
<div class="proofscript" id="proof147">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_bind">near_bind</a></span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">P</span> <span class="id">Q</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="id">near</span> <span class="id">x</span>, (\<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; (\<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="id">near</span> <span class="id">x</span>, <span class="id">Q</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof148')">Proof.</span></div>
<div class="proofscript" id="proof148">
<span class="id">move</span>=&gt; <span class="id">PQ</span> <span class="id">xP</span>; <span class="id">near</span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">PQ</span> <span class="id">y</span>) =&gt; //;<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#near_join">near_join</a></span> <span class="id">xP</span>) <span class="id">y</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_cvg">continuous_cvg</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">V</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">h</span> : <span class="id">V</span> -&gt; <span class="id">U</span>) (<span class="id">a</span> : <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">a</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">h</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">a</span> -&gt; (<span class="id">h</span> \<span class="id">o</span> <span class="id">f</span>) @ <span class="id">F</span> --&gt; <span class="id">h</span> <span class="id">a</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof149')">Proof.</span></div>
<div class="proofscript" id="proof149">
<span class="id">move</span>=&gt; <span class="id">h_continuous</span> <span class="id">fa</span> <span class="id">fb</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">_</span> <span class="id">h_continuous</span>).<br/>
<span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">h</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">fa</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_is_cvg">continuous_is_cvg</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">V</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} [<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)]<br/>
&nbsp;&nbsp;(<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">h</span> : <span class="id">V</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">f</span> <span class="id">x</span> @[<span class="id">x</span> --&gt; <span class="id">F</span>] --&gt; <span class="id">l</span> -&gt; {<span class="kwd">for</span> <span class="id">l</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">h</span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> <span class="id">x</span> @[<span class="id">x</span> --&gt; <span class="id">F</span>]) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> ((<span class="id">h</span> \<span class="id">o</span> <span class="id">f</span>) <span class="id">x</span> @[<span class="id">x</span> --&gt; <span class="id">F</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof150')">Proof.</span></div>
<div class="proofscript" id="proof150">
<span class="id">move</span>=&gt; <span class="id">ach</span> /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>[<span class="id">l</span> <span class="id">fxl</span>]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> (<span class="id">h</span> <span class="id">l</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#continuous_cvg">continuous_cvg</a></span> =&gt; //; <span class="id">exact</span>: <span class="id">ach</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous2_cvg">continuous2_cvg</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">V</span> <span class="id">W</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">W</span>) (<span class="id">h</span> : <span class="id">V</span> -&gt; <span class="id">W</span> -&gt; <span class="id">U</span>) (<span class="id">a</span> : <span class="id">V</span>) (<span class="id">b</span> : <span class="id">W</span>) :<br/>
&nbsp;&nbsp;<span class="id">h</span> <span class="id">z</span>.1 <span class="id">z</span>.2 @[<span class="id">z</span> --&gt; (<span class="id">a</span>, <span class="id">b</span>)] --&gt; <span class="id">h</span> <span class="id">a</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">a</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">b</span> -&gt; (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">h</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>)) @ <span class="id">F</span> --&gt; <span class="id">h</span> <span class="id">a</span> <span class="id">b</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof151')">Proof.</span></div>
<div class="proofscript" id="proof151">
<span class="id">move</span>=&gt; <span class="id">h_continuous</span> <span class="id">fa</span> <span class="id">fb</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">_</span> <span class="id">h_continuous</span>).<br/>
<span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">h</span> <span class="id">x</span>.1 <span class="id">x</span>.2) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_pair">cvg_pair</a></span> <span class="id">fa</span> <span class="id">fb</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_near_cst">cvg_near_cst</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id">l</span> : <span class="id">U</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof152')">Proof.</span></div>
<div class="proofscript" id="proof152">
<span class="id">move</span>=&gt; <span class="id">fFl</span> <span class="id">P</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span> =&gt; <span class="id">Pl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fFl</span> =&gt; <span class="id">_</span> -&gt;; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>.<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> {<span class="id">f</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="is_cvg_near_cst">is_cvg_near_cst</a></span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id">l</span> : <span class="id">U</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof153')">Proof.</span></div>
<div class="proofscript" id="proof153">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#is_cvg_near_cst">is_cvg_near_cst</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> {<span class="id">f</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_cst_continuous">near_cst_continuous</a></span> (<span class="id">T</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id">l</span> : <span class="id">U</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">y</span> = <span class="id">l</span>) -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof154')">Proof.</span></div>
<div class="proofscript" id="proof154">
<span class="id">move</span>=&gt; <span class="id">eq_f_l</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> (<span class="id">eq_f_l</span>) =&gt; <span class="id">y</span> -&gt;.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">eq_f_l</span>).<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_cst_continuous">near_cst_continuous</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> [<span class="id">f</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_cst">cvg_cst</a></span> (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">x</span> : <span class="id">U</span>) (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>) @ <span class="id">F</span> --&gt; <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof155')">Proof.</span></div>
<div class="proofscript" id="proof155">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>; <span class="id">near</span>=&gt; <span class="id">x0</span>. <span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span> {<span class="id">U</span>} <span class="id">x</span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">cvg_cst</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="is_cvg_cst">is_cvg_cst</a></span> (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">x</span> : <span class="id">U</span>) (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> ((<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>) @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof156')">Proof.</span></div>
<div class="proofscript" id="proof156">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#is_cvg_cst">is_cvg_cst</a></span> {<span class="id">U</span>} <span class="id">x</span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">is_cvg_cst</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cst_continuous">cst_continuous</a></span> {<span class="id">T</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">x</span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof157')">Proof.</span></div>
<div class="proofscript" id="proof157">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="within_topologicalType">within_topologicalType</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>).<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_nbhsW">within_nbhsW</a></span> (<span class="id">x</span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof158')">Proof.</span></div>
<div class="proofscript" id="proof158">
<span class="id">move</span>=&gt; <span class="id">Ax</span> <span class="id">P</span> <span class="id">AP</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">near</span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: <span class="id">AP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="locally_of">locally_of</a></span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) -&gt; <span class="kwd">Prop</span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="kwd">Prop</span> (<span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>))<br/>
&nbsp;&nbsp;:= <span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>)).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#locally_of">locally_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">P</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_interior">within_interior</a></span> (<span class="id">x</span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>^° <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) = <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof159')">Proof.</span></div>
<div class="proofscript" id="proof159">
<span class="id">move</span>=&gt; <span class="id">Aox</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span>.<br/>
<span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; <span class="id">W</span> /= =&gt; [[<span class="id">B</span> + <span class="id">BsubW</span>]].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">open_nbhsE</a></span> =&gt; [[<span class="id">oB</span> <span class="id">nbhsB</span>]].<br/>
<span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>^°); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> /= [] /<span class="id">BsubW</span> + /<span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">interior_subset</a></span>; <span class="id">apply</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">open_nbhsE</a></span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_interior">open_interior</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> =&gt; //; <span class="id">move</span>:(<span class="id"><a href="mathcomp.analysis.topology.html#open_interior">open_interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_subset">within_subset</a></span> <span class="id">B</span> <span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> `&lt;=` <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">B</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof160')">Proof.</span></div>
<div class="proofscript" id="proof160">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">AsubB</span> <span class="id">W</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span> =&gt; ? + ?; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">AsubB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinE">withinE</a></span> <span class="id">F</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">U</span> | <span class="kwd">exists2</span> <span class="id">V</span>, <span class="id">F</span> <span class="id">V</span> &amp; <span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> = <span class="id">V</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof161')">Proof.</span></div>
<div class="proofscript" id="proof161">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>=&gt; <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">Wu</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">x</span> | <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id">U</span> <span class="id">x</span>] =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; <span class="id">t</span> [<span class="id">L</span> <span class="id">R</span>]; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">L</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">V</span> <span class="id">FV</span> <span class="id">AU</span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="id">near</span>=&gt; <span class="id">w</span> =&gt; <span class="id">Aw</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> []// : (<span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>) <span class="id">w</span>; <span class="id">rewrite</span> <span class="id">AU</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FV</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmap_within_eq">fmap_within_eq</a></span> {<span class="id">S</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>)) (<span class="id">f</span> <span class="id">g</span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; {<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> --&gt; <span class="id">g</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof162')">Proof.</span></div>
<div class="proofscript" id="proof162">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">feq</span> <span class="id">U</span> /=; <span class="id">near_simpl</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>.<br/>
<span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="id">near_simpl</span>; <span class="id">near</span>=&gt; <span class="id">w</span>; <span class="id">rewrite</span> (<span class="id">feq</span> <span class="id">w</span>) // <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>.<br/>
<span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#withinT">withinT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">FF</span>) <span class="id">w</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType">within_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#locally_of">locally_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">P</span>)).<br/>
<br/>
<h2> Topology defined by a filter </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfFilter">TopologyOfFilter</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">nbhs</span>' : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)}.<br/>
<span class="kwd">Hypothesis</span> (<span class="id">nbhs</span>'<span class="id">_filter</span> : <span class="kwd">forall</span> <span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">nbhs</span>' <span class="id">p</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">nbhs</span>'<span class="id">_singleton</span> : <span class="kwd">forall</span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>), <span class="id">nbhs</span>' <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">nbhs</span>'<span class="id">_nbhs</span>' : <span class="kwd">forall</span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>), <span class="id">nbhs</span>' <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span>' <span class="id">p</span> (<span class="id">nbhs</span>'^~ <span class="id">A</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_of_nbhs">open_of_nbhs</a></span> := [<span class="id">set</span> <span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span> | <span class="id">A</span> `&lt;=` <span class="id">nbhs</span>'^~ <span class="id">A</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfFilterMixin">topologyOfFilterMixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#mixin_of">Topological.mixin_of</a></span> <span class="id">nbhs</span>' :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Mixin">Topological.Mixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span> <span class="id">nbhs</span>' <span class="id"><a href="mathcomp.analysis.topology.html#open_of_nbhs">open_of_nbhs</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof163')">Next Obligation.</span></div>
<div class="proofscript" id="proof163">
<span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">p_A</span>|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sBA</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Bop</span>.<br/>
<span class="kwd">exists</span> (<span class="id">nbhs</span>'^~ <span class="id">A</span>) ; <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>: <span class="id">nbhs</span>'<span class="id">_nbhs</span>'.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> /<span class="id">nbhs</span>'<span class="id">_singleton</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof164')">Next Obligation.</span></div>
<div class="proofscript" id="proof164">
 <span class="id">done</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter">TopologyOfFilter</a></span>.<br/>
<br/>
<h2> Topology defined by open sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfOpen">TopologyOfOpen</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfOpen.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfOpen.op">op</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> -&gt; <span class="kwd">Prop</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.opT">opT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.opI">opI</a></span> : <span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>), <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.op_bigU">op_bigU</a></span> : <span class="kwd">forall</span> (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (\<span class="id">bigcup_i</span> <span class="id">f</span> <span class="id">i</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs_of_open">nbhs_of_open</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">B</span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfOpenMixin">topologyOfOpenMixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#mixin_of">Topological.mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Mixin">Topological.Mixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof165')">Next Obligation.</span></div>
<div class="proofscript" id="proof165">
<span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">B</span> [<span class="id">_</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">C</span> [<span class="id">Cop</span> <span class="id">Cp</span> <span class="id">sCA</span>]] [<span class="id">D</span> [<span class="id">Dop</span> <span class="id">Dp</span> <span class="id">sDB</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">C</span> `&amp;` <span class="id">D</span>); <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.opI">opI</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> [/<span class="id">sCA</span> <span class="id">Aq</span> /<span class="id">sDB</span> <span class="id">Bq</span>].<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> [<span class="id">C</span> [<span class="id">Cop</span> <span class="id">p_C</span> <span class="id">sCA</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sAB</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof166')">Next Obligation.</span></div>
<div class="proofscript" id="proof166">
 <span class="id">done</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof167')">Next Obligation.</span></div>
<div class="proofscript" id="proof167">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">Aop</span> <span class="id">p</span> <span class="id">Ap</span>|<span class="id">Aop</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span>; <span class="id">split</span>=&gt; //; <span class="id">split</span>.<br/>
<span class="id">suff</span> -&gt; : <span class="id">A</span> = \<span class="id">bigcup_</span>(<span class="id">B</span> : {<span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span> /\ <span class="id">B</span> `&lt;=` <span class="id">A</span>}) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op_bigU">op_bigU</a></span> =&gt; <span class="id">B</span>; <span class="id">have</span> [] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> <span class="id">B</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [|[<span class="id">B</span> <span class="id">_</span> <span class="id">Bp</span>]]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> <span class="id">B</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">Aop</span> [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">B</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">conj</a></span> <span class="id">Bop</span> <span class="id">sBA</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen">TopologyOfOpen</a></span>.<br/>
<br/>
<h2> Topology defined by a base of open sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfBase">TopologyOfBase</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_from">open_from</a></span> <span class="id">I</span> <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">b</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>') <span class="id">b</span> <span class="id">i</span> | <span class="id">D</span>' <span class="kwd">in</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subset">subset</a></span>^~ <span class="id">D</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_fromT">open_fromT</a></span> <span class="id">I</span> <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">b</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">b</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id">D</span> <span class="id">b</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof168')">Proof.</span></div>
<div class="proofscript" id="proof168">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">D</span>. Qed.</div>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfBase.I">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="TopologyOfBase.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfBase.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="TopologyOfBase.b">b</a></span> : <span class="id">I</span> -&gt; (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfBase.b_cover">b_cover</a></span> : \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfBase.b_join">b_join</a></span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span> <span class="id">t</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">j</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">j</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">k</span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">k</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">k</span> <span class="id">t</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">k</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">j</span>]).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfBaseMixin">topologyOfBaseMixin</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfOpenMixin">topologyOfOpenMixin</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#open_fromT">open_fromT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b_cover">b_cover</a></span>) <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof169')">Next Obligation.</span></div>
<div class="proofscript" id="proof169">
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">DA</span> <span class="id">sDAD</span> <span class="id">AeUbA</span>] [<span class="id">DB</span> <span class="id">sDBD</span> <span class="id">BeUbB</span>].<br/>
<span class="id">have</span> <span class="id">ABU</span> : <span class="kwd">forall</span> <span class="id">t</span>, (<span class="id">A</span> `&amp;` <span class="id">B</span>) <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">it</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">it</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> `&lt;=` <span class="id">A</span> `&amp;` <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t</span> [<span class="id">At</span> <span class="id">Bt</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">iA</span> [<span class="id">DiA</span> [<span class="id">biAt</span> <span class="id">sbiA</span>]]] : <span class="kwd">exists</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&lt;=` <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">At</span>; <span class="id">rewrite</span> -<span class="id">AeUbA</span> =&gt; - [<span class="id">i</span> <span class="id">DAi</span> <span class="id">bit</span>]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">sDAD</span>|<span class="id">split</span>=&gt; // ?; <span class="kwd">exists</span> <span class="id">i</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">iB</span> [<span class="id">DiB</span> [<span class="id">biBt</span> <span class="id">sbiB</span>]]] : <span class="kwd">exists</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&lt;=` <span class="id">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Bt</span>; <span class="id">rewrite</span> -<span class="id">BeUbB</span> =&gt; - [<span class="id">i</span> <span class="id">DBi</span> <span class="id">bit</span>]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">sDBD</span>|<span class="id">split</span>=&gt; // ?; <span class="kwd">exists</span> <span class="id">i</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">i</span> [<span class="id">Di</span> <span class="id">bit</span> <span class="id">sbiAB</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b_join">b_join</a></span> <span class="id">DiA</span> <span class="id">DiB</span> <span class="id">biAt</span> <span class="id">biBt</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>; <span class="id">split</span>=&gt; //; <span class="id">split</span>=&gt; // <span class="id">s</span> /<span class="id">sbiAB</span> [/<span class="id">sbiA</span> ? /<span class="id">sbiB</span>].<br/>
<span class="id">set</span> <span class="id">Dt</span> := <span class="kwd">fun</span> <span class="id">t</span> =&gt; [<span class="id">set</span> <span class="id">it</span> | <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">it</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> `&lt;=` <span class="id">A</span> `&amp;` <span class="id">B</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">Dt</span> <span class="id">t</span>) | <span class="id">t</span> <span class="kwd">in</span> <span class="id">A</span> `&amp;` <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">t</span> <span class="id">ABt</span> &lt;-]; <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] := <span class="id">ABt</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; [[<span class="id">_</span> [<span class="id">s</span> <span class="id">ABs</span> &lt;-] <span class="id">bDtst</span>]|<span class="id">ABt</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> [<span class="id">_</span>]] := <span class="id">ABs</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">Dt</span> <span class="id">t</span>)); [<span class="kwd">exists</span> <span class="id">t</span>| <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [? []]:= <span class="id">ABt</span>].<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof170')">Next Obligation.</span></div>
<div class="proofscript" id="proof170">
<span class="id">move</span>=&gt; <span class="id">I0</span> <span class="id">f</span>.<br/>
<span class="id">set</span> <span class="id">fop</span> := <span class="kwd">fun</span> <span class="id">j</span> =&gt; [<span class="id">set</span> <span class="id">Dj</span> | <span class="id">Dj</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> /\ <span class="id">f</span> <span class="id">j</span> = \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">Dj</span>) <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span>].<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_j</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">fop</span> <span class="id">j</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> [<span class="id">j</span> <span class="id">_</span> <span class="id">fopji</span>].<br/>
&nbsp;&nbsp;<span class="id">suff</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [/(<span class="id">_</span> <span class="id">_</span> <span class="id">fopji</span>)] : <span class="kwd">exists</span> <span class="id">Dj</span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; [[<span class="id">i</span> [<span class="id">j</span> <span class="id">_</span> <span class="id">fopji</span> <span class="id">bit</span>]]|[<span class="id">j</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">j</span> =&gt; //; <span class="id">suff</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> -&gt;] : <span class="kwd">exists</span> <span class="id">Dj</span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> -&gt;] : <span class="kwd">exists</span> <span class="id">Dj</span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">i</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="kwd">exists</span> <span class="id">j</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase">TopologyOfBase</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="filter_supremums">filter_supremums</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="smallest_filter_filter">smallest_filter_filter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof171')">Proof.</span></div>
<div class="proofscript" id="proof171">
<span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">G</span> [? <span class="id">_</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? <span class="id">sFP</span> <span class="id">sFQ</span> ? [? ?]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">apply</span>: <span class="id">sFP</span> | <span class="id">apply</span>: <span class="id">sFQ</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> + <span class="id">sFP</span> ? [? ?]; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">sFP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id"><a name="filterI_iter">filterI_iter</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">n</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1<br/>
&nbsp;&nbsp;<span class="kwd">then</span> [<span class="id">set</span> <span class="id">P</span> `&amp;` <span class="id">Q</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span> <span class="kwd">in</span> <span class="id">filterI_iter</span> <span class="id">F</span> <span class="id">m</span> &amp; <span class="id">Q</span> <span class="kwd">in</span> <span class="id">filterI_iter</span> <span class="id">F</span> <span class="id">m</span>]<br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> |` <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iter_sub">filterI_iter_sub</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> <span class="id">F</span> : <span class="id">i</span> <span class="id">j</span> / (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span> &gt;-&gt; <span class="id">i</span> `&lt;=` <span class="id">j</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof172')">Proof.</span></div>
<div class="proofscript" id="proof172">
<span class="id">move</span>=&gt; + <span class="id">j</span>; <span class="id">elim</span>: <span class="id">j</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">IH</span> <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[-&gt;//|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">IH</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span>; <span class="id">apply</span>=&gt; <span class="id">A</span> ?; <span class="id">do</span> 2 <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">setIid</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iterE">filterI_iterE</a></span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (\<span class="id">bigcup_n</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> <span class="id">F</span> <span class="id">n</span>)) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof173')">Proof.</span></div>
<div class="proofscript" id="proof173">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">smallest_sub</a></span> =&gt; //; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">FA</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">i</span> <span class="id">_</span> <span class="id">sFP</span>] [<span class="id">j</span> <span class="id">_</span> <span class="id">sFQ</span>]; <span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>).+1 =&gt; //=; <span class="kwd">exists</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">leq_maxl</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">Q</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">leq_maxr</span>.<br/>
<span class="id">move</span>=&gt; + [+ [<span class="id">n</span> <span class="id">_</span>]]; <span class="id">elim</span>: <span class="id">n</span> =&gt; [<span class="id">A</span> <span class="id">B</span>|<span class="id">n</span> <span class="id">IH</span>/= <span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [-&gt; /[!(@<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span> <span class="id">T</span>)] -&gt;|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#sub_gen_smallest">sub_gen_smallest</a></span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">sFP</span>] [<span class="id">Q</span> <span class="id">sFQ</span>] <span class="id">PQB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>; <span class="id">rewrite</span> -<span class="id">PQB</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> <span class="id">_</span> <span class="id">_</span>); [<span class="id">exact</span>: (<span class="id">IH</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sFP</span>)|<span class="id">exact</span>: (<span class="id">IH</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sFQ</span>)].<br/>
Qed.</div>
<br/>
<h2> Topology defined by a subbase of open sets </h2>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="finI_from">finI_from</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> \<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">D</span>']) <span class="id">f</span> <span class="id">i</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">D</span>' <span class="kwd">in</span> [<span class="id">set</span> <span class="id">A</span> : {<span class="id">fset</span> <span class="id">I</span>} | {<span class="id">subset</span> <span class="id">A</span> &lt;= <span class="id">D</span>}]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from_cover">finI_from_cover</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>) <span class="id">A</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof174')">Proof.</span></div>
<div class="proofscript" id="proof174">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; // <span class="id">_</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; //; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset0">set_fset0</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from1">finI_from1</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id">i</span> :<br/>
&nbsp;&nbsp;<span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> (<span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof175')">Proof.</span></div>
<div class="proofscript" id="proof175">
<span class="id">move</span>=&gt; <span class="id">Di</span>; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">i</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_fset">bigcap_fset</a></span> <span class="id">big_seq_fset1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from_countable">finI_from_countable</a></span> (<span class="id">I</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> <span class="id">D</span> -&gt; <span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof176')">Proof.</span></div>
<div class="proofscript" id="proof176">
<span class="id">move</span>=&gt; ?; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.classical.cardinality.html#card_le_trans">card_le_trans</a></span> (<span class="id"><a href="mathcomp.classical.cardinality.html#card_image_le">card_image_le</a></span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#fset_subset_countable">fset_subset_countable</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_fromI">finI_fromI</a></span> {<span class="id">I</span> : <span class="id">choiceType</span>} <span class="id">T</span> <span class="id">D</span> (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id">A</span> <span class="id">B</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof177')">Proof.</span></div>
<div class="proofscript" id="proof177">
<span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">ND</span> &lt;- [<span class="id">M</span> <span class="id">MD</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">N</span> `|` <span class="id">M</span>)%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orP">orP</a></span>[/<span class="id">ND</span> | /<span class="id">MD</span>].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_setU">bigcap_setU</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetU">set_fsetU</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iter_finI">filterI_iter_finI</a></span> {<span class="id">I</span> : <span class="id">choiceType</span>} <span class="id">T</span> <span class="id">D</span> (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> = \<span class="id">bigcup_n</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> (<span class="id">f</span> @` <span class="id">D</span>) <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof178')">Proof.</span></div>
<div class="proofscript" id="proof178">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">N</span> /= + &lt;-]; <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.cardinality.html#finite_setP">finite_setP</a></span>[<span class="id">n</span>] := <span class="id"><a href="mathcomp.classical.cardinality.html#finite_fset">finite_fset</a></span> <span class="id">N</span>; <span class="id">elim</span>: <span class="id">n</span> <span class="id">N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#II0">II0</a></span> <span class="id"><a href="mathcomp.classical.cardinality.html#card_eq0">card_eq0</a></span> =&gt; /<span class="id">eqP</span> -&gt; <span class="id">_</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">N</span> /<span class="id"><a href="mathcomp.classical.cardinality.html#eq_cardSP">eq_cardSP</a></span>[<span class="id">x</span> <span class="id">Ax</span> + <span class="id">ND</span>]; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetD1">set_fsetD1</a></span> =&gt; <span class="id">Nxn</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">NxD</span> : {<span class="id">subset</span> (<span class="id">N</span> `\ <span class="id">x</span>)%<span class="id">fset</span> &lt;= <span class="id">D</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#andP">andP</a></span> [<span class="id">_</span> /<span class="id">ND</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">r</span> <span class="id">_</span> <span class="id">xr</span>] := <span class="id">IH</span> <span class="id">_</span> <span class="id">Nxn</span> <span class="id">NxD</span>; <span class="kwd">exists</span> <span class="id">r</span>.+1 =&gt; //; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span>) =&gt; //; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>; <span class="id">apply</span>: <span class="id">ND</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` (<span class="id">N</span> `\ <span class="id">x</span>)%<span class="id">fset</span>]) <span class="id">f</span> <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_setU1">bigcap_setU1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetD1">set_fsetD1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setD1K">setD1K</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">n</span> <span class="id">_</span>]; <span class="id">elim</span>: <span class="id">n</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">a</span> [-&gt; |[<span class="id">i</span> <span class="id">Di</span> &lt;-]]; [<span class="kwd">exists</span> <span class="id">fset0</span> | <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">i</span>]%<span class="id">fset</span>] =&gt; //.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset0">set_fset0</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset1">set_fset1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set1">bigcap_set1</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">A</span> /= [<span class="id">B</span> <span class="id">snB</span> [<span class="id">C</span> <span class="id">snC</span> &lt;-]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#finI_fromI">finI_fromI</a></span>; <span class="id">apply</span>: <span class="id">IH</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="smallest_filter_finI">smallest_filter_finI</a></span> {<span class="id">T</span> : <span class="id">choiceType</span>} (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id">f</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">T</span>) (<span class="id">f</span> @` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof179')">Proof.</span></div>
<div class="proofscript" id="proof179">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_finI">filterI_iter_finI</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iterE">filterI_iterE</a></span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_supremums">filter_supremums</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfSubbase">TopologyOfSubbase</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfSubbase.I">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="TopologyOfSubbase.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfSubbase.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="TopologyOfSubbase.b">b</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfSubbaseMixin">topologyOfSubbaseMixin</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfBaseMixin">topologyOfBaseMixin</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.b">b</a></span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from_cover">finI_from_cover</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.b">b</a></span>) <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof180')">Next Obligation.</span></div>
<div class="proofscript" id="proof180">
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">t</span> [<span class="id">DA</span> <span class="id">sDAD</span> <span class="id">AeIbA</span>] [<span class="id">DB</span> <span class="id">sDBD</span> <span class="id">BeIbB</span>] <span class="id">At</span> <span class="id">Bt</span>.<br/>
<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>); <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">exists</span> (<span class="id">DA</span> `|` <span class="id">DB</span>)%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> /<span class="id">fsetUP</span> [/<span class="id">sDAD</span>|/<span class="id">sDBD</span>].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">s</span>; <span class="id">split</span>=&gt; [<span class="id">Ifs</span>|[<span class="id">As</span> <span class="id">Bs</span>] <span class="id">i</span> /<span class="id">fsetUP</span>].<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">AeIbA</span> =&gt; <span class="id">i</span> <span class="id">DAi</span>; <span class="id">apply</span>: <span class="id">Ifs</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">DAi</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">BeIbB</span> =&gt; <span class="id">i</span> <span class="id">DBi</span>; <span class="id">apply</span>: <span class="id">Ifs</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">DBi</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orbC">orbC</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">DAi</span>|<span class="id">DBi</span>];<br/>
&nbsp;&nbsp;[<span class="id">have</span> := <span class="id">As</span>; <span class="id">rewrite</span> -<span class="id">AeIbA</span>; <span class="id">apply</span>|<span class="id">have</span> := <span class="id">Bs</span>; <span class="id">rewrite</span> -<span class="id">BeIbB</span>; <span class="id">apply</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase">TopologyOfSubbase</a></span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="nat_topologicalType">nat_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.b">b</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; [<span class="id">set</span> <span class="id">i</span>].<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.bT">bT</a></span> : \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof181')">Proof.</span></div>
<div class="proofscript" id="proof181">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">i</span>; <span class="id">split</span> =&gt; // <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">i</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.bD">bD</a></span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span> <span class="id">t</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">j</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> <span class="id">t</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">j</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">k</span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">k</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">k</span> <span class="id">t</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">k</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">j</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof182')">Proof.</span></div>
<div class="proofscript" id="proof182">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">t</span> <span class="id">_</span> <span class="id">_</span> -&gt; -&gt;; <span class="kwd">exists</span> <span class="id">j</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nat_topologicalTypeMixin">nat_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfBaseMixin">topologyOfBaseMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.bT">bT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.bD">bD</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nat_filteredType">nat_filteredType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span>)).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nat_topologicalType">nat_topologicalType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalTypeMixin">nat_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType">nat_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="eventually">eventually</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> (<span class="kwd">fun</span> <span class="id">N</span> =&gt; [<span class="id">set</span> <span class="id">n</span> | (<span class="id">N</span> &lt;= <span class="id">n</span>)%<span class="id">N</span>]).<br/>
<span class="kwd">Notation</span> "'\<span class="id">oo</span>'" := <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_filter_source">eventually_filter_source</a></span> <span class="id">X</span> :=<br/>
&nbsp;&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Source">Filtered.Source</a></span> <span class="id">X</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> (<span class="kwd">fun</span> <span class="id">f</span> =&gt; <span class="id">f</span> @ \<span class="id">oo</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="eventually_filter">eventually_filter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof183')">Proof.</span></div>
<div class="proofscript" id="proof183">
<span class="id">eapply</span> @<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">i</span> =&gt; /=.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_fromT_filter">filter_fromT_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>) =&gt; <span class="id">n</span> //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">geq_max</span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#andP">andP</a></span>[<span class="id">ltin</span> <span class="id">ltjn</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_filterType">eventually_filterType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> <span class="id">_</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_pfilterType">eventually_pfilterType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#PFilterType">PFilterType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_infty_gt">nbhs_infty_gt</a></span> <span class="id">N</span> : \<span class="kwd">forall</span> <span class="id">n</span> \<span class="id">near</span> \<span class="id">oo</span>, (<span class="id">N</span> &lt; <span class="id">n</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof184')">Proof.</span></div>
<div class="proofscript" id="proof184">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>.+1. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nbhs_infty_gt</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_infty_ge">nbhs_infty_ge</a></span> <span class="id">N</span> : \<span class="kwd">forall</span> <span class="id">n</span> \<span class="id">near</span> \<span class="id">oo</span>, (<span class="id">N</span> &lt;= <span class="id">n</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof185')">Proof.</span></div>
<div class="proofscript" id="proof185">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_addnl">cvg_addnl</a></span> <span class="id">N</span> : <span class="id">addn</span> <span class="id">N</span> @ \<span class="id">oo</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof186')">Proof.</span></div>
<div class="proofscript" id="proof186">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> - <span class="id">N</span>)%<span class="id">N</span> =&gt; // <span class="id">m</span>; <span class="id">rewrite</span> /= <span class="id">leq_subLR</span> =&gt; /<span class="id">Pn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_addnr">cvg_addnr</a></span> <span class="id">N</span> : <span class="id">addn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof187')">Proof.</span></div>
<div class="proofscript" id="proof187">
 <span class="kwd">by</span> <span class="id">under</span> [<span class="id">addn</span>^~ <span class="id">N</span>]<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span> =&gt; <span class="id">n</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">addnC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_addnl">cvg_addnl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_subnr">cvg_subnr</a></span> <span class="id">N</span> : <span class="id">subn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof188')">Proof.</span></div>
<div class="proofscript" id="proof188">
<span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">N</span> + <span class="id">n</span>)%<span class="id">N</span> =&gt; //= <span class="id">m</span> <span class="id">le_m</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Pn</span>; <span class="id">rewrite</span> /= <span class="id">leq_subRL</span>// (<span class="id">leq_trans</span> <span class="id">_</span> <span class="id">le_m</span>)// <span class="id">leq_addr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_mulnl">cvg_mulnl</a></span> <span class="id">N</span> : (<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">muln</span> <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof189')">Proof.</span></div>
<div class="proofscript" id="proof189">
<span class="id">case</span>: <span class="id">N</span> =&gt; <span class="id">N</span> // <span class="id">_</span> <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> %/ <span class="id">N</span>.+1).+1 =&gt; // <span class="id">m</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">ltn_divLR</span>// =&gt; <span class="id">n_lt</span>; <span class="id">apply</span>: <span class="id">Pn</span>; <span class="id">rewrite</span> <span class="id">mulnC</span> /= <span class="id">ltnW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_mulnr">cvg_mulnr</a></span> <span class="id">N</span> :(<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">muln</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof190')">Proof.</span></div>
<div class="proofscript" id="proof190">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N_gt0</span>; <span class="id">under</span> [<span class="id">muln</span>^~ <span class="id">N</span>]<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span> =&gt; <span class="id">n</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">mulnC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_mulnl">cvg_mulnl</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_divnr">cvg_divnr</a></span> <span class="id">N</span> : (<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">divn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof191')">Proof.</span></div>
<div class="proofscript" id="proof191">
<span class="id">move</span>=&gt; <span class="id">N_gt0</span> <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> * <span class="id">N</span>)%<span class="id">N</span> =&gt; //= <span class="id">m</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= -<span class="id">leq_divRL</span>//; <span class="id">apply</span>: <span class="id">Pn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_inftyS">near_inftyS</a></span> (<span class="id">P</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> \<span class="id">oo</span>, <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">S</a></span> <span class="id">x</span>)) -&gt; (\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> \<span class="id">oo</span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof192')">Proof.</span></div>
<div class="proofscript" id="proof192">
 <span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">_</span> <span class="id">NPS</span>; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">S</a></span> <span class="id">N</span>) =&gt; // [[]]; <span class="id">rewrite</span> /= ?<span class="id">ltn0</span> //. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="infty_nat">infty_nat</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">nat_scope</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="infty_nat.cvgnyP">cvgnyP</a></span> {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>)} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} : [&lt;-&gt;<br/>
 <span class="id">F</span> --&gt; \<span class="id">oo</span>;<br/>
 <span class="kwd">forall</span> <span class="id">A</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt;= <span class="id">x</span>;<br/>
 <span class="kwd">forall</span> <span class="id">A</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt; <span class="id">x</span>;<br/>
 \<span class="kwd">forall</span> <span class="id">A</span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt; <span class="id">x</span>;<br/>
 \<span class="kwd">forall</span> <span class="id">A</span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt;= <span class="id">x</span> ].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof193')">Proof.</span></div>
<div class="proofscript" id="proof193">
<span class="id">tfae</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Foo</span> <span class="id">A</span>; <span class="id">apply</span>: <span class="id">Foo</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">AF</span> <span class="id">A</span>; <span class="id">near</span> \<span class="id">oo</span> =&gt; <span class="id">B</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> : (<span class="id">B</span> &lt;= <span class="id">x</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">leq_trans</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_gt">nbhs_infty_gt</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">near</span>: <span class="id">B</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Foo</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">Foo</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ?; <span class="id">apply</span>: <span class="id">ltnW</span>.<br/>
<span class="id">case</span>=&gt; [<span class="id">A</span> <span class="id">_</span> <span class="id">AF</span>] <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="id">near</span> \<span class="id">oo</span> =&gt; <span class="id">B</span>; <span class="id">near</span>=&gt; <span class="id">m</span>; <span class="id">apply</span>: <span class="id">Pn</span> =&gt; /=.<br/>
<span class="id">suff</span>: (<span class="id">B</span> &lt;= <span class="id">m</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">leq_trans</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
<span class="kwd">by</span> <span class="id">near</span>: <span class="id">m</span>; <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="infty_nat.map">map</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">I</span> : <span class="kwd">Type</span>} {<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>)} {<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPge">cvgnyPge</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof194')">Proof.</span></div>
<div class="proofscript" id="proof194">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 1%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgt">cvgnyPgt</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof195')">Proof.</span></div>
<div class="proofscript" id="proof195">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 2%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgty">cvgnyPgty</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; \<span class="kwd">forall</span> <span class="id">A</span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof196')">Proof.</span></div>
<div class="proofscript" id="proof196">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 3%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgey">cvgnyPgey</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; \<span class="kwd">forall</span> <span class="id">A</span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof197')">Proof.</span></div>
<div class="proofscript" id="proof197">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 4%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map">map</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat">infty_nat</a></span>.<br/>
<br/>
<h2> Topology on the product of two spaces </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Prod_Topology">Prod_Topology</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Prod_Topology.prod_nbhs">prod_nbhs</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>.1) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>.2).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_filter">prod_nbhs_filter</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof198')">Proof.</span></div>
<div class="proofscript" id="proof198">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_proper">filter_prod_proper</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_singleton">prod_nbhs_singleton</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof199')">Proof.</span></div>
<div class="proofscript" id="proof199">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">QR</span> [/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">Qp1</span> /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">Rp2</span>]]; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_nbhs">prod_nbhs_nbhs</a></span> (<span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof200')">Proof.</span></div>
<div class="proofscript" id="proof200">
<span class="id">move</span>=&gt; [<span class="id">QR</span> [/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span> <span class="id">p1_Q</span> /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span> <span class="id">p2_R</span>] <span class="id">sQRA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">QR</span>.1^°, <span class="id">QR</span>.2^°) =&gt; // ??; <span class="kwd">exists</span> <span class="id">QR</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prod_topologicalTypeMixin">prod_topologicalTypeMixin</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfFilterMixin">topologyOfFilterMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_filter">prod_nbhs_filter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_singleton">prod_nbhs_singleton</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_nbhs">prod_nbhs_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="prod_topologicalType">prod_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#prod_topologicalTypeMixin">prod_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology">Prod_Topology</a></span>.<br/>
<br/>
<h2> Topology on matrices </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="matrix_Topology">matrix_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="matrix_Topology.m">m</a></span> <span class="id"><a name="matrix_Topology.n">n</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) (<span class="id"><a name="matrix_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>).<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_filter">mx_nbhs_filter</a></span> <span class="id">M</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof201')">Proof.</span></div>
<div class="proofscript" id="proof201">
<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span> <span class="id">_</span> <span class="id">_</span>)) =&gt; [|<span class="id">P</span> <span class="id">Q</span> <span class="id">M_P</span> <span class="id">M_Q</span>|<span class="id">P</span> <span class="id">M_P</span>].<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>) =&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> `&amp;` <span class="id">Q</span> <span class="id">i</span> <span class="id">j</span>) =&gt; [??|<span class="id">mx</span> <span class="id">PQmx</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> [] := <span class="id">PQmx</span> <span class="id">i</span> <span class="id">j</span>.<br/>
- <span class="kwd">exists</span> (\<span class="id">matrix_</span>(<span class="id">i</span>, <span class="id">j</span>) <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)) =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">rewrite</span> <span class="id">mxE</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> (<span class="id">M_P</span> <span class="id">i</span> <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_singleton">mx_nbhs_singleton</a></span> <span class="id">M</span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">M</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof202')">Proof.</span></div>
<div class="proofscript" id="proof202">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">M_P</span>]; <span class="id">apply</span>=&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_nbhs">mx_nbhs_nbhs</a></span> <span class="id">M</span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof203')">Proof.</span></div>
<div class="proofscript" id="proof203">
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">M_P</span> <span class="id">sPA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)^°).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="kwd">exists</span> <span class="id">P</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="matrix_topologicalTypeMixin">matrix_topologicalTypeMixin</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfFilterMixin">topologyOfFilterMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_filter">mx_nbhs_filter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_singleton">mx_nbhs_singleton</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_nbhs">mx_nbhs_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="matrix_topologicalType">matrix_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#matrix_topologicalTypeMixin">matrix_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology">matrix_Topology</a></span>.<br/>
<br/>
<h2> Weak topology by a function </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Weak_Topology">Weak_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Weak_Topology.S">S</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="Weak_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="Weak_Topology.f">f</a></span> : <span class="id">S</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="wopen">wopen</a></span> := [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wopT">wopT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof204')">Proof.</span></div>
<div class="proofscript" id="proof204">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openT">openT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wopI">wopI</a></span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof205')">Proof.</span></div>
<div class="proofscript" id="proof205">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">C</span> <span class="id">Cop</span> &lt;-] [<span class="id">D</span> <span class="id">Dop</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">C</span> `&amp;` <span class="id">D</span>) =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wop_bigU">wop_bigU</a></span> (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">g</span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (<span class="id">g</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (\<span class="id">bigcup_i</span> <span class="id">g</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof206')">Proof.</span></div>
<div class="proofscript" id="proof206">
<span class="id">move</span>=&gt; <span class="id">gop</span>.<br/>
<span class="id">set</span> <span class="id">opi</span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; [<span class="id">set</span> <span class="id">Ui</span> | <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">Ui</span> /\ <span class="id">g</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">Ui</span>].<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_i</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">opi</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#bigcup_open">bigcup_open</a></span> =&gt; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] : <span class="kwd">exists</span> <span class="id">U</span>, <span class="id">opi</span> <span class="id">i</span> <span class="id">U</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">U</span>] := <span class="id">gop</span> <span class="id">i</span>; <span class="kwd">exists</span> <span class="id">U</span>.<br/>
<span class="id">have</span> <span class="id">g_preim</span> <span class="id">i</span> : <span class="id">g</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">opi</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] : <span class="kwd">exists</span> <span class="id">U</span>, <span class="id">opi</span> <span class="id">i</span> <span class="id">U</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">U</span>] := <span class="id">gop</span> <span class="id">i</span>; <span class="kwd">exists</span> <span class="id">U</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">s</span>; <span class="id">split</span>=&gt; [[<span class="id">i</span> <span class="id">_</span>]|[<span class="id">i</span> <span class="id">_</span>]]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">g_preim</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">_</span> <span class="id">_</span>]/((<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">_</span>) <span class="id">_</span>) -<span class="id">g_preim</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="weak_topologicalTypeMixin">weak_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfOpenMixin">topologyOfOpenMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopT">wopT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopI">wopI</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wop_bigU">wop_bigU</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Weak_Topology.S_filteredClass">S_filteredClass</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Class">Filtered.Class</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="weak_topologicalType">weak_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Class">Topological.Class</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S_filteredClass">S_filteredClass</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalTypeMixin">weak_topologicalTypeMixin</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="weak_continuous">weak_continuous</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.T">T</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof207')">Proof.</span></div>
<div class="proofscript" id="proof207">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#continuousP">continuousP</a></span> =&gt; <span class="id">A</span> ?; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_image">cvg_image</a></span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>)) (<span class="id">s</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @` <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; (<span class="id">s</span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span>) &lt;-&gt; [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>] --&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> <span class="id">s</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof208')">Proof.</span></div>
<div class="proofscript" id="proof208">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fsurj</span>; <span class="id">split</span>=&gt; [<span class="id">cvFs</span>|<span class="id">cvfFfs</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id"><a href="mathcomp.analysis.topology.html#weak_continuous">weak_continuous</a></span> [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bs</span> <span class="id">sBAf</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">cvFs</span> <span class="id">FB</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id">s</span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">open_nbhs_nbhs</a></span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">A</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FB</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#image_preimage">image_preimage</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /= [<span class="id">_</span> [[<span class="id">B</span> <span class="id">Bop</span> &lt;-] <span class="id">Bfs</span> <span class="id">sBfA</span>]].<br/>
<span class="id">have</span> /<span class="id">cvfFfs</span> [<span class="id">C</span> <span class="id">FC</span> <span class="id">fCeB</span>] : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> <span class="id">s</span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FC</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sBfA</span>; <span class="id">rewrite</span> -<span class="id">fCeB</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#preimage_image">preimage_image</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology">Weak_Topology</a></span>.<br/>
<br/>
<h2> Supremum of a family of topologies </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Sup_Topology">Sup_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Sup_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="Sup_Topology.I">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Sup_Topology.Tc">Tc</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#class_of">Topological.class_of</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Sup_Topology.TS">TS</a></span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.Tc">Tc</a></span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_subbase">sup_subbase</a></span> := \<span class="id">bigcup_i</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_topologicalTypeMixin">sup_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfSubbaseMixin">topologyOfSubbaseMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_subbase">sup_subbase</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_topologicalType">sup_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Class">Topological.Class</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Class">Filtered.Class</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>) <span class="id">_</span>)<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalTypeMixin">sup_topologicalTypeMixin</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_sup">cvg_sup</a></span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>)) (<span class="id">t</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; (<span class="id">t</span> : <span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span>) &lt;-&gt; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">F</span> --&gt; (<span class="id">t</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof209')">Proof.</span></div>
<div class="proofscript" id="proof209">
<span class="id">move</span>=&gt; <span class="id">Ffilt</span>; <span class="id">split</span>=&gt; <span class="id">cvFt</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">A</span> /=; <span class="id">rewrite</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>)) =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bt</span>] <span class="id">sBA</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvFt</span>; <span class="kwd">exists</span> <span class="id">B</span>; <span class="id">split</span>=&gt; //; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">B</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; ?; <span class="id">split</span>=&gt; [[<span class="id">_</span> -&gt;]|] //; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">_</span> -&gt;; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">B</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span>-&gt;; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span>=&gt; ?; <span class="id">split</span>=&gt; [|??]; [<span class="id">apply</span>|]; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> // =&gt;/<span class="id">eqP</span>-&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /=; <span class="id">rewrite</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">_</span> [[<span class="id">B</span> <span class="id">sB</span> &lt;-] [<span class="id">C</span> <span class="id">BC</span> <span class="id">Ct</span>] <span class="id">sUBA</span>]].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sUBA</span> <span class="id">_</span>; <span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="kwd">exists</span> <span class="id">C</span>.<br/>
<span class="id">have</span> /<span class="id">sB</span> [<span class="id">D</span> <span class="id">sD</span> <span class="id">IDeC</span>] := <span class="id">BC</span>; <span class="id">rewrite</span> -<span class="id">IDeC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_bigI">filter_bigI</a></span> =&gt; <span class="id">E</span> <span class="id">DE</span>.<br/>
<span class="id">have</span> /<span class="id">sD</span> := <span class="id">DE</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; - [<span class="id">i</span> <span class="id">_</span>]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Eop</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">cvFt</span> <span class="id">i</span>); <span class="id">apply</span>: <span class="id">Eop</span>; <span class="id">move</span>: <span class="id">Ct</span>; <span class="id">rewrite</span> -<span class="id">IDeC</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">DE</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology">Sup_Topology</a></span>.<br/>
<br/>
<h2> Product topology </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Product_Topology">Product_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Product_Topology.I">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Product_Topology.T">T</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="product_topologicalType">product_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#class">Topological.class</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span> (<span class="kwd">fun</span> <span class="id">f</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#dep_arrow_pointedType">dep_arrow_pointedType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Product_Topology.T">T</a></span> =&gt; <span class="id">f</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Product_Topology">Product_Topology</a></span>.<br/>
<br/>
<div class="doc">dnbhs </div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="dnbhs">dnbhs</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> (<span class="kwd">fun</span> <span class="id">y</span> =&gt; <span class="id">y</span> != <span class="id">x</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>).<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> ^'" := (<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> <span class="id">x</span>) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="dnbhsE">dnbhsE</a></span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id">x</span> : <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> = <span class="id">x</span>^' `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof210')">Proof.</span></div>
<div class="proofscript" id="proof210">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">x_A</span>|[<span class="id">x_A</span> <span class="id">Ax</span>]].<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">x_A</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span> [<span class="id">oB</span> <span class="id">x_B</span> <span class="id">sBA</span>]]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // ? /<span class="id">sBA</span>.<br/>
<span class="id">move</span>: <span class="id">x_A</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> !<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span> [<span class="id">oB</span> <span class="id">x_B</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> <span class="id">B</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> /<span class="id">sBA</span> <span class="id">Ay</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">y</span> <span class="id">x</span>) =&gt; [-&gt;|].<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="dnbhs_filter">dnbhs_filter</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">x</span> : <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof211')">Proof.</span></div>
<div class="proofscript" id="proof211">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#within_filter">within_filter</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">dnbhs</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="dnbhs_filter_on">dnbhs_filter_on</a></span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)  (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">x</span>^' (<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs_filter">dnbhs_filter</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fmap2">cvg_fmap2</a></span> (<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>):<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">F</span> <span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)), <span class="id">G</span> `=&gt;` <span class="id">F</span> -&gt; <span class="id">f</span> @ <span class="id">G</span> `=&gt;` <span class="id">f</span> @ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof212')">Proof.</span></div>
<div class="proofscript" id="proof212">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">G</span> <span class="id">H</span> <span class="id">A</span> <span class="id">fFA</span> ; <span class="id">exact</span>: <span class="id">H</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">preimage</a></span> <span class="id">f</span> <span class="id">A</span>) <span class="id">fFA</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_within_filter">cvg_within_filter</a></span> {<span class="id">T</span> <span class="id">U</span>} {<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id">FF</span> : (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) }<br/>
&nbsp;&nbsp;(<span class="id">G</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) : <span class="kwd">forall</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>), (<span class="id">f</span> @ <span class="id">F</span>) --&gt; <span class="id">G</span> -&gt; (<span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>) --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof213')">Proof.</span></div>
<div class="proofscript" id="proof213">
 <span class="id">move</span>=&gt; ?;  <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_fmap2">cvg_fmap2</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span> <span class="id">_</span>)). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_app_within">cvg_app_within</a></span> {<span class="id">T</span>} {<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>): <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id">F</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof214')">Proof.</span></div>
<div class="proofscript" id="proof214">
 <span class="kwd">by</span> <span class="id">move</span> =&gt; <span class="id">FF</span> /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span> [<span class="id">l</span> <span class="id">H</span>]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> <span class="id">l</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within_filter">cvg_within_filter</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_dnbhs">nbhs_dnbhs</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">x</span>^' `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof215')">Proof.</span></div>
<div class="proofscript" id="proof215">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span>. Qed.</div>
<br/>
<div class="doc">meets </div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_openr">meets_openr</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> = <span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof216')">Proof.</span></div>
<div class="proofscript" id="proof216">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>; [<span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#meetsSr">meetsSr</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">open_nbhs_nbhs</a></span>|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">A</span> <span class="id">B</span> {}/<span class="id">P</span> <span class="id">P</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span>' /<span class="id">P</span> + <span class="id">sB</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_neq0">subsetI_neq0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_openl">meets_openl</a></span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> `#` <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">x</span> `#` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof217')">Proof.</span></div>
<div class="proofscript" id="proof217">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_openr">meets_openr</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_globallyl">meets_globallyl</a></span> <span class="id">T</span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id">G</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id">G</span> = <span class="kwd">forall</span> <span class="id">B</span>, <span class="id">G</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof218')">Proof.</span></div>
<div class="proofscript" id="proof218">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; [/(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span>=&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>))//|<span class="id">clA</span> <span class="id">A</span>' <span class="id">B</span> <span class="id">sA</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clA</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_neq0">subsetI_neq0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_globallyr">meets_globallyr</a></span> <span class="id">T</span> <span class="id">F</span> (<span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">B</span> = <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof219')">Proof.</span></div>
<div class="proofscript" id="proof219">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>; <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_forall">eq_forall</a></span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">setIC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meetsxx">meetsxx</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) : <span class="id">F</span> `#` <span class="id">F</span> = ~ (<span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof220')">Proof.</span></div>
<div class="proofscript" id="proof220">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; [<span class="id">FmF</span> <span class="id">F0</span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">x</span> []] := <span class="id">FmF</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F0</span> <span class="id">F0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">FN0</span> <span class="id">A</span> <span class="id">B</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> <span class="id">FAI</span> {}/<span class="id">FAI</span> <span class="id">FAB</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">set0P</a></span>/<span class="id">eqP</span> =&gt; <span class="id">AB0</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">AB0</span> <span class="kwd">in</span> <span class="id">FAB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="proper_meetsxx">proper_meetsxx</a></span> <span class="id">T</span> (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>) : <span class="id">F</span> `#` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof221')">Proof.</span></div>
<div class="proofscript" id="proof221">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#meetsxx">meetsxx</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span>. Qed.</div>
<br/>
<h2> Closed sets in topological spaces </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Closed">Closed</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="closure">closure</a></span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">p</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span> | <span class="kwd">forall</span> <span class="id">B</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closure0">closure0</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> :&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof222')">Proof.</span></div>
<div class="proofscript" id="proof222">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; // /(<span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_nbhsT">filter_nbhsT</a></span> <span class="id">_</span>))/<span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">set0P</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0I">set0I</a></span> <span class="id">eqxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureEnbhs">closureEnbhs</a></span> <span class="id">A</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof223')">Proof.</span></div>
<div class="proofscript" id="proof223">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_fun">eq_fun</a></span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureEonbhs">closureEonbhs</a></span> <span class="id">A</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof224')">Proof.</span></div>
<div class="proofscript" id="proof224">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_fun">eq_fun</a></span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#meets_openr">meets_openr</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="subset_closure">subset_closure</a></span> (<span class="id">A</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>) : <span class="id">A</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof225')">Proof.</span></div>
<div class="proofscript" id="proof225">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> ??; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureI">closure_eq0</a></span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closure</span> <span class="id">A</span> = <span class="id">set0</span> -&gt; <span class="id">A</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof226')">Proof.</span></div>
<div class="proofscript" id="proof226">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A0</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> -<span class="id">A0</span>; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureI</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closure</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) `&lt;=` <span class="id">closure</span> <span class="id">A</span> `&amp;` <span class="id">closure</span> <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof227')">Proof.</span></div>
<div class="proofscript" id="proof227">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">clABp</span>; <span class="id">split</span>=&gt; ? /<span class="id">clABp</span> [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> <span class="id">q</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">limit_point</span> <span class="id">E</span> := [<span class="id">set</span> <span class="id">t</span> : <span class="id">T</span> |<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">U</span>, <span class="id">nbhs</span> <span class="id">t</span> <span class="id">U</span> -&gt; <span class="kwd">exists</span> <span class="id">y</span>, [/\ <span class="id">y</span> != <span class="id">t</span>, <span class="id">E</span> <span class="id">y</span> &amp; <span class="id">U</span> <span class="id">y</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">limit_pointEnbhs</span> <span class="id">E</span> :<br/>
&nbsp;&nbsp;<span class="id">limit_point</span> <span class="id">E</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">globally</span> (<span class="id"><a href="mathcomp.classical.boolp.html#propeqE">E</a></span> `\ <span class="id">p</span>) `#` <span class="id">nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof228')">Proof.</span></div>
<div class="proofscript" id="proof228">
<span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">meets_globallyl</span>; <span class="id"><a name="limit_pointEonbhs">rewrite</a></span> <span class="id">funeqE</span> =&gt; <span class="id">p</span> /=.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#limit_point">apply</a></span>/<span class="id">eq_forall2</span> =&gt; <span class="id">x</span> <span class="id">px</span>; <span class="id">apply</span>/<span class="id">eq_exists</span> =&gt; <span class="id">y</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [[/<span class="id">eqP</span> ? ?]|[[? /<span class="id">eqP</span> ?]]]; <span class="id">do</span> 2?<span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">limit_pointEonbhs</span> <span class="id"><a name="subset_limit_point">E</a></span> :<br/>
&nbsp;&nbsp;<span class="id">limit_point</span> <span class="id">E</span> = [<span class="id"><a href="mathcomp.analysis.topology.html#limit_point">set</a></span> <span class="id">p</span> | <span class="id">globally</span> (<span class="id">E</span> `\ <span class="id">p</span>) `#` <span class="id">open_nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof229')">Proof.</span></div>
<div class="proofscript" id="proof229">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">limit_pointEnbhs</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">meets_openr</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_limit_point</span> <span class="id">E</span> : <span class="id">limit_point</span> <span class="id">E</span> `&lt;=` <span class="id">closure</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof230')">Proof.</span></div>
<div class="proofscript" id="proof230">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">Et</span> <span class="id">U</span> <span class="id">tU</span>; <span class="id">have</span> [<span class="id">p</span> [? ? ?]] := <span class="id">Et</span> <span class="id">_</span> <span class="id">tU</span>; <span class="kwd">exists</span> <span class="id">p</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_limit_point</span> <span class="id">E</span> : <span class="id">closure</span> <span class="id">E</span> = <span class="id">E</span> `|` <span class="id">limit_point</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof231')">Proof.</span></div>
<div class="proofscript" id="proof231">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">t</span>; <span class="id">split</span> =&gt; [<span class="id">cEt</span>|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>; [<span class="id">exact</span>: <span class="id">subset_closure</span>|<span class="id">exact</span>: <span class="id">subset_limit_point</span>].<br/>
<span class="id">have</span> [?|<span class="id">Et</span>] := <span class="id">pselect</span> (<span class="id">E</span> <span class="id">t</span>); [<span class="kwd">by</span> <span class="id">left</span>|<span class="id">right</span>=&gt; <span class="id">U</span> <span class="id">tU</span>; <span class="id">have</span> [<span class="id">p</span> []] := <span class="id">cEt</span> <span class="id">_</span> <span class="id">tU</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">pt</span>; <span class="id">apply</span>: <span class="id">Et</span>; <span class="id">rewrite</span> -<span class="id">pt</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">closed</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">closure</span> <span class="id">D</span> `&lt;=` <span class="id">D</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_closedC</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> <span class="id">D</span> -&gt; <span class="id">closed</span> (~` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof232')">Proof.</span></div>
<div class="proofscript" id="proof232">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">Dop</span> <span class="id">p</span> <span class="id">clNDp</span> /<span class="id">Dop</span> /<span class="id">clNDp</span> [? []]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigI</span> {<span class="id">I</span>} (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id"><a name="closedI">f</a></span> <span class="id">i</span>)) -&gt; <span class="id">closed</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed">i</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof233')">Proof.</span></div>
<div class="proofscript" id="proof233">
<span class="id">move</span>=&gt; <span class="id">fcl</span> <span class="id">t</span> <span class="id">clft</span> <span class="id">i</span> <span class="id">Di</span>; <span class="id">have</span> /<span class="id">fcl</span> := <span class="id">Di</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">clft</span> [<span class="id">s</span> [/(<span class="id">_</span> <span class="id">i</span> <span class="id">Di</span>)]]; <span class="kwd">exists</span> <span class="id">s</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedI</span> (<span class="id">D</span> <span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">closed</span> <span class="id">E</span> -&gt; <span class="id">closed</span> (<span class="id">D</span> `&amp;` <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof234')">Proof.</span></div>
<div class="proofscript" id="proof234">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Dcl</span> <span class="id">Ecl</span> <span class="id">p</span> <span class="id">clDEp</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">Dcl</span>|<span class="id">apply</span>: <span class="id">Ecl</span>];<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">clDEp</span> [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> <span class="id">q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedT</span> : <span class="id">closed</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">setT</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof235')">Proof.</span></div>
<div class="proofscript" id="proof235">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed0</span> : <span class="id">closed</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof236')">Proof.</span></div>
<div class="proofscript" id="proof236">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /(<span class="id">_</span> <span class="id">setT</span>) [|? []] //; <span class="id">apply</span>: <span class="id">filterT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedE</span> : <span class="id">closed</span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span> | <span class="kwd">forall</span> <span class="id">p</span>, ~ (\<span class="id">near</span> <span class="id">p</span>, ~ <span class="id">A</span> <span class="id">p</span>) -&gt; <span class="id">A</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof237')">Proof.</span></div>
<div class="proofscript" id="proof237">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; <span class="id">Acl</span> <span class="id">p</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">clAp</span>; <span class="id">apply</span>: <span class="id">Acl</span>; <span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> =&gt; /<span class="id">clAp</span> [? []].<br/>
<span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> <span class="id">nbhsE</span> =&gt; /<span class="id">asboolP</span>.<br/>
<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn2</span> <span class="id">clAp</span>.<br/>
<span class="id">apply</span>: <span class="id">Acl</span> =&gt; <span class="id">B</span>; <span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; - [<span class="id">C</span> [<span class="id">oC</span> <span class="id">pC</span>]].<br/>
<span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">clAp</span> <span class="id">C</span>.<br/>
<span class="id">rewrite</span> <span class="id">asbool_or</span> 2!<span class="id">asbool_neg</span> =&gt; /<span class="id">orP</span>[/<span class="id">asboolP</span>/<span class="id">not_andP</span>[]//|/<span class="id">existsp_asboolPn</span> [<span class="id">q</span>]].<br/>
<span class="id">move</span>/<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">imply_asboolPn</span>[+ /<span class="id">contrapT</span> <span class="id">Aq</span> <span class="id">sCB</span>] =&gt; /<span class="id">sCB</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_openC</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">open</span> (~` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof238')">Proof.</span></div>
<div class="proofscript" id="proof238">
<span class="id">rewrite</span> <span class="id">closedE</span> <span class="id"><a href="mathcomp.classical.boolp.html#propext">openE</a></span> =&gt; <span class="id">Dcl</span> <span class="id">t</span> <span class="id">nDt</span>; <span class="id">apply</span>: <span class="id">contrapT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">nbhs_nearE</span> =&gt; /<span class="id">Dcl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedC</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">D</a></span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> (~` <span class="id">D</span>) = <span class="id">open</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof239')">Proof.</span></div>
<div class="proofscript" id="proof239">
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">split</span>=&gt; [/<span class="id">closed_openC</span>|]; [<span class="id">rewrite</span> <span class="id">setCK</span>|<span class="id">exact</span>: <span class="id">open_closedC</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">openC</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> (~`<span class="id">D</span>) = <span class="id">closed</span> (<span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof240')">Proof.</span></div>
<div class="proofscript" id="proof240">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closedC</span> <span class="id">setCK</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_closure</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> (<span class="id">closure</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof241')">Proof.</span></div>
<div class="proofscript" id="proof241">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">clclAp</span> <span class="id">B</span> /<span class="id">nbhs_interior</span> /<span class="id">clclAp</span> [<span class="id">q</span> [<span class="id">clAq</span> /<span class="id">clAq</span>]]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Closed</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_comp</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">D</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#contra_not">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> ~` <span class="id">f</span> @^-1` <span class="id">D</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof242')">Proof.</span></div>
<div class="proofscript" id="proof242">
<span class="id">rewrite</span> !<span class="id">closedE</span>=&gt; <span class="id">f_continuous</span> <span class="id">D_cl</span> <span class="id">x</span> /= <span class="id">xDf</span>.<br/>
<span class="id">apply</span>: <span class="id">D_cl</span>; <span class="id">apply</span>: <span class="id">contra_not</span> <span class="id">xDf</span> =&gt; <span class="id">fxD</span>.<br/>
<span class="id">have</span> <span class="id">NDfx</span> : ~ <span class="id">D</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">fxD</span>; <span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> <span class="id">nbhsE</span> =&gt; - [<span class="id">A</span> [? ?]]; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">f_continuous</span> <span class="id">fxD</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_cvg</span> {<span class="id">T</span>} {<span class="id">V</span> : <span class="id">topologicalType</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">u_</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> : <span class="id">V</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; (\<span class="kwd">forall</span> <span class="id">n</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">u_</span> <span class="id">n</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">u_</span> @ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">A</span> <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof243')">Proof.</span></div>
<div class="proofscript" id="proof243">
<span class="id">move</span>=&gt; + <span class="id">FAu_</span> <span class="id">l</span> <span class="id">u_Fl</span>; <span class="id">apply</span> =&gt; <span class="id">B</span> /<span class="id">u_Fl</span> /=; <span class="id">rewrite</span> <span class="id">nbhs_filterE</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">move</a></span>=&gt; /(<span class="id">filterI</span> <span class="id">FAu_</span>) =&gt; /<span class="id">filter_ex</span>[<span class="id">t</span> [<span class="id">Au_t</span> <span class="id">u_Bt</span>]]; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#closed">u_</a></span> <span class="id">t</span>).<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id">closed_cvg</span> {<span class="id">T</span> <span class="id">V</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">u_</span>} <span class="id"><a href="mathcomp.analysis.topology.html#continuousP">_</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_closedP</span> (<span class="id">S</span> <span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">f</span> : <span class="id">S</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof244')">Proof.</span></div>
<div class="proofscript" id="proof244">
<span class="id">rewrite</span> <span class="id">continuousP</span>; <span class="id">split</span>=&gt; <span class="id">ctsf</span> ? ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">openC</span> <span class="id">preimage_setC</span>; <span class="id">apply</span>: <span class="id">ctsf</span>; <span class="id"><a href="mathcomp.analysis.topology.html#closed">rewrite</a></span> <span class="id">openC</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closedC</span> <span class="id">preimage_setC</span>; <span class="id"><a href="mathcomp.analysis.topology.html#openC">apply</a></span>: <span class="id">ctsf</span>; <span class="id">rewrite</span> <span class="id">closedC</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedU</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">D</span> <span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">closed</span> <span class="id">E</span> -&gt; <span class="id">closed</span> (<span class="id">D</span> `|` <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof245')">Proof.</span></div>
<div class="proofscript" id="proof245">
 <span class="kwd">by</span> <span class="id">rewrite</span> -?<span class="id">openC</span> <span class="id">setCU</span>; <span class="id"><a href="mathcomp.analysis.topology.html#closed">exact</a></span>: <span class="id">openI</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigsetU</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">I</span> : <span class="id">eqType</span>) (<span class="id">s</span> : <span class="id">seq</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) : (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">x</span> \<span class="kwd">in</span> <span class="id">s</span> -&gt; <span class="id">closed</span> (<span class="id">F</span> <span class="id">x</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">x</span> &lt;- <span class="id">s</span>) <span class="id">F</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof246')">Proof.</span></div>
<div class="proofscript" id="proof246">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">scF</a></span>; <span class="id">rewrite</span> <span class="id">big_seq</span>.<br/>
<span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_ind</span> : <span class="id">_</span> =&gt; //; [<span class="id">exact</span>: <span class="id">closed0</span>|<span class="id">exact</span>: <span class="id">closedU</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigcup</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed_bigsetU">T</a></span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">A</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id">F</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">F</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof247')">Proof.</span></div>
<div class="proofscript" id="proof247">
<span class="id">move</span>=&gt; <span class="id">finA</span> <span class="id">cF</span>; <span class="id">rewrite</span> -<span class="id">bigsetU_fset_set</span>//; <span class="id">apply</span>: <span class="id">closed_bigsetU</span> =&gt; <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">in_fset_set</span>// <span class="id">inE</span>; <span class="id">exact</span>: <span class="id">cF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">closure_lemmas</span>.<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">E</span> <span class="id">A</span> <span class="id">B</span> <span class="id">U</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">T</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_subset</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">closure</span> <span class="id">A</span> `&lt;=` <span class="id">closure</span> <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof248')">Proof.</span></div>
<div class="proofscript" id="proof248">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? <span class="id">CAx</span> ?; <span class="id">move</span>/<span class="id">CAx</span>; <span class="id">exact</span>/<span class="id">subsetI_neq0</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureE</span> <span class="id">A</span> : <span class="id">closure</span> <span class="id">A</span> = <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">smallest</a></span> <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof249')">Proof.</span></div>
<div class="proofscript" id="proof249">
<span class="id">rewrite</span> <span class="id"><a name="closureC">eqEsubset</a></span>; <span class="id">split</span>=&gt; [<span class="id">x</span> ? <span class="id">B</span> [<span class="id">cB</span> <span class="id">AB</span>]|]; <span class="id">first</span> <span class="id">exact</span>/<span class="id">cB</span>/(<span class="id"><a href="mathcomp.analysis.topology.html#open">closure_subset</a></span> <span class="id">AB</span>).<br/>
<span class="id">exact</span>: (<span class="id">smallest_sub</span> (@<span class="id">closed_closure</span> <span class="id">_</span> <span class="id">_</span>) (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureC</span> <span class="id">E</span> :<br/>
&nbsp;&nbsp;~` <span class="id">closure</span> <span class="id">E</span> = \<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">U</span> | <span class="id">open</span> <span class="id">U</span> /\ <span class="id">U</span> `&lt;=` ~` <span class="id">E</span>]) <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof250')">Proof.</span></div>
<div class="proofscript" id="proof250">
<span class="id">rewrite</span> <span class="id">closureE</span> <span class="id">setC_bigcap</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">t</span> [<span class="id">U</span> [? <span class="id">EU</span> <span class="id">Ut</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (~` <span class="id">U</span>) =&gt; //; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">closed_openC</span>|<span class="id">exact</span>: <span class="id">subsetC</span>].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">setCK</span> <span class="id">E</span>); <span class="kwd">exists</span> (~` <span class="id">U</span>)=&gt; //; <span class="id">split</span>; [<span class="id">exact</span>:<span class="id">open_closedC</span>|<span class="id">exact</span>:<span class="id">subsetC</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_id</span> <span class="id">E</span> : <span class="id">closed</span> <span class="id">E</span> &lt;-&gt; <span class="id">E</span> = <span class="id">closure</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof251')">Proof.</span></div>
<div class="proofscript" id="proof251">
<span class="id">split</span>=&gt; [?|-&gt;]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">closure_lemmas</span>.<br/>
<br/>
<h2> Compact sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id">Compact</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cluster</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := [<span class="id">set</span> <span class="id">p</span> : <span class="id">T</span> | <span class="id">F</span> `#` <span class="id">nbhs</span> <span class="id">p</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cluster_nbhs</span> <span class="id">t</span> : <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">t</span>) <span class="id">t</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof252')">Proof.</span></div>
<div class="proofscript" id="proof252">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> /<span class="id">nbhs_singleton</span> <span class="id">At</span> /<span class="id">nbhs_singleton</span> <span class="id">Bt</span>; <span class="kwd">exists</span> <span class="id">t</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clusterEonbhs</span> <span class="id">F</span> : <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> `#` <span class="id">open_nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof253')">Proof.</span></div>
<div class="proofscript" id="proof253">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id"><a name="closureEcluster">meets_openr</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clusterE</span> <span class="id">F</span> : <span class="id">cluster</span> <span class="id">F</span> = \<span class="id">bigcap_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>) (<span class="id">closure</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof254')">Proof.</span></div>
<div class="proofscript" id="proof254">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a name="cvg_cluster">predeqE</a></span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; <span class="id">cF</span> ????; <span class="id">apply</span>: <span class="id">cF</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureEcluster</span> <span class="id">E</span> : <span class="id">closure</span> <span class="id">E</span> = <span class="id">cluster</span> (<span class="id">globally</span> <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof255')">Proof.</span></div>
<div class="proofscript" id="proof255">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEnbhs</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_cluster</span> <span class="id">F</span> <span class="id">G</span> : <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> `&lt;=` <span class="id">cluster</span> <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof256')">Proof.</span></div>
<div class="proofscript" id="proof256">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sGF</span> <span class="id">p</span> <span class="id">Fp</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">GP</span> <span class="id">Qp</span>; <span class="id">apply</span>: <span class="id">Fp</span> <span class="id">Qp</span>; <span class="id">apply</span>: <span class="id">sGF</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cluster_cvgE</span> <span class="id">F</span> :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="kwd">exists2</span> <span class="id">G</span>, <span class="id">ProperFilter</span> <span class="id">G</span> &amp; <span class="id">G</span> --&gt; <span class="id">p</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof257')">Proof.</span></div>
<div class="proofscript" id="proof257">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">have</span> [<span class="id">F0</span>|<span class="id"><a href="mathcomp.classical.classical_sets.html#subset0">nF0</a></span>] := <span class="id">pselect</span> (<span class="id">F</span> <span class="id">set0</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> -&gt; : <span class="id">cluster</span> <span class="id">F</span> = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">subset0</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">clusterE</a></span> =&gt; <span class="id">x</span> /(<span class="id">_</span> <span class="id">set0</span> <span class="id">F0</span>); <span class="id">rewrite</span> <span class="id">closure0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>; <span class="id">rewrite</span> -<span class="id">subset0</span> =&gt; <span class="id">p</span> [? <span class="id">PG</span> [<span class="id">_</span> /(<span class="id">_</span> <span class="id">set0</span> <span class="id">F0</span>)]]; <span class="id">apply</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">PG</a></span>.<br/>
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filterI">p</a></span>; <span class="id">have</span> <span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span> <span class="kwd">by</span> [].<br/>
<span class="id">split</span>=&gt; [<span class="id">clFp</span>|[<span class="id">G</span> <span class="id">Gproper</span> [<span class="id">cvGp</span> <span class="id">sFG</span>]] <span class="id">A</span> <span class="id">B</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">sFG</span> <span class="id">GA</span> /<span class="id">cvGp</span> <span class="id">GB</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id">_</span> <span class="id">G</span>); <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">exists</span> (<span class="id">filter_from</span> (\<span class="id">bigcup_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">A</a></span> <span class="kwd">in</span> <span class="id">F</span>) [<span class="id">set</span> <span class="id">A</span> `&amp;` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">p</span>]) <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">apply</a></span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id"><a href="mathcomp.analysis.topology.html#filterT">A</a></span> <span class="id">FA</span> [<span class="id">B</span> <span class="id">p_B</span> &lt;-]]; <span class="id">have</span> := <span class="id">clFp</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FA</span> <span class="id">p_B</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">setT</span>; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> [<span class="id">A1</span> <span class="id">FA1</span> [<span class="id">B1</span> <span class="id">p_B1</span> &lt;-]] [<span class="id">A2</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIACA">FA2</a></span> [<span class="id">B2</span> <span class="id">p_B2</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A1</span> `&amp;` <span class="id">B1</span> `&amp;` (<span class="id">A2</span> `&amp;` <span class="id">B2</span>)) =&gt; //; <span class="kwd">exists</span> (<span class="id">A1</span> `&amp;` <span class="id">A2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B1</span> `&amp;` <span class="id">B2</span>); [<span class="id">apply</span>: <span class="id">filterI</span>|<span class="id">rewrite</span> <span class="id">setIACA</span>].<br/>
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">A</a></span> <span class="id">p_A</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#Compact.T">rewrite</a></span> <span class="id">setIC</span> <span class="id">setIT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">FA</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureEcvg</span> (<span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>):<br/>
&nbsp;&nbsp;<span class="id">closure</span> <span class="id">E</span> =<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">p</span> | <span class="kwd">exists2</span> <span class="id">G</span>, <span class="id">ProperFilter</span> <span class="id">G</span> &amp; <span class="id">G</span> --&gt; <span class="id">p</span> /\ <span class="id">globally</span> <span class="id">E</span> `&lt;=` <span class="id">G</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof258')">Proof.</span></div>
<div class="proofscript" id="proof258">
 <span class="kwd">by</span> <span class="id"><a name="compact0">rewrite</a></span> <span class="id">closureEcluster</span> <span class="id">cluster_cvgE</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compact</span> <span class="id">A</span> := <span class="kwd">forall</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)),<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">cluster</span> <span class="id">F</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact0</span> : <span class="id">compact</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof259')">Proof.</span></div>
<div class="proofscript" id="proof259">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">FF</span> /<span class="id">filter_ex</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subclosed_compact</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof260')">Proof.</span></div>
<div class="proofscript" id="proof260">
<span class="id">move</span>=&gt; <span class="id">Acl</span> <span class="id">Bco</span> <span class="id">sAB</span> <span class="id">F</span> <span class="id">Fproper</span> <span class="id">FA</span>.<br/>
<span class="id">have</span> [|<span class="id">p</span> [<span class="id">Bp</span> <span class="id">Fp</span>]] := <span class="id">Bco</span> <span class="id">F</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterS</span> <span class="id">FA</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">Acl</span>=&gt; <span class="id">C</span> <span class="id">Cp</span>; <span class="id">apply</span>: <span class="id">Fp</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">hausdorff_space</a></span> := <span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span> : <span class="id">T</span>, <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">p</span>) <span class="id">q</span> -&gt; <span class="id">p</span> = <span class="id">q</span>.<br/>
<br/>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">within</span>.<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">within_nbhs_proper</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">p</span> :<br/>
&nbsp;&nbsp;<span class="id">infer</span> (<span class="id">closure</span> <span class="id">A</span> <span class="id">p</span>) -&gt; <span class="id">ProperFilter</span> (<span class="id">within</span> <span class="id">A</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">nbhs</a></span> <span class="id">p</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof261')">Proof.</span></div>
<div class="proofscript" id="proof261">
<span class="id">move</span>=&gt; <span class="id">clAp</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span> =&gt; <span class="id">B</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clAp</span> [<span class="id">q</span> [<span class="id">Aq</span> <span class="id">AqsoBq</span>]]; <span class="kwd">exists</span> <span class="id">q</span>; <span class="id">apply</span>: <span class="id">AqsoBq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">hausdorff_space</span> -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof262')">Proof.</span></div>
<div class="proofscript" id="proof262">
<span class="id">move</span>=&gt; <span class="id">hT</span> <span class="id">Aco</span> <span class="id">p</span> <span class="id">clAp</span>; <span class="id">have</span> <span class="id">pA</span> := !! @<span class="id">withinT</span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">p</span>) <span class="id">A</span> <span class="id">_</span>.<br/>
<span class="id">have</span> [<span class="id">q</span> [<span class="id">Aq</span> <span class="id">clsAp_q</span>]] := !! <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">pA</span>; <span class="id">rewrite</span> (<span class="id">hT</span> <span class="id">p</span> <span class="id">q</span>) //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_cluster</span> <span class="id">clsAp_q</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_set1</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">compact</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof263')">Proof.</span></div>
<div class="proofscript" id="proof263">
<span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">PF</span> <span class="id">Fx</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> [].<br/>
<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">B</span> <span class="id">nbhsB</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">nbhs_singleton</span>.<br/>
<span class="id">suff</span> [<span class="id">y</span> [<span class="id">Py</span> &lt;-//]] : <span class="id">P</span> `&amp;` [<span class="id">set</span> <span class="id">x</span>] !=<span class="id">set0</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_ex</span>; [<span class="id">exact</span>: <span class="id">PF</span>| <span class="id">exact</span>: <span class="id">filterI</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Compact</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">hausdorff_space</span> : <span class="id">clear</span> <span class="id">implicits</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#clopen">ClopenSets</a></span>.<br/>
<span class="kwd">Implicit</span> <span class="kwd">Type</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clopen</span> {<span class="id">T</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">open</span> <span class="id">A</span> /\ <span class="id">closed</span> <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenI</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> <span class="id">B</span> -&gt; <span class="id">clopen</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof264')">Proof.</span></div>
<div class="proofscript" id="proof264">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ? [] ? ?; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openI</span> | <span class="id">exact</span>: <span class="id">closedI</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenU</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> <span class="id">B</span> -&gt; <span class="id">clopen</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof265')">Proof.</span></div>
<div class="proofscript" id="proof265">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ? [] ? ?; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openU</span> | <span class="id">exact</span>: <span class="id">closedU</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenC</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> (~`<span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof266')">Proof.</span></div>
<div class="proofscript" id="proof266">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ?; <span class="id">split</span>;[<span class="id">exact</span>: <span class="id">closed_openC</span> | <span class="id">exact</span>: <span class="id">open_closedC</span> ]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen0</span> {<span class="id">T</span>} : @<span class="id">clopen</span> <span class="id">T</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof267')">Proof.</span></div>
<div class="proofscript" id="proof267">
 <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">open0</span> | <span class="id">exact</span>: <span class="id">closed0</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenT</span> {<span class="id">T</span>} : <span class="id">clopen</span> [<span class="id">set</span>: <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof268')">Proof.</span></div>
<div class="proofscript" id="proof268">
 <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openT</span> | <span class="id">exact</span>: <span class="id">closedT</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_comp</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ClopenSets">T</a></span> -&gt; <span class="id">U</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) :<br/>
&nbsp;<span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">continuous</span> <span class="id">f</span> -&gt; <span class="id">clopen</span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof269')">Proof.</span></div>
<div class="proofscript" id="proof269">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ?; <span class="id">split</span>; [ <span class="id"><a href="mathcomp.analysis.topology.html#near_covering.X">exact</a></span>: <span class="id">open_comp</span> | <span class="id">exact</span>: <span class="id">closed_comp</span>]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">ClopenSets</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">near_covering</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">near_covering</span> (<span class="id">K</span> : <span class="id">set</span> <span class="id">X</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">I</span>)) (<span class="id">P</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="kwd">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">K</span> <span class="id">x</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span>' \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id">i</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">i</span> <span class="id">x</span>') -&gt;<br/>
&nbsp;&nbsp;\<span class="id">near</span> <span class="id">F</span>, <span class="id">K</span> `&lt;=` <span class="id">P</span> <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">near_covering_compact</span> : <span class="id">near_covering</span> `&lt;=` <span class="id">compact</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof270')">Proof.</span></div>
<div class="proofscript" id="proof270">
<span class="id">move</span>=&gt; <span class="id">K</span> <span class="id">locK</span> <span class="id">F</span> <span class="id">PF</span> <span class="id">FK</span>; <span class="id">apply</span>/<span class="id">set0P</span>/<span class="id">eqP</span>=&gt; <span class="id">KclstF0</span>; <span class="id">case</span>: (<span class="id">PF</span>) =&gt; + <span class="id">FF</span>; <span class="id">apply</span>.<br/>
<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">xpredp0</span> = <span class="id">set0</span>)// -(<span class="id">setICr</span> <span class="id">K</span>); <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //.<br/>
<span class="id">have</span> /<span class="id">locK</span> : <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">K</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">x</span>' \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id">i</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> <span class="id">F</span>, (~` <span class="id">i</span>) <span class="id">x</span>'.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Kx</span>; <span class="id">have</span> : ~ <span class="id">cluster</span> <span class="id">F</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">contraPnot</span> <span class="id">KclstF0</span> =&gt; <span class="id">clstFx</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">existsNP</span> [<span class="id">U</span> /<span class="id">existsNP</span> [<span class="id">V</span> /<span class="id">not_implyP</span> [<span class="id">FU</span> /<span class="id">not_implyP</span> [<span class="id">nbhsV</span>]]]] <span class="id">UV0</span>.<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">x</span>' <span class="id">W</span> =&gt; //= =&gt; <span class="id">Wx</span>'; <span class="id">apply</span>: <span class="id">UV0</span>; <span class="kwd">exists</span> <span class="id">x</span>'.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">small_set_sub</span> <span class="id">FU</span>) <span class="id">W</span>) | <span class="id">exact</span>: (<span class="id">near</span> <span class="id">nbhsV</span> <span class="id">x</span>')].<br/>
<span class="id">case</span>=&gt; <span class="id">G</span> [<span class="id">GF</span> <span class="id">Gdown</span> [<span class="id">U</span> <span class="id">GU</span>]] <span class="id">GP</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">U</span>); <span class="id">last</span> <span class="id">exact</span>: <span class="id">GF</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Uy</span> <span class="id">Ky</span>; <span class="id">exact</span>: (<span class="id">GP</span> <span class="id">_</span> <span class="id">GU</span> <span class="id">y</span> <span class="id">Ky</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">compact_near_covering</span> : <span class="id">compact</span> `&lt;=` <span class="id">near_covering</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof271')">Proof.</span></div>
<div class="proofscript" id="proof271">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">K</a></span> <span class="id">cptK</span> <span class="id">I</span> <span class="id">F</span> <span class="id">P</span> <span class="id">FF</span> <span class="id">cover</span>.<br/>
<span class="id">pose</span> <span class="id">badPoints</span> := <span class="kwd">fun</span> <span class="id">U</span> =&gt; <span class="id">K</span> `\` [<span class="id">set</span> <span class="id">x</span> | <span class="id">K</span> <span class="id">x</span> /\ <span class="id">U</span> `&lt;=` <span class="id">P</span> ^~ <span class="id">x</span>].<br/>
<span class="id">pose</span> <span class="id">G</span> := <span class="id">filter_from</span> <span class="id">F</span> <span class="id">badPoints</span>.<br/>
<span class="id">have</span> <span class="id">FG</span> : <span class="id">Filter</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">L</span> <span class="id">R</span> <span class="id">FL</span> <span class="id">FR</span>; <span class="kwd">exists</span> (<span class="id">L</span> `&amp;` <span class="id">R</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">badPoints</span> /= !<span class="id">setDIr</span> !<span class="id">setDv</span> !<span class="id">set0U</span> -<span class="id">setDUr</span>; <span class="id">apply</span>: <span class="id">setDS</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [|] =&gt; + ? [? ?]; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">exact</a></span>.<br/>
<span class="id">have</span> [[<span class="id">V</span> <span class="id">FV</span>]|<span class="id">G0</span>] := <span class="id">pselect</span> (<span class="id">G</span> <span class="id">set0</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">subset0</span> <span class="id">setD_eq0</span> =&gt; <span class="id">subK</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">V</span>) =&gt; // ? ? ? /<span class="id">subK</span> [?]; <span class="id">exact</span>.<br/>
<span class="id">have</span> <span class="id">PG</span> : <span class="id">ProperFilter</span> <span class="id">G</span> <span class="kwd">by</span> [].<br/>
<span class="id">have</span> <span class="id">GK</span> : <span class="id">G</span> <span class="id">K</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">exact</span>: <span class="id">filterT</span> | <span class="id">move</span>=&gt; ? []].<br/>
<span class="id">case</span>: (<span class="id">cptK</span> <span class="id">_</span> <span class="id">PG</span> <span class="id">GK</span>) =&gt; <span class="id">x</span> [<span class="id">Kx</span>].<br/>
<span class="id">have</span> [[/= <span class="id">U1</span> <span class="id">U2</span>] [<span class="id">U1x</span> <span class="id">FU2</span> <span class="id">subP</span>]] := <span class="id">cover</span> <span class="id">x</span> <span class="id">Kx</span>.<br/>
<span class="id">have</span> <span class="id">GP</span> : <span class="id">G</span> (<span class="id">badPoints</span> (<span class="id">P</span> ^~ <span class="id">x</span> `&amp;` <span class="id">U2</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="kwd">exists</span> (<span class="id">P</span> ^~ <span class="id">x</span> `&amp;` <span class="id">U2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">i</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: (<span class="id">near</span> <span class="id">FU2</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subP</span> (<span class="id">x</span>, <span class="id">i</span>)); <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">nbhs_singleton</span>|<span class="id">exact</span>: (<span class="id">near</span> <span class="id">FU2</span> <span class="id">i</span>)].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">GP</a></span> <span class="id">U1x</span>) =&gt; [[<span class="id">x</span>'[]]][] <span class="id">Kx</span>' /[<span class="id">swap</span>] <span class="id">U1x</span>'.<br/>
<span class="kwd">by</span> <span class="id">case</span>; <span class="id">split</span> =&gt; // <span class="id">i</span> [? ?]; <span class="id">exact</span>: (<span class="id">subP</span> (<span class="id">x</span>', <span class="id">i</span>)).<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_near_coveringP</span> <span class="id">A</span> : <span class="id">compact</span> <span class="id">A</span> &lt;-&gt; <span class="id">near_covering</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof272')">Proof.</span></div>
<div class="proofscript" id="proof272">
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id"><a name="ultra_proper">exact</a></span>: <span class="id">compact_near_covering</span>| <span class="id">exact</span>: <span class="id">near_covering_compact</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">near_covering</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Tychonoff</span>.<br/>
<br/>
<span class="kwd">Class</span> <span class="id">UltraFilter</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id">ultra_proper</span> :&gt; <span class="id">ProperFilter</span> <span class="id"><a href="mathcomp.analysis.topology.html#UltraFilter">F</a></span> ;<br/>
&nbsp;&nbsp;<span class="id">max_filter</span> : <span class="kwd">forall</span> <span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>), <span class="id">ProperFilter</span> <span class="id">G</span> -&gt; <span class="id">F</span> `&lt;=` <span class="id">G</span> -&gt; <span class="id">G</span> = <span class="id">F</span><br/>
}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultra_cvg_clusterE</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> --&gt; <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof273')">Proof.</span></div>
<div class="proofscript" id="proof273">
<span class="id">move</span>=&gt; <span class="id">FU</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">cluster_cvgE</span> =&gt; - [<span class="id">G</span> <span class="id">GF</span> [<span class="id">cvGp</span> /<span class="id">max_filter</span> &lt;-]].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">cvFp</span>; <span class="id">rewrite</span> <span class="id">cluster_cvgE</span>; <span class="kwd">exists</span> <span class="id">F</span>; [<span class="id">apply</span>: <span class="id">ultra_proper</span>|<span class="id">split</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultraFilterLemma</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="kwd">exists</span> <span class="id">G</span>, <span class="id">UltraFilter</span> <span class="id">G</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof274')">Proof.</span></div>
<div class="proofscript" id="proof274">
<span class="id">move</span>=&gt; <span class="id">FF</span>.<br/>
<span class="id">set</span> <span class="id">filter_preordset</span> := ({<span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>) &amp; <span class="id">ProperFilter</span> <span class="id">G</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>}).<br/>
<span class="id">set</span> <span class="id">preorder</span> := <span class="kwd">fun</span> <span class="id">G1</span> <span class="id">G2</span> : <span class="id">filter_preordset</span> =&gt; <span class="id">projT1</span> <span class="id">G1</span> `&lt;=` <span class="id">projT1</span> <span class="id">G2</span>.<br/>
<span class="id">suff</span> [<span class="id">G</span> <span class="id">Gmax</span>] : <span class="kwd">exists</span> <span class="id">G</span> : <span class="id">filter_preordset</span>, <span class="id">premaximal</span> <span class="id">preorder</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">have</a></span> [<span class="id">GF</span> <span class="id">sFG</span>] := <span class="id">projT2</span> <span class="id">G</span>; <span class="kwd">exists</span> (<span class="id">projT1</span> <span class="id">G</span>); <span class="id">split</span>=&gt; //; <span class="id">split</span>=&gt; // <span class="id">H</span> <span class="id">HF</span> <span class="id">sGH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sFH</span> : <span class="id">F</span> `&lt;=` <span class="id">H</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">sGH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sHG</span> : <span class="id">preorder</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">H</span> (<span class="id">conj</span> <span class="id">HF</span> <span class="id">sFH</span>)) <span class="id">G</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Gmax</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; ?; <span class="id">split</span>=&gt; [/<span class="id">sHG</span>|/<span class="id">sGH</span>].<br/>
<span class="id">have</span> <span class="id">sFF</span> : <span class="id">F</span> `&lt;=` <span class="id">F</span> <span class="kwd">by</span> [].<br/>
<span class="id">apply</span>: (<span class="id">ZL_preorder</span> ((<span class="id">existT</span> <span class="id">_</span> <span class="id">F</span> (<span class="id">conj</span> <span class="id">FF</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">sFF</a></span>)) : <span class="id">filter_preordset</span>)) =&gt;<br/>
&nbsp;&nbsp;[?|<span class="id">G</span> <span class="id">H</span> <span class="id">I</span> <span class="id">sGH</span> <span class="id">sHI</span> ? /<span class="id">sGH</span> /<span class="id"><a href="mathcomp.classical.boolp.html#asbool_neg">sHI</a></span>|<span class="id">A</span> <span class="id">Atot</span>] //.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">A</span> !=<span class="id">set0</span>)) =&gt; [[<span class="id">G</span> <span class="id">AG</span>] | <span class="id">A0</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">F</span> (<span class="id">conj</span> <span class="id">FF</span> <span class="id">sFF</span>)) =&gt; <span class="id">G</span> <span class="id">AG</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">A0</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> /(<span class="id">_</span> <span class="id">G</span>).<br/>
<span class="id">have</span> [<span class="id">GF</span> <span class="id">sFG</span>] := <span class="id">projT2</span> <span class="id">G</span>.<br/>
<span class="id">suff</span> <span class="id">UAF</span> : <span class="id">ProperFilter</span> (\<span class="id">bigcup_</span>(<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">H</a></span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sFUA</span> : <span class="id">F</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">H</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">FB</span>; <span class="kwd">exists</span> <span class="id">G</span> =&gt; //; <span class="id">apply</span>: <span class="id">sFG</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> (\<span class="id">bigcup_</span>(<span class="id">H</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>) (<span class="id">conj</span> <span class="id">UAF</span> <span class="id">sFUA</span>)) =&gt; <span class="id">H</span> <span class="id">AH</span> <span class="id">B</span> <span class="id">HB</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">H</span>.<br/>
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> [<span class="id">H</span> <span class="id">AH</span> <span class="id">HB</span>]; <span class="id">have</span> [<span class="id">HF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">H</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id">_</span> <span class="id">_</span> <span class="id">HF</span>).<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">G</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> [<span class="id">HB</span> <span class="id">AHB</span> <span class="id">HBB</span>] [<span class="id">HC</span> <span class="id">AHC</span> <span class="id">HCC</span>]; <span class="id">have</span> [<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">sHBC</a></span>|<span class="id">sHCB</span>] := <span class="id">Atot</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AHB</span> <span class="id">AHC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">HC</span> =&gt; //; <span class="id">have</span> [<span class="id">HCF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">HC</span>; <span class="id">apply</span>: <span class="id">filterI</span> <span class="id">HCC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sHBC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">HB</span> =&gt; //; <span class="id">have</span> [<span class="id">HBF</span> <span class="id"><a name="compact_ultra">_</a></span>] := <span class="id">projT2</span> <span class="id">HB</span>; <span class="id">apply</span>: <span class="id">filterI</span> <span class="id">HBB</span> <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sHCB</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> <span class="id">SBC</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">H</a></span> <span class="id">AH</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">HB</a></span>]; <span class="kwd">exists</span> <span class="id">H</span> =&gt; //; <span class="id">have</span> [<span class="id">HF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">H</span>.<br/>
<span class="id">exact</span>: <span class="id">filterS</span> <span class="id">HB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_ultra</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> = [<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> <span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> --&gt; <span class="id">p</span>] !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof275')">Proof.</span></div>
<div class="proofscript" id="proof275">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; <span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">Aco</span> [<span class="id">p</span> [?]] := <span class="id">FA</span>; <span class="id">rewrite</span> <span class="id">ultra_cvg_clusterE</span>; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
<span class="id">have</span> [<span class="id">G</span> [<span class="id">GU</span> <span class="id">sFG</span>]] := <span class="id">ultraFilterLemma</span> <span class="id">FF</span>.<br/>
<span class="id">have</span> /<span class="id">Aco</span> [<span class="id">p</span> [<span class="id">Ap</span>]] : <span class="id">G</span> <span class="id">A</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sFG</span>.<br/>
<span class="id">rewrite</span> /= -[<span class="id">_</span> --&gt; <span class="id">p</span>]/([<span class="id">set</span> <span class="id">_</span> | <span class="id">_</span>] <span class="id">p</span>) -<span class="id">ultra_cvg_clusterE</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">cvg_cluster</span> <span class="id">sFG</span>); <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_image</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">T</a></span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">Filter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof276')">Proof.</span></div>
<div class="proofscript" id="proof276">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fsurj</span>; <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> [<span class="id">A</span> <span class="id">FA</span> &lt;-] [<span class="id">B</span> <span class="id">FB</span> &lt;-].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` (<span class="id">f</span> @` <span class="id">A</span> `&amp;` <span class="id">f</span> @` <span class="id">B</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sAB</span> : <span class="id">A</span> `&amp;` <span class="id">B</span> `&lt;=` <span class="id">f</span> @^-1` (<span class="id">f</span> @` <span class="id">A</span> `&amp;` <span class="id">f</span> @` <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">Ax</span> <span class="id">Bx</span>]; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">sAB</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> [<span class="id">C</span> <span class="id">FC</span> <span class="id">fC_eqA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">B</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FC</span> =&gt; <span class="id">p</span> <span class="id">Cp</span>; <span class="id">apply</span>: <span class="id">sAB</span>; <span class="id">rewrite</span> -<span class="id">fC_eqA</span>; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">proper_image</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">T</a></span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">ProperFilter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof277')">Proof.</span></div>
<div class="proofscript" id="proof277">
<span class="id">move</span>=&gt; <span class="id"><a name="principal_filter_ultra">FF</a></span> <span class="id">fsurj</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">filter_image</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">A</span> <span class="id">FA</span> &lt;-]; <span class="id">have</span> /<span class="id">filter_ex</span> [<span class="id">p</span> <span class="id">Ap</span>] := <span class="id">FA</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">p</span>); <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">principal_filter_ultra</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> (<span class="id">principal_filter</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof278')">Proof.</span></div>
<div class="proofscript" id="proof278">
<span class="id">split</span>=&gt; [|<span class="id">G</span> [<span class="id">G0</span> <span class="id">xG</span>] <span class="id">FG</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">principal_filter_proper</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; // <span class="id">U</span> <span class="id"><a name="in_ultra_setVsetC">GU</a></span>; <span class="id">apply</span>/<span class="id">principal_filterP</span>.<br/>
<span class="id">have</span> /(<span class="id">filterI</span> <span class="id">GU</span>): <span class="id">G</span> [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">exact</span>/<span class="id">FG</span>/<span class="id">principal_filterP</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">set1I</span>; <span class="id">case</span>: <span class="id">ifPn</span> =&gt; // /[!<span class="id">inE</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">in_ultra_setVsetC</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> \/ <span class="id">F</span> (~` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof279')">Proof.</span></div>
<div class="proofscript" id="proof279">
<span class="id">move</span>=&gt; <span class="id">FU</span>; <span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">F</span> (~` <span class="id">A</span>))) =&gt; [|<span class="id">nFnA</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">right</span>.<br/>
<span class="id">left</span>; <span class="id">suff</span> : <span class="id">ProperFilter</span> (<span class="id">filter_from</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterT">F</a></span> `|` [<span class="id">set</span> <span class="id">A</span> `&amp;` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">F</span>]) <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">max_filter</span> &lt;-; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">FB</span>; <span class="kwd">exists</span> <span class="id">B</span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
<span class="id">apply</span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">B</span> [|[<span class="id">C</span> <span class="id">FC</span> &lt;-]]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filter_ex</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">AC0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nFnA</span>; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FC</span> =&gt; <span class="id">p</span> <span class="id">Cp</span> <span class="id">Ap</span>; <span class="id">apply</span>: (<span class="id">AC0</span> <span class="id">p</span>).<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> [<span class="id">FB</span>|[<span class="id">DB</span> <span class="id">FDB</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">FC</span>|[<span class="id">DC</span> <span class="id">FDC</span> &lt;-]]; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id">C</span>)=&gt; //; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">B</span> `&amp;` <span class="id">DC</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setICA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id">DC</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">FC</span>|[<span class="id">DC</span> <span class="id">FDC</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">DB</span> `&amp;` <span class="id">C</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">DB</span> `&amp;` <span class="id">C</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">DB</span> `&amp;` <span class="id">DC</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">rewrite</span> <span class="id">setIACA</span> <span class="id">setIid</span>.<br/>
<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">DB</span> `&amp;` <span class="id">DC</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultra_image</span> (<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">UltraFilter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof280')">Proof.</span></div>
<div class="proofscript" id="proof280">
<span class="id">move</span>=&gt; <span class="id">FU</span> <span class="id">fsurj</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">proper_image</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">G</span> <span class="id">GF</span> <span class="id">sfFG</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">sfFG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">GA</span>; <span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">A</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
<span class="id">have</span> [//|<span class="id">FnAf</span>] := <span class="id">in_ultra_setVsetC</span> (<span class="id">f</span> @^-1` <span class="id">A</span>) <span class="id">FU</span>.<br/>
<span class="id">have</span> : <span class="id">G</span> (<span class="id">f</span> @` (~` (<span class="id">f</span> @^-1` <span class="id">A</span>))) <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sfFG</span>; <span class="kwd">exists</span> (~` (<span class="id">f</span> @^-1` <span class="id">A</span>)).<br/>
<span class="id">suff</span> : ~ <span class="id">G</span> (<span class="id">f</span> @` (~` (<span class="id">f</span> @^-1` <span class="id">A</span>))) <span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">preimage_setC</span> <span class="id">image_preimage</span> // =&gt; <span class="id">GnA</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">filter_ex</span> [? []] : <span class="id">G</span> (<span class="id">A</span> `&amp;` (~` <span class="id">A</span>)) <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tychonoff</span> (<span class="id">I</span> : <span class="id">eqType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>)<br/>
&nbsp;&nbsp;(<span class="id">A</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">set</span> (<span class="id">T</span> <span class="id">i</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">compact</span> (<span class="id">A</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;@<span class="id">compact</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">f</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> <span class="id">i</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#ReflectT">i</a></span> (<span class="id">f</span> <span class="id">i</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof281')">Proof.</span></div>
<div class="proofscript" id="proof281">
<span class="id">move</span>=&gt; <span class="id">Aco</span>; <span class="id">rewrite</span> <span class="id">compact_ultra</span> =&gt; <span class="id">F</span> <span class="id">FU</span> <span class="id">FA</span>.<br/>
<span class="id">set</span> <span class="id">subst_coord</span> := <span class="kwd">fun</span> (<span class="id">i</span> : <span class="id">I</span>) (<span class="id">pi</span> : <span class="id">T</span> <span class="id">i</span>) (<span class="id">f</span> : <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">I</span>, <span class="id">T</span> <span class="id">x</span>) (<span class="id">j</span> : <span class="id">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">eqP</span> <span class="id">is</span> <span class="id">ReflectT</span> <span class="id">e</span> <span class="kwd">then</span> <span class="id">ecast</span> <span class="id">i</span> (<span class="id">T</span> <span class="id">i</span>) (<span class="id">esym</span> <span class="id">e</span>) <span class="id">pi</span> <span class="kwd">else</span> <span class="id">f</span> <span class="id">j</span>.<br/>
<span class="id">have</span> <span class="id">subst_coordT</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> : <span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">i</span> = <span class="id">pi</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">subst_coord</span>; <span class="id">case</span> <span class="id">eqP</span> =&gt; // <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">eq_irrelevance</span> <span class="id">e</span> (<span class="id">erefl</span> <span class="id">_</span>)).<br/>
<span class="id">have</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">subst_coordN</a></span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">j</span> : <span class="id">i</span> != <span class="id">j</span> -&gt; <span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">j</span> = <span class="id">f</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">inej</a></span>; <span class="id">rewrite</span> /<span class="id">subst_coord</span>; <span class="id">case</span>: <span class="id">eqP</span> =&gt; // <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">inej</span>; <span class="id">rewrite</span> {1}<span class="id">e</span> =&gt; /<span class="id">negP</span>.<br/>
<span class="id">have</span> <span class="id">pr_surj</span> <span class="id">i</span> : @^~ <span class="id">i</span> @` [<span class="id">set</span>: <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> <span class="id">i</span>] = <span class="id">setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">pi</span>; <span class="id">split</span>=&gt; // <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">point</span>))=&gt; //; <span class="id">rewrite</span> <span class="id">subst_coordT</span>.<br/>
<span class="id">set</span> <span class="id">pF</span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; [<span class="id">set</span> @^~ <span class="id">i</span> @` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<span class="id">have</span> <span class="id">pFultra</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">UltraFilter</span> (<span class="id">pF</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">apply</span>: <span class="id">ultra_image</span> (<span class="id">pr_surj</span> <span class="id">i</span>).<br/>
<span class="id">have</span> <span class="id">pFA</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">pF</span> <span class="id">i</span> (<span class="id">A</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">g</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> (<span class="id">g</span> <span class="id">i</span>)] =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">pi</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">g</span> <span class="id">Ag</span> &lt;-]; <span class="id">apply</span>: <span class="id">Ag</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">Aipi</span>; <span class="id">have</span> [<span class="id">f</span> <span class="id">Af</span>] := <span class="id">filter_ex</span> <span class="id">FA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span>); <span class="id">last</span> <span class="id">exact</span>: <span class="id">subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">j</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">i</span> <span class="id">j</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span>: <span class="id">_</span> /; <span class="id">rewrite</span> <span class="id">subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subst_coordN</span> -&gt;; <span class="id">apply</span>: <span class="id">Af</span>.<br/>
<span class="id">have</span> <span class="id">cvpFA</span> <span class="id">i</span> : <span class="id">A</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">pF</span> <span class="id">i</span> --&gt; <span class="id">p</span>] !=<span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ultra_cvg_clusterE</span>; <span class="id">apply</span>: <span class="id">Aco</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">get</span> (<span class="id">A</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">pF</span> <span class="id">i</span> --&gt; <span class="id">p</span>])).<br/>
<span class="id"><a name="compact_cluster_set1">split</a></span>=&gt; [<span class="id">i</span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">cvpFA</span> <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">i</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#compact">cvg_image</a></span>=&gt; //; <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">cvpFA</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Tychonoff</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cluster_set1</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">x</span> : <span class="id">T</span>) <span class="id">F</span> <span class="id">V</span> :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">compact</span> <span class="id">V</span> -&gt; <span class="id">nbhs</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">x</a></span> <span class="id">V</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">V</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">x</span>] -&gt; <span class="id">F</span> --&gt; <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof282')">Proof.</span></div>
<div class="proofscript" id="proof282">
<span class="id">move</span>=&gt; ? <span class="id">cptV</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">nxV</a></span> <span class="id">PF</span> <span class="id">FV</span> <span class="id">clFx1</span> <span class="id">U</span> <span class="id">nbhsU</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>.<br/>
<span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">nbhsU</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /= <span class="id">nbhsE</span> <span class="kwd">in</span> <span class="id">nbhsU</span>; <span class="id">case</span>: <span class="id">nbhsU</span> =&gt; <span class="id">O</span> <span class="id">oO</span> <span class="id">OsubU</span> /(<span class="id">_</span> <span class="id">O</span>) <span class="id">WH</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">OsubU</span>); <span class="id">apply</span>: <span class="id">WH</span>; [<span class="id">exact</span>: <span class="id">open_nbhs_nbhs</span> | <span class="kwd">by</span> <span class="id">case</span>: <span class="id">oO</span>].<br/>
<span class="id">have</span> /<span class="id">compact_near_coveringP</span> : <span class="id">compact</span> (<span class="id">V</span> `\` <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cptV</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedI</span>; [<span class="id">exact</span>: <span class="id">compact_closed</span> | <span class="id">exact</span>: <span class="id">open_closedC</span>].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> (<span class="id">powerset_filter_from</span> <span class="id">F</span>) (<span class="kwd">fun</span> <span class="id">W</span> <span class="id">x</span> =&gt; ~ <span class="id">W</span> <span class="id">x</span>))[].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">Vz</a></span> ?]; <span class="id">have</span> <span class="id">zE</span> : <span class="id">x</span> &lt;&gt; <span class="id">z</span> <span class="kwd">by</span> <span class="id">move</span>/<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">nbhs_singleton</a></span>: <span class="id">nbhsU</span> =&gt; /[<span class="id">swap</span>] -&gt;.<br/>
&nbsp;&nbsp;<span class="id">have</span> : ~ <span class="id">cluster</span> <span class="id">F</span> <span class="id">z</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">zE</span>; <span class="id">apply</span>: <span class="id">contra_not</span>; <span class="id">rewrite</span> <span class="id">clFx1</span> =&gt; -&gt;.<br/>
&nbsp;&nbsp;<span class="id">case</span>/<span class="id">existsNP</span>=&gt; <span class="id">C</span> /<span class="id">existsPNP</span> [<span class="id">D</span>] <span class="id">FC</span> /<span class="id">existsNP</span> [<span class="id">Dz</span>] /<span class="id">set0P</span>/<span class="id">negP</span>/<span class="id">negPn</span>/<span class="id">eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /<span class="id">disjoints_subset</span> <span class="id">CD0</span>; <span class="kwd">exists</span> (<span class="id">D</span>, [<span class="id">set</span> <span class="id">W</span> | <span class="id">F</span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>]).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; <span class="id">rewrite</span> //= <span class="id">nbhs_simpl</span>; <span class="id">exact</span>: <span class="id">powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; <span class="id">t</span> <span class="id">W</span> [<span class="id">Dt</span>] [<span class="id">FW</span>] /<span class="id">subsetCP</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">CD0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">M</span> [<span class="id">MF</span> <span class="id">ME2</span> [<span class="id">W</span>] <span class="id">MW</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">MW</span>) <span class="id">VUW</span>].<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">V</a></span> `&amp;` <span class="id">W</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">exact</a></span>: <span class="id">MF</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> [<span class="id">Vt</span> <span class="id">Wt</span>]; <span class="id">apply</span>: <span class="id">contrapT</span> =&gt; <span class="id">Ut</span>; <span class="id">exact</span>: (<span class="id">VUW</span> <span class="id">t</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">Precompact</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compactU</span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_ultra_setVsetC">A</a></span> <span class="id">B</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">B</span> -&gt; <span class="id">compact</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof283')">Proof.</span></div>
<div class="proofscript" id="proof283">
<span class="id">rewrite</span> <span class="id">compact_ultra</span> =&gt; <span class="id">cptA</span> <span class="id">cptB</span> <span class="id">F</span> <span class="id">UF</span> <span class="id">FAB</span>; <span class="id">rewrite</span> <span class="id">setIUl</span>.<br/>
<span class="id">have</span> [/<span class="id">cptA</span>[<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">AFx</a></span>]|] := <span class="id">in_ultra_setVsetC</span> <span class="id">A</span> <span class="id">UF</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">left</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">filterI</span> <span class="id">FAB</span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">setIUl</a></span> <span class="id">setICr</span> <span class="id">set0U</span> =&gt; <span class="id">FBA</span>.<br/>
<span class="id">have</span> /<span class="id">cptB</span>[<span class="id">x</span> <span class="id">BFx</span>] : <span class="id">F</span> <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FBA</span>; <span class="id">exact</span>: <span class="id">subIsetr</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">right</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bigsetU_compact</span> <span class="id">I</span> (<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">X</span>) (<span class="id">s</span> : <span class="id">seq</span> <span class="id">I</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#compact0">P</a></span> : <span class="id">pred</span> <span class="id">I</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">compact</span> (<span class="id">F</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> &lt;- <span class="id">s</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">F</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof284')">Proof.</span></div>
<div class="proofscript" id="proof284">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">elim</span>/<span class="id">big_ind</span> : <span class="id">_</span> =&gt;//; [<span class="id">exact</span>:<span class="id">compact0</span>|<span class="id">exact</span>:<span class="id">compactU</span>]. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compact_near</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">X</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">U</span>, <span class="id">F</span> <span class="id">U</span> &amp; <span class="id">compact</span> <span class="id">U</span> /\ <span class="id">closed</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">U</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">precompact</span> (<span class="id">C</span> : <span class="id">set</span> <span class="id">X</span>) := <span class="id">compact_near</span> (<span class="id">globally</span> <span class="id">C</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">precompactE</a></span> (<span class="id">C</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">precompact</span> <span class="id">C</span> = <span class="id">compact</span> (<span class="id">closure</span> <span class="id">C</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof285')">Proof.</span></div>
<div class="proofscript" id="proof285">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#subclosed_compact">B</a></span> <span class="id">CsubB</span> [<span class="id">cptB</span> <span class="id">cB</span>]]|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">clC</span>; <span class="kwd">exists</span> (<span class="id">closure</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure_id">C</a></span>) =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id"><a name="precompact_subset">exact</a></span>: <span class="id">closed_closure</span>.<br/>
<span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cptB</span>); <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#precompact">exact</a></span>: <span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">closure_id</span>: <span class="id">cB</span> =&gt; -&gt;; <span class="id">exact</span>: <span class="id">closure_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_subset</span> (<span class="id">A</span> <span class="id"><a name="compact_precompact">B</a></span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">precompact</span> <span class="id">B</span> -&gt; <span class="id">precompact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof286')">Proof.</span></div>
<div class="proofscript" id="proof286">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">AsubB</span> [<span class="id">B</span>' <span class="id">B</span>'<span class="id">subB</span> <span class="id">cptB</span>']; <span class="kwd">exists</span> <span class="id">B</span>' =&gt; // ? ?; <span class="id">exact</span>/<span class="id">B</span>'<span class="id">subB</span>/<span class="id">AsubB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_precompact</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact_closed">set</a></span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">X</span> -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">precompact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof287')">Proof.</span></div>
<div class="proofscript" id="proof287">
<span class="id">move</span>=&gt; <span class="id">h</span> <span class="id">c</span>; <span class="id">rewrite</span> <span class="id">precompactE</span> ( <span class="id">_</span> : <span class="id">closure</span> <span class="id">A</span> = <span class="id">A</span>)//.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">apply</a></span>/<span class="id">esym</span>/<span class="id">closure_id</span>; <span class="id">exact</span>: <span class="id">compact_closed</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">precompact</span> <span class="id"><a href="mathcomp.analysis.topology.html#precompactE">A</a></span> = <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof288')">Proof.</span></div>
<div class="proofscript" id="proof288">
<span class="id">move</span>=&gt; <span class="id">clA</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [[<span class="id">B</span> <span class="id">AsubB</span> [ + <span class="id">_</span> ]]|].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subclosed_compact</span>; <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {1}(<span class="id">_</span> : <span class="id">A</span> = <span class="id">closure</span> <span class="id">A</span>) ?<span class="id">precompactE</span>// -<span class="id">closure_id</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">locally_compact</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) := [<span class="id">locally</span> <span class="id">precompact</span> <span class="id">A</span>].<br/>
<br/>
<span class="kwd">End</span> <span class="id">Precompact</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_spaces</span>.<br/>
<span class="kwd">Context</span> {<span class="id">I</span> : <span class="id">eqType</span>} {<span class="id">K</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">PK</span> := <span class="id">product_topologicalType</span> <span class="id">K</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">proj_continuous</span> <span class="id">i</span> : <span class="id">continuous</span> (<span class="id">proj</span> <span class="id">i</span> : <span class="id">PK</span> -&gt; <span class="id">K</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof289')">Proof.</span></div>
<div class="proofscript" id="proof289">
<span class="id">move</span>=&gt; <span class="id">f</span>; <span class="id">have</span> /<span class="id">cvg_sup</span>/(<span class="id">_</span> <span class="id">i</span>)/<span class="id">cvg_image</span> : <span class="id">f</span> --&gt; <span class="id">f</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_id</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">h</span>; <span class="id">apply</span>: <span class="id">cvg_trans</span> (<span class="id">h</span> <span class="id">_</span>) =&gt; {<span class="id">h</span>}.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html#dfwithin">move</a></span>=&gt; <span class="id">Q</span> /= [<span class="id">W</span> <span class="id">nbdW</span> &lt;-]; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">nbdW</span>; <span class="id">exact</span>: <span class="id">preimage_image</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_spaces.K">eqEsubset</a></span>; <span class="id">split</span> =&gt; <span class="id">y</span> //; <span class="kwd">exists</span> (<span class="id">dfwith</span> (<span class="kwd">fun</span>=&gt; <span class="id">point</span>) <span class="id">i</span> <span class="id">y</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">dfwithin</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dfwith_continuous</span> <span class="id">g</span> (<span class="id">i</span> : <span class="id">I</span>) : <span class="id">continuous</span> (<span class="id">dfwith</span> <span class="id">g</span> <span class="id">_</span> : <span class="id">K</span> <span class="id">i</span> -&gt; <span class="id">PK</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof290')">Proof.</span></div>
<div class="proofscript" id="proof290">
<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">U</span> [] <span class="id">P</span> [] [] <span class="id">Q</span> <span class="id">QfinP</span> &lt;- [] <span class="id">V</span> <span class="id">JV</span> <span class="id">Vpz</span>.<br/>
<span class="id">move</span>/(@<span class="id">preimage_subset</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">dfwith</span> <span class="id">g</span> <span class="id">i</span>))/<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ((<span class="id">dfwith</span> <span class="id">g</span> <span class="id">i</span>) @^-1` <span class="id">V</span>)); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="id">have</span> [<span class="id">L</span> <span class="id">Lsub</span> /[<span class="id">dup</span>] <span class="id">VL</span> &lt;-] := <span class="id">QfinP</span> <span class="id">_</span> <span class="id">JV</span>; <span class="id">rewrite</span> <span class="id">preimage_bigcap</span>.<br/>
<span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; /= <span class="id">M</span> /[<span class="id">dup</span>] <span class="id">LM</span> /<span class="id">Lsub</span> /<span class="id">set_mem</span> [] <span class="id">w</span> <span class="id">_</span> [+] + /[<span class="id">dup</span>] + &lt;-.<br/>
<span class="id">have</span> [-&gt;|<span class="id">wnx</span>] := <span class="id">eqVneq</span> <span class="id">w</span> <span class="id">i</span> =&gt; <span class="id">N</span> <span class="id">oN</span> <span class="id">NM</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#dfwithin">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">N</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id">dfwithin</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //; <span class="id">move</span>: <span class="id">Vpz</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">VL</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">LM</span>); <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#open">NM</a></span> /= <span class="id">dfwithin</span>.<br/>
<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">apply</a></span>: <span class="id">nearW</span> =&gt; <span class="id">y</span> /=; <span class="id">move</span>: <span class="id">Vpz</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">VL</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">LM</span>); <span class="id">rewrite</span> -<span class="id">NM</span> /= ? <span class="id">dfwithout</span> // <span class="id">eq_sym</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">proj_open</span> <span class="id">i</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">PK</span>) : <span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">proj</span> <span class="id">i</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof291')">Proof.</span></div>
<div class="proofscript" id="proof291">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">z</span> [<span class="id">f</span> <span class="id">Af</span> &lt;-]; <span class="id">rewrite</span> <span class="id">openE</span> <span class="kwd">in</span> <span class="id">oA</span>.<br/>
<span class="id">have</span> {<span class="id">oA</span>} := <span class="id">oA</span> <span class="id">_</span> <span class="id">Af</span>; <span class="id">rewrite</span> /<span class="id">interior</span> =&gt; <span class="id">nAf</span>.<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ((<span class="id">dfwith</span> <span class="id">f</span> <span class="id">i</span>) @^-1` <span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> <span class="id">Apw</span>; <span class="kwd">exists</span> (<span class="id">dfwith</span> <span class="id">f</span> <span class="id">i</span> <span class="id">w</span>) =&gt; //; <span class="id">rewrite</span> <span class="id">projK</span>.<br/>
<span class="id">apply</span>: <span class="id">dfwith_continuous</span> =&gt; /=; <span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">nAf</a></span>; <span class="id">congr</span> (<span class="id">nbhs</span> <span class="id">_</span> <span class="id">A</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">functional_extensionality_dep</span> =&gt; ?; <span class="id">case</span>: <span class="id">dfwithP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">hausdorff_product</span> :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">hausdorff_space</span> (<span class="id">K</span> <span class="id">x</span>)) -&gt; <span class="id">hausdorff_space</span> <span class="id">PK</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof292')">Proof.</span></div>
<div class="proofscript" id="proof292">
<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">move</a></span>=&gt; <span class="id">hsdfK</span> <span class="id">p</span> <span class="id">q</span> /= <span class="id">clstr</span>; <span class="id">apply</span>: <span class="id">functional_extensionality_dep</span> =&gt; <span class="id">x</span>.<br/>
<span class="id">apply</span>: <span class="id">hsdfK</span>; <span class="id">move</span>: <span class="id">clstr</span>; <span class="id">rewrite</span> ?<span class="id">cluster_cvgE</span> /= =&gt; -[<span class="id">G</span> <span class="id">PG</span> [<span class="id">GtoQ</span> <span class="id">psubG</span>]].<br/>
<span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">x</span> @ <span class="id">G</span>); [<span class="id">exact</span>: <span class="id">fmap_proper_filter</span>|<span class="id">split</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">last</span> <span class="id">exact</span>: (@<span class="id">proj_continuous</span> <span class="id"><a name="finI">x</a></span> <span class="id">q</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_app</span>; <span class="id">exact</span>: <span class="id">GtoQ</span>.<br/>
<span class="id">move</span>/(<span class="id"><a href="mathcomp.classical.classical_sets.html#set">cvg_app</a></span> (<span class="id">proj</span> <span class="id">x</span>)): <span class="id">psubG</span> =&gt; /<span class="id">cvg_trans</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">product_spaces</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="finI_filter">finI</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">D</span>' : {<span class="id">fset</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">I</a></span>}, {<span class="id">subset</span> <span class="id">D</span>' &lt;= <span class="id">D</span>} -&gt;<br/>
&nbsp;&nbsp;\<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">bigcap_</a></span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">i</span> | <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>']) <span class="id">f</span> <span class="id">i</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">finI_filter</span> (<span class="id">I</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">choiceType</a></span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">finI</span> <span class="id">D</span> <span class="id">f</span> -&gt; <span class="id">ProperFilter</span> (<span class="id">filter_from</span> (<span class="id">finI_from</span> <span class="id">D</span> <span class="id">f</span>) <span class="id">id</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof293')">Proof.</span></div>
<div class="proofscript" id="proof293">
<span class="id">move</span>=&gt; <span class="id">finIf</span>; <span class="id">apply</span>: (<span class="id">filter_from_proper</span> (<span class="id">filter_from_filter</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; //; <span class="id">rewrite</span> <span class="id">predeqE</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">DA</span> <span class="id">sDA</span> <span class="id">IfA</span>] [<span class="id">DB</span> <span class="id">sDB</span> <span class="id">IfB</span>]; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">DA</span> `|` <span class="id">DB</span>)%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; /<span class="id">orP</span> [/<span class="id">sDA</span>|/<span class="id">sDB</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">IfA</span> -<span class="id">IfB</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [<span class="id">Ifp</span>|[<span class="id">IfAp</span> <span class="id">IfBp</span>] <span class="id">i</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">apply</span>: <span class="id">Ifp</span>; <span class="id">rewrite</span> /= <span class="id">inE</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">Di</a></span> // <span class="id">orbC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">inE</span> =&gt; /<span class="id">orP</span> []; [<span class="id">apply</span>: <span class="id">IfAp</span>|<span class="id">apply</span>: <span class="id">IfBp</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [?? &lt;-]; <span class="id">apply</span>: <span class="id">finIf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_finI</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">D</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">set</span> <span class="id">T</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">D</span> <span class="id">A</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">A</span>)) -&gt; <span class="id">finI</span> <span class="id">D</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof294')">Proof.</span></div>
<div class="proofscript" id="proof294">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">sDFf</a></span> <span class="id">D</span>' <span class="id">sD</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id">_</span> <span class="id">F</span>); <span class="id">apply</span>: <span class="id">filter_bigI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">sD</span>; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; /<span class="id">sDFf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">finite_subset_cover</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U</span> (<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">U</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">U</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">D</span>' : {<span class="id">fset</span> <span class="id">I</span>}, {<span class="id">subset</span> <span class="id">D</span>' &lt;= <span class="id">D</span>} &amp; <span class="id">A</span> `&lt;=` <span class="id">cover</span> [<span class="id">set</span>` <span class="id">D</span>'] <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Covers</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cover_compact</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">I</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">choiceType</a></span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">open</span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id">A</span> `&lt;=` <span class="id">cover</span> <span class="id">D</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">open_fam_of</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">I</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">g</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_fam_of">g</a></span> <span class="id">i</span>)) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">f</span> <span class="id">i</span> = <span class="id">A</span> `&amp;` <span class="id">g</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cover_compactE</span> : <span class="id">cover_compact</span> =<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">cover</span> <span class="id">D</span> <span class="id">f</span> -&gt; <span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof295')">Proof.</span></div>
<div class="proofscript" id="proof295">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gop</span> <span class="id">feAg</span>] <span class="id">fcov</span>|<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> <span class="id">fop</span> <span class="id">fcov</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">gcov</span> : <span class="id">A</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">g</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> /<span class="id">fcov</span> [<span class="id">i</span> <span class="id">Di</span>]; <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - []; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">D</span>' <span class="id">sD</span> <span class="id">sgcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">gop</span> <span class="id">gcov</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">D</span>' =&gt; // <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">sgcov</span> [<span class="id">i</span> <span class="id">D</span>'<span class="id">i</span> <span class="id">gip</span>] := <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">rewrite</span> <span class="id">feAg</span> //; <span class="id">have</span> /<span class="id">sD</span> := <span class="id">D</span>'<span class="id">i</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
<span class="id">have</span> <span class="id">Afcov</span> : <span class="id">A</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `&amp;` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">fcov</span> [<span class="id">i</span> ??] := <span class="id">Ap</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">have</span> <span class="id">Afop</span> : <span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">A</span> `&amp;` <span class="id">f</span> <span class="id">i</span>) <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">have</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">D</a></span>' <span class="id">sD</span> <span class="id">sAfcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Afop</span> <span class="id">Afcov</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">D</span>' =&gt; // <span class="id">p</span> /<span class="id">sAfcov</span> [<span class="id">i</span> ? []]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">closed_fam_of</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id"><a href="mathcomp.analysis.topology.html#compact">I</a></span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">g</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">I</a></span> -&gt; <span class="id">set</span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id">g</span> <span class="id">i</span>)) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">f</span> <span class="id">i</span> = <span class="id">A</span> `&amp;` <span class="id">g</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_In0</span> :<br/>
&nbsp;&nbsp;<span class="id">compact</span> = [<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.boolp.html#pselect">closed_fam_of</a></span> <span class="id">A</span> <span class="id">D</span> <span class="id">f</span> -&gt; <span class="id">finI</span> <span class="id">D</span> <span class="id">f</span> -&gt; \<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span> !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof296')">Proof.</span></div>
<div class="proofscript" id="proof296">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id"><a href="mathcomp.classical.boolp.html#forallp_asboolPn">A</a></span>; <span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gcl</span> <span class="id">feAg</span>] <span class="id">finIf</span>|<span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FA</span>].<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#finI_filter">i</a></span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">i</span> <span class="id">Di</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span>; <span class="kwd">exists</span> <span class="id">point</span> =&gt; ? /<span class="id">D0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [|<span class="id">p</span> [<span class="id">Ap</span> <span class="id">clfinIfp</span>]] := <span class="id">Aco</span> <span class="id">_</span> (<span class="id">finI_filter</span> <span class="id">finIf</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">i</span>); [<span class="id">apply</span>: <span class="id">finI_from1</span>|<span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; ? []].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">p</span> =&gt; <span class="id">j</span> <span class="id">Dj</span>; <span class="id">rewrite</span> <span class="id">feAg</span> //; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">gcl</span> =&gt; // <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">clfinIfp</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">j</span>); [<span class="id">apply</span>: <span class="id">finI_from1</span>|<span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; ? []].<br/>
<span class="id">have</span> <span class="id">finIAclF</span> : <span class="id">finI</span> <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">B</span> =&gt; <span class="id">A</span> `&amp;` <span class="id">closure</span> <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id">filter_finI</span> <span class="id">_</span> <span class="id">F</span>) =&gt; <span class="id">B</span> <span class="id">FB</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FB</span>; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
<span class="id">have</span> [|<span class="id">p</span> <span class="id">AclFIp</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">finIAclF</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">closure</span>=&gt; //; <span class="id">move</span>=&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#compact">closed_closure</a></span>.<br/>
<span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; [|<span class="id">B</span> <span class="id">C</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_In0">FB</a></span> <span class="id">p_C</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">AclFIp</span> [] := <span class="id">FA</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">AclFIp</span> [<span class="id">_</span>] := <span class="id">FB</span>; <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">p_C</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cover</span> : <span class="id">compact</span> = <span class="id">cover_compact</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof297')">Proof.</span></div>
<div class="proofscript" id="proof297">
<span class="id">rewrite</span> <span class="id">compact_In0</span> <span class="id">cover_compactE</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gop</span> <span class="id">feAg</span>] <span class="id">fcov</span>|<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gcl</span> <span class="id">feAg</span>]].<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">j</span> <span class="id">Dj</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; // ? /<span class="id">fcov</span> [? /<span class="id">D0</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">exists2P</span>; <span class="id">apply</span>: <span class="id">contrapT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">sfncov</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> [<span class="id">p</span> <span class="id">IAnfp</span>] : \<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>) !=<span class="id">set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">IAnfp</span> [<span class="id">Ap</span> <span class="id">_</span>] := <span class="id">Dj</span>; <span class="id">have</span> /<span class="id">fcov</span> [<span class="id">k</span> /<span class="id">IAnfp</span> [<span class="id">_</span>]] := <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">Aco</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; ~` <span class="id">g</span> <span class="id">i</span>) =&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">open_closedC</span>/<span class="id">gop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [[<span class="id">Ap</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#cover">nfip</a></span>] | [<span class="id">Ap</span> <span class="id">ngip</span>]]; <span class="id">split</span>=&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">gip</span>; <span class="id">apply</span>: <span class="id">nfip</span>; <span class="id">rewrite</span> <span class="id">feAg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">D</span>' <span class="id">sD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">asboolP</span> : ~ <span class="id">A</span> `&lt;=` <span class="id">cover</span> [<span class="id">set</span>` <span class="id">D</span>'] <span class="id">f</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAIf</span>; <span class="id">exact</span>: (<span class="id">sfncov</span> <span class="id">D</span>').<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">existsp_asboolPn</span> [<span class="id">p</span> /<span class="id">asboolP</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">imply_asboolPn</span> [<span class="id">Ap</span> <span class="id">nUfp</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span> =&gt; <span class="id">i</span> <span class="id">D</span>'<span class="id">i</span>; <span class="id">split</span>=&gt; // <span class="id">fip</span>; <span class="id">apply</span>: <span class="id">nUfp</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.boolp.html#contraPP">i</a></span>.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">j</span> <span class="id">Dj</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span> =&gt; <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">point</span> =&gt; ? /<span class="id">D0</span>.<br/>
<span class="id">apply</span>: <span class="id">contraPP</span> =&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">If0</span>.<br/>
<span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span>; <span class="id">apply</span>/<span class="id">existsp_asboolPn</span>.<br/>
<span class="id">have</span> <span class="id">Anfcov</span> : <span class="id">A</span> `&lt;=` \<span class="id"><a href="mathcomp.classical.boolp.html#imply_asboolPn">bigcup_</a></span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">If0</span> <span class="id">p</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">existsp_asboolPn</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">i</span> /<span class="id">asboolP</span>]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed_openC">asbool_neg</a></span> =&gt; /<span class="id">imply_asboolPn</span> [<span class="id">Di</span> <span class="id">nfip</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">have</span> <span class="id">Anfop</span> : <span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; ~` <span class="id">g</span> <span class="id">i</span>) =&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">gcl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [[<span class="id">Ap</span> <span class="id">nfip</span>] | [<span class="id">Ap</span> <span class="id">ngip</span>]]; <span class="id">split</span>=&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">gip</span>; <span class="id">apply</span>: <span class="id">nfip</span>; <span class="id">rewrite</span> <span class="id">feAg</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - [].<br/>
<span class="id">have</span> [<span class="id">D</span>' <span class="id">sD</span> <span class="id">sAnfcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Anfop</span> <span class="id">Anfcov</span>.<br/>
<span class="id">wlog</span> [<span class="id">k</span> <span class="id">D</span>'<span class="id">k</span>] : <span class="id">D</span>' <span class="id">sD</span> <span class="id">sAnfcov</span> / <span class="kwd">exists</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>'.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> (<span class="id">D</span>' `|` [<span class="id">fset</span> <span class="id">j</span>])%<span class="id">fset</span>); <span class="id">apply</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">k</a></span>; <span class="id">rewrite</span> !<span class="id">inE</span> =&gt; /<span class="id">orP</span> [/<span class="id">sD</span>|/<span class="id">eqP</span>-&gt;] //; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> /<span class="id">sAnfcov</span> [<span class="id">i</span> <span class="id">D</span>'<span class="id">i</span> <span class="id">Anfip</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //=; <span class="id">rewrite</span> !<span class="id">inE</span> <span class="id">D</span>'<span class="id">i</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">j</span>; <span class="id">rewrite</span> !<span class="id">inE</span> <span class="id">orbC</span> <span class="id">eq_refl</span>.<br/>
<span class="kwd">exists</span> <span class="id">D</span>' =&gt; /(<span class="id">_</span> <span class="id">sD</span>) [<span class="id">p</span> <span class="id">Ifp</span>].<br/>
<span class="id">have</span> /<span class="id">Ifp</span> := <span class="id">D</span>'<span class="id">k</span>; <span class="id">rewrite</span> <span class="id">feAg</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">sD</span> := <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">D</a></span>'<span class="id">k</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [/<span class="id">sAnfcov</span> [<span class="id"><a href="mathcomp.classical.cardinality.html#finite_setP">i</a></span> <span class="id">D</span>'<span class="id">i</span> [<span class="id">_</span> <span class="id">nfip</span>]] <span class="id">_</span>]; <span class="id">have</span> /<span class="id">Ifp</span> := <span class="id">D</span>'<span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Covers</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">finite_compact</span> {<span class="id">X</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof298')">Proof.</span></div>
<div class="proofscript" id="proof298">
<span class="id">case</span>/<span class="id">finite_setP</span>=&gt; <span class="id">n</span>; <span class="id">elim</span>: <span class="id">n</span> <span class="id">A</span> =&gt; [<span class="id">A</span>|<span class="id">n</span> <span class="id">ih</span> <span class="id">A</span> /<span class="id">eq_cardSP</span>[<span class="id">x</span> <span class="id">Ax</span> /<span class="id">ih</span> ?]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">II0</span> <span class="id">card_eq0</span> =&gt; /<span class="id">eqP</span> -&gt;; <span class="id">exact</span>: <span class="id">compact0</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">setD1K</span> <span class="id">Ax</span>); <span class="id">apply</span>: <span class="id">compactU</span> =&gt; //; <span class="id">exact</span>: <span class="id">compact_set1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_countable</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}:<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; @<span class="id">second_countable</span> <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">countable</a></span> (@<span class="id">clopen</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof299')">Proof.</span></div>
<div class="proofscript" id="proof299">
<span class="id">move</span>=&gt; <span class="id">cmpT</span> [<span class="id">B</span> /<span class="id">fset_subset_countable</span> <span class="id">cntB</span>] [<span class="id">obase</span> <span class="id"><a href="mathcomp.analysis.topology.html#cover_compact">Bbase</a></span>].<br/>
<span class="id">apply</span>/(<span class="id">card_le_trans</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_cover">cntB</a></span>)/<span class="id">pcard_surjP</span>.<br/>
<span class="id">pose</span> <span class="id">f</span> := <span class="kwd">fun</span> <span class="id">F</span> : {<span class="id">fset</span> <span class="id">set</span> <span class="id">T</span>} =&gt; \<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">D</span> [] <span class="id">oD</span> <span class="id">cD</span> /=; <span class="id">have</span> <span class="id">cmpt</span> : <span class="id">cover_compact</span> <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">compact_cover</span>; <span class="id">exact</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cmpT</span>).<br/>
<span class="id">have</span> <span class="id">h</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="kwd">exists</span> <span class="id">V</span> : <span class="id">set</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">T</a></span>, <span class="id">D</span> <span class="id">x</span> -&gt; [/\ <span class="id">B</span> <span class="id">V</span>, <span class="id">nbhs</span> <span class="id">x</span> <span class="id">V</span> &amp; <span class="id">V</span> `&lt;=` <span class="id">D</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">Dx</span>|] := <span class="id">pselect</span> (<span class="id">D</span> <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">V</span> [<span class="id">BV</span> <span class="id">Vx</span> <span class="id">VD</span>]] := <span class="id">Bbase</span> <span class="id">x</span> <span class="id">D</span> (<span class="id">open_nbhs_nbhs</span> (<span class="id">conj</span> <span class="id">oD</span> <span class="id">Dx</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span> =&gt; <span class="id">_</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">obase</span>.<br/>
<span class="id">pose</span> <span class="id">h</span>' := <span class="kwd">fun</span> <span class="id">z</span> =&gt; <span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)).<br/>
<span class="id">have</span> [<span class="id">fs</span> <span class="id">fsD</span> <span class="id">DsubC</span>] : <span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">h</span>' <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">apply</a></span>: <span class="id">cmpt</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">Dz</span>; <span class="id">apply</span>: <span class="id">obase</span>; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">Dz</span>; <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">apply</span>: <span class="id">nbhs_singleton</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
<span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">h</span>' <span class="id">z</span> | <span class="id">z</span> <span class="kwd">in</span> <span class="id">fs</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">U</span>/<span class="id">imfsetP</span> [<span class="id">z</span> /=] /<span class="id">fsD</span> /<span class="id">set_mem</span> <span class="id">Dz</span> -&gt;; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">rewrite</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#cid">inE</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">y</span> /<span class="id">imfsetP</span> [<span class="id">x</span> /= /<span class="id">fsD</span>/<span class="id">set_mem</span> <span class="id">Dx</span> -&gt;]; <span class="id">move</span>: <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">h</a></span> <span class="id">x</span>)) <span class="id">Dx</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">DsubC</span> /= [<span class="id">y</span> /= <span class="id">yfs</span> <span class="id">hyz</span>]; <span class="kwd">exists</span> (<span class="id">h</span>' <span class="id">y</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_imfset</span> /=; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">separated_topologicalType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">topologicalType</span>).<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">x</span> <span class="id">y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">T</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kolmogorov_space</span> := <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, (<span class="id">A</span> \<span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">x</span> /\ <span class="id">y</span> \<span class="kwd">in</span> ~` <span class="id">A</span>) \/ (<span class="id">A</span> \<span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">y</span> /\ <span class="id">x</span> \<span class="kwd">in</span> ~` <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">accessible_space</span> := <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setCK">open</a></span> <span class="id">A</span> /\ <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> /\ <span class="id">y</span> \<span class="kwd">in</span> ~` <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_closed_set1</span> : <span class="id">accessible_space</span> -&gt; <span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">x</a></span>, <span class="id">closed</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof300')">Proof.</span></div>
<div class="proofscript" id="proof300">
<span class="id">move</span>=&gt; <span class="id">T1</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetC1">x</a></span>; <span class="id">rewrite</span> -[<span class="id">X</span> <span class="kwd">in</span> <span class="id">closed</span> <span class="id">X</span>]<span class="id">setCK</span>; <span class="id">apply</span>: <span class="id">open_closedC</span>.<br/>
<span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">y</span> /<span class="id">eqP</span> /<span class="id">T1</span> [<span class="id">U</span> [<span class="id">oU</span> [<span class="id">yU</span> <span class="id">xU</span>]]].<br/>
<span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">nbhsE</span> /=; <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">subsetC1</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">set_mem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_kolmogorov</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">accessible_space</a></span> -&gt; <span class="id">kolmogorov_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof301')">Proof.</span></div>
<div class="proofscript" id="proof301">
<span class="id">move</span>=&gt; <span class="id">T1</span> <span class="id">x</span> <span class="id">y</span> /<span class="id">T1</span> [<span class="id">A</span> [<span class="id">oA</span> [<span class="id">xA</span> <span class="id">yA</span>]]]; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span>; <span class="id">left</span>; <span class="id">split</span>=&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhsE</span> <span class="id">inE</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">rewrite</span> <span class="id">inE</span> <span class="kwd">in</span> <span class="id">xA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_finite_set_closed</span> :<br/>
&nbsp;&nbsp;<span class="id">accessible_space</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id"><a href="mathcomp.analysis.topology.html#accessible_closed_set1">finite_set</a></span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof302')">Proof.</span></div>
<div class="proofscript" id="proof302">
<span class="id">split</span> =&gt; [<span class="id">TT1</span> <span class="id">A</span> <span class="id">fA</span>|<span class="id">h</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -(<span class="id">fsbig_setU_set1</span> <span class="id">fA</span>) <span class="id">fsbig_finite</span>//=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_bigsetU</span> =&gt; <span class="id">x</span> <span class="id">xA</span>; <span class="id">exact</span>: <span class="id">accessible_closed_set1</span>.<br/>
<span class="kwd">exists</span> (~` [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">y</a></span>]); <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openC</span>; <span class="id">exact</span>: <span class="id">h</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">inE</span>/=; <span class="id">split</span>=&gt; [|/<span class="id">eqP</span>]; [<span class="id">exact</span>/<span class="id">eqP</span>|<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#cluster">eqxx</a></span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> : <span class="kwd">Prop</span> := <span class="kwd">forall</span> <span class="id">M</span>, <span class="id">open_nbhs</span> <span class="id">y</span> <span class="id">M</span> -&gt; <span class="id">closure</span> <span class="id">M</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeEnbhs</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> = <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof303')">Proof.</span></div>
<div class="proofscript" id="proof303">
<span class="id">transitivity</span> (<span class="id">cluster</span> (<span class="id">open_nbhs</span> <span class="id">x</span>)); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">cluster</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">meets_openl</span>.<br/>
<span class="id">rewrite</span> <span class="id">clusterEonbhs</span> /<span class="id">close</span> <span class="id">funeqE</span> =&gt; <span class="id">y</span> /=; <span class="id">rewrite</span> <span class="id">meetsC</span> /<span class="id">meets</span>.<br/>
<span class="id">apply</span>/<span class="id">eq_forall</span> =&gt; <span class="id">A</span>; <span class="id">rewrite</span> <span class="id">forall_swap</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEonbhs</span>/= <span class="id">meets_globallyl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeEonbhs</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> = [<span class="id">set</span> <span class="id">y</span> | <span class="id">open_nbhs</span> <span class="id">x</span> `#` <span class="id">open_nbhs</span> <span class="id">y</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof304')">Proof.</span></div>
<div class="proofscript" id="proof304">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">meets_openl</span> -<span class="id">meets_openr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_sym</span> <span class="id"><a href="mathcomp.analysis.topology.html#close">x</a></span> <span class="id">y</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">y</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof305')">Proof.</span></div>
<div class="proofscript" id="proof305">
 <span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">closeEnbhs</span> /<span class="id">cluster</span>/= <span class="id">meetsC</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_close</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} <span class="id">x</span> <span class="id">y</span> : <span class="id">F</span> --&gt; <span class="id">x</span> -&gt; <span class="id">F</span> --&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg_close">y</a></span> -&gt; <span class="id">close</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">x</a></span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof306')">Proof.</span></div>
<div class="proofscript" id="proof306">
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">sub_meets</span> <span class="id">sx</span> /<span class="id">sx</span>; <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">proper_meetsxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_refl</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof307')">Proof.</span></div>
<div class="proofscript" id="proof307">
 <span class="id">exact</span>: (@<span class="id">cvg_close</span> (<span class="id">nbhs</span> <span class="id">x</span>)). Qed.</div>
<span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">close_refl</span> : <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">core</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_cvg</span> (<span class="id">F1</span> <span class="id">F2</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) {<span class="id">FF2</span> : <span class="id">ProperFilter</span> <span class="id">F2</span>} :<br/>
&nbsp;&nbsp;<span class="id">F1</span> --&gt; <span class="id">F2</span> -&gt; <span class="id">F2</span> --&gt; <span class="id">F1</span> -&gt; <span class="id">close</span> (<span class="id">lim</span> <span class="id">F1</span>) (<span class="id">lim</span> <span class="id">F2</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof308')">Proof.</span></div>
<div class="proofscript" id="proof308">
<span class="id">move</span>=&gt; <span class="id">F12</span> <span class="id">F21</span>.<br/>
<span class="id">have</span> [/(<span class="id">cvg_trans</span> <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">F21</a></span>) <span class="id">F2l</span>|<span class="id">dvgF1</span>] := <span class="id">pselect</span> (<span class="id">cvg</span> <span class="id">F1</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">cvg_close</span> <span class="id">F2</span>) =&gt; //; <span class="id">apply</span>: <span class="id">cvgP</span> <span class="id">F2l</span>.<br/>
<span class="id">have</span> [/(<span class="id">cvg_trans</span> <span class="id">F12</span>)/<span class="id">cvgP</span>//|<span class="id">dvgF2</span>] := <span class="id">pselect</span> (<span class="id">cvg</span> <span class="id">F2</span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">rewrite</a></span> <span class="id">dvgP</span> // <span class="id">dvgP</span> //; <span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">close_refl</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgx_close</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">x</span> --&gt; <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof309')">Proof.</span></div>
<div class="proofscript" id="proof309">
 <span class="id">exact</span>: <span class="id">cvg_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_close</span> <span class="id">T</span>' {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span>' -&gt; <span class="id">set</span> <span class="id">T</span>) (<span class="id">l</span> <span class="id">l</span>' : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">is_fun</span> <span class="id">f</span>} -&gt; <span class="id">f</span> `@ <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">F</a></span> --&gt; <span class="id">l</span> -&gt; <span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">l</span>' -&gt; <span class="id">close</span> <span class="id">l</span> <span class="id">l</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof310')">Proof.</span></div>
<div class="proofscript" id="proof310">
<span class="id">move</span>=&gt; <span class="id">f_prop</span> <span class="id">fFl</span> <span class="id">fFl</span>'.<br/>
<span class="id">suff</span> <span class="id">f_totalfun</span>: <span class="id">infer</span> {<span class="id">near</span> <span class="id">F</span>, <span class="id">is_totalfun</span> <span class="id">f</span>} <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">cvg_close</span> <span class="id">fFl</span> <span class="id">fFl</span>'.<br/>
<span class="id">apply</span>: <span class="id">filter_app</span> <span class="id">f_prop</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">split</span>=&gt; //=.<br/>
<span class="id">have</span>: (<span class="id">f</span> `@ <span class="id">F</span>) <span class="id">setT</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvgi_close">apply</a></span>: <span class="id">fFl</span>; <span class="id">apply</span>: <span class="id"><a name="open_hausdorff">filterT</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fmapiE</span>; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">x</span> [<span class="id">y</span> []]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Definition</span> <span class="id">cvg_toi_locally_close</span> := @<span class="id">cvgi_close</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">T</a></span> =<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">AB</span>, (<span class="id">x</span> \<span class="kwd">in</span> <span class="id">AB</span>.1 /\ <span class="id">y</span> \<span class="kwd">in</span> <span class="id">AB</span>.2) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id">open</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#rwP">AB</a></span>.1, <span class="id">open</span> <span class="id">AB</span>.2 &amp; <span class="id">AB</span>.1 `&amp;` <span class="id">AB</span>.2 == <span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof311')">Proof.</span></div>
<div class="proofscript" id="proof311">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [<span class="id">T_filterT2</span>|<span class="id">T_openT2</span>] <span class="id">x</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> := @<span class="id">contra_not</span> <span class="id"><a href="mathcomp.classical.boolp.html#existsp_asboolPn">_</a></span> <span class="id">_</span> (<span class="id">T_filterT2</span> <span class="id">x</span> <span class="id">y</span>); <span class="id">rewrite</span> (<span class="id">rwP</span> <span class="id">eqP</span>) (<span class="id">rwP</span> <span class="id">negP</span>).  <span class="comment">(*&nbsp;change&nbsp;@contra_not&nbsp;_&nbsp;_&nbsp;to&nbsp;contra_not&nbsp;when&nbsp;requiring&nbsp;MathComp&nbsp;&gt;&nbsp;1.14&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">apply</span>] /<span class="id">asboolPn</span>/<span class="id">existsp_asboolPn</span>[<span class="id">A</span>]; <span class="id">rewrite</span> -<span class="id">existsNE</span> =&gt; -[<span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">nbhs</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">_</a></span> <span class="id">_</span> -&gt; <span class="id">_</span>](<span class="id">rwP</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negbK">imply_asboolP</a></span>) =&gt; /<span class="id">negP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_imply</span> !<span class="id">negb_imply</span> =&gt; /<span class="id">andP</span>[/<span class="id">asboolP</span> <span class="id">xA</span>] /<span class="id">andP</span>[/<span class="id">asboolP</span> <span class="id">yB</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">asboolPn</span>; <span class="id">rewrite</span> -<span class="id">set0P</span> =&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> <span class="id">negbK</span> =&gt; /<span class="id">eqP</span> <span class="id">AIB_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">xA</span> <span class="id">yB</span>; <span class="id">rewrite</span> !<span class="id">nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; - [<span class="id">oA</span> [<span class="id">oA_open</span> <span class="id">oAx</span>] <span class="id">oAA</span>] [<span class="id">oB</span> [<span class="id">oB_open</span> <span class="id">oBx</span>] <span class="id">oBB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">oA</span>, <span class="id">oB</span>); <span class="id">rewrite</span> ?<span class="id">inE</span>; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">split</a></span> =&gt; //; <span class="id">apply</span>: <span class="id">subsetI_eq0</span> <span class="id">AIB_eq0</span>.<br/>
<span class="id">apply</span>: <span class="id">contraPP</span> =&gt; /<span class="id">eqP</span> /<span class="id">T_openT2</span>[[/=<span class="id">A</span> <span class="id">B</span>]].<br/>
<span class="id">rewrite</span> !<span class="id">inE</span> =&gt; - [<span class="id">xA</span> <span class="id">yB</span>] [<span class="id">Aopen</span> <span class="id">Bopen</span> /<span class="id">eqP</span> <span class="id">AIB_eq0</span>].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">A</span> <span class="id">B</span> (<span class="id">open_nbhs_nbhs</span> <span class="id">_</span>) (<span class="id">open_nbhs_nbhs</span> <span class="id">_</span>)).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">set0P</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)/<span class="id">negP</span>; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">hausdorff_accessible</span> : <span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">accessible_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof312')">Proof.</span></div>
<div class="proofscript" id="proof312">
<span class="id">rewrite</span> <span class="id">open_hausdorff</span> =&gt; <span class="id">hsdfT</span> =&gt; <span class="id">x</span> <span class="id">y</span> /<span class="id">hsdfT</span> [[<span class="id">U</span> <span class="id">V</span>] [<span class="id">xU</span> <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">yV</a></span>]] [/= ? ? /<span class="id">eqP</span>].<br/>
<span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /<span class="id">disjoints_subset</span> <span class="id">VUc</span>; <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inE</span>; <span class="id">apply</span>: <span class="id">VUc</span>; <span class="id">rewrite</span> -<span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">sep</span> : <span class="id">hausdorff_space</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeE</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = (<span class="id">x</span> = <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof313')">Proof.</span></div>
<div class="proofscript" id="proof313">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">exact</span>: <span class="id">close_refl</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">exact</span>: <span class="id">sep</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_eq</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">close</span> <span class="id"><a href="mathcomp.analysis.topology.html#closeE">x</a></span> <span class="id">y</span> -&gt; <span class="id">x</span> = <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof314')">Proof.</span></div>
<div class="proofscript" id="proof314">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeE</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_unique</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} : <span class="id">is_subset1</span> [<span class="id">set</span> <span class="id">x</span> : <span class="id">T</span> | <span class="id">F</span> --&gt; <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof315')">Proof.</span></div>
<div class="proofscript" id="proof315">
 <span class="id">move</span>=&gt; <span class="id">Fx</span> <span class="id">Fy</span>; <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id">exact</span>: (@<span class="id">cvg_close</span> <span class="id">F</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_eq</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">x</span> --&gt; <span class="id">y</span> -&gt; <span class="id">x</span> = <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof316')">Proof.</span></div>
<div class="proofscript" id="proof316">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id">apply</span>: <span class="id">cvg_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_id</span> <span class="id">x</span> : <span class="id">lim</span> <span class="id">x</span> = <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof317')">Proof.</span></div>
<div class="proofscript" id="proof317">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>/<span class="id">cvg_eq</span>/<span class="id">cvg_ex</span>; <span class="kwd">exists</span> <span class="id">x</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_lim</span> {<span class="id">U</span> : <span class="kwd">Type</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">lim</span> (<span class="id">f</span> @ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof318')">Proof.</span></div>
<div class="proofscript" id="proof318">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /[<span class="id">dup</span>] /<span class="id">cvgP</span> /<span class="id">cvg_unique</span>; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_near_cst</span> {<span class="id"><a name="lim_cst">U</a></span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">l</span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id">lim</span> (<span class="id">f</span> @ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof319')">Proof.</span></div>
<div class="proofscript" id="proof319">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">cvg_near_cst</span>/<span class="id">cvg_lim</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_cst</span> {<span class="id">U</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">k</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">lim</span> ((<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">U</span> =&gt; <span class="id">k</span>) @ <span class="id">F</span>) = <span class="id">k</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof320')">Proof.</span></div>
<div class="proofscript" id="proof320">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">apply</a></span>: <span class="id">cvg_lim</span>; <span class="id">apply</span>: <span class="id">cvg_cst</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_unique</span> {<span class="id"><a href="mathcomp.analysis.topology.html#closeE">U</a></span> : <span class="kwd">Type</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">is_fun</span> <span class="id">f</span>} -&gt; <span class="id">is_subset1</span> [<span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">set</a></span> <span class="id">x</span> : <span class="id">T</span> | <span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof321')">Proof.</span></div>
<div class="proofscript" id="proof321">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">ffun</span> <span class="id">fx</span> <span class="id">fy</span>; <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id">exact</span>: <span class="id">cvgi_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_lim</span> {<span class="id">U</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="kwd">fun</span> <span class="id">x</span> : <span class="id">U</span> =&gt; <span class="id">is_subset1</span> (<span class="id">f</span> <span class="id">x</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">lim</span> (<span class="id">f</span> `@ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof322')">Proof.</span></div>
<div class="proofscript" id="proof322">
<span class="id">move</span>=&gt; <span class="id">f_prop</span> <span class="id">fl</span>; <span class="id">apply</span>: <span class="id">get_unique</span> =&gt; // <span class="id">l</span>' <span class="id">fl</span>'; <span class="id">exact</span>: <span class="id">cvgi_unique</span> <span class="id">_</span> <span class="id">fl</span>' <span class="id">fl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">separated_topologicalType</span>.<br/>
<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> <span class="id">to</span> `<span class="id">cvg_lim</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvg_map_lim</span> := <span class="id">cvg_lim</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> <span class="id">to</span> `<span class="id">cvgi_lim</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvgi_map_lim</span> := <span class="id">cvgi_lim</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">connected_sets</span>.<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">A</span> <span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected_sets.T">C</a></span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">connected</span> <span class="id">A</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">B</span>, <span class="id">B</span> !=<span class="id">set0</span> -&gt; (<span class="kwd">exists2</span> <span class="id">C</span>, <span class="id">open</span> <span class="id">C</span> &amp; <span class="id">B</span> = <span class="id">A</span> `&amp;` <span class="id">C</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">exists2</span> <span class="id">C</span>, <span class="id">closed</span> <span class="id">C</span> &amp; <span class="id">B</span> = <span class="id">A</span> `&amp;` <span class="id">C</span>) -&gt; <span class="id">B</span> = <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected0</span> : <span class="id">connected</span> (@<span class="id">set0</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof323')">Proof.</span></div>
<div class="proofscript" id="proof323">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? [? ?]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">set0I</a></span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> :=<br/>
&nbsp;&nbsp;(<span class="id">closure</span> <span class="id">A</span>) `&amp;` <span class="id">B</span> = <span class="id">set0</span> /\ <span class="id">A</span> `&amp;` (<span class="id">closure</span> <span class="id">B</span>) = <span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">separatedC</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">A</a></span> <span class="id">B</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> = <span class="id">separated</span> <span class="id">B</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof324')">Proof.</span></div>
<div class="proofscript" id="proof324">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">separated</span> <span class="id">andC</span> <span class="id">setIC</span> (<span class="id">setIC</span> <span class="id">_</span> <span class="id">B</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">separated_disjoint</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof325')">Proof.</span></div>
<div class="proofscript" id="proof325">
<span class="id">move</span>=&gt; <span class="id">AB</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; // -[<span class="id">Ax</span> <span class="id">Bx</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[&lt;- <span class="id">_</span>]; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedPn</span> <span class="id">A</span> : ~ <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span> : <span class="id">bool</span> -&gt; <span class="id">set</span> <span class="id">T</span>, [/\ <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">E</span> <span class="id">b</span> !=<span class="id">set0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> = <span class="id">E</span> <span class="id">false</span> `|` <span class="id">E</span> <span class="id">true</span> &amp; <span class="id">separated</span> (<span class="id">E</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setD">false</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#closure">E</a></span> <span class="id">true</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof326')">Proof.</span></div>
<div class="proofscript" id="proof326">
<span class="id">rewrite</span> -<span class="id">propeqE</span>; <span class="id">apply</span>: <span class="id">notLR</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">conE</span> [<span class="id">E</span> [<span class="id">E0</span> <span class="id">EU</span> [<span class="id">E1</span> <span class="id">E2</span>]]]|<span class="id">conE</span> <span class="id">B</span> <span class="id">B0</span> [<span class="id">C</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setU0">oC</a></span> <span class="id">BAC</span>] [<span class="id">D</span> <span class="id">cD</span> <span class="id">BAD</span>]].<br/>
&nbsp;&nbsp;<span class="id">suff</span> : <span class="id">E</span> <span class="id">true</span> = <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>/<span class="id">esym</span>/(<span class="id">congr1</span> (<span class="id">setD</span>^~ (<span class="id">closure</span> (<span class="id">E</span> <span class="id">true</span>)))); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">EU</a></span> <span class="id">setDUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">E</span> <span class="id">true</span>); <span class="id">rewrite</span> -<span class="id">setD_eq0</span> =&gt; -&gt;; <span class="id">rewrite</span> <span class="id">setU0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">setDidPl</span> : <span class="id">E2</span> =&gt; -&gt;; <span class="id">exact</span>/<span class="id">eqP</span>/<span class="id">set0P</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">conE</span> <span class="id">_</span> (<span class="id">E0</span> <span class="id">true</span>)).<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> (~` (<span class="id">closure</span> (<span class="id">E</span> <span class="id">false</span>))); <span class="id">first</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setIUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /<span class="id">subsets_disjoint</span> -&gt; := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#esym">E</a></span> <span class="id">false</span>); <span class="id">rewrite</span> <span class="id">set0U</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id">setIC</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">E</span> <span class="id">true</span>)); <span class="id">first</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setIUl</span> <span class="id">E2</span> <span class="id">set0U</span>; <span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">subset_closure</span>.<br/>
<span class="id"><a href="mathcomp.classical.classical_sets.html#setCK">apply</a></span>: <span class="id">contrapT</span> =&gt; <span class="id">AF</span>; <span class="id">apply</span>: <span class="id">conE</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIidPl">i</a></span> =&gt; <span class="kwd">if</span> <span class="id">i</span> <span class="id">is</span> <span class="id">false</span> <span class="kwd">then</span> <span class="id">A</span> `\` <span class="id"><a href="mathcomp.classical.classical_sets.html#setIUr">C</a></span> <span class="kwd">else</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setUCl">A</a></span> `&amp;` <span class="id">C</span>); <span class="id">split</span>.<br/>
- <span class="id">case</span>=&gt; /=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#disjoints_subset">BAC</a></span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">set0P</span>/<span class="id">eqP</span> =&gt; /<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id">setCK</span> =&gt; <span class="id">EC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setDE">BAC</a></span>; <span class="id">exact</span>/<span class="id">setIidPl</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setDE</span> -<span class="id">setIUr</span> <span class="id">setUCl</span> <span class="id">setIT</span>.<br/>
- <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">setIC</span>; <span class="id">apply</span>/<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id">closureC</span> =&gt; <span class="id">x</span> [? ?].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span> =&gt; //; <span class="id">split</span>=&gt; //; <span class="id">rewrite</span> <span class="id">setDE</span> <span class="id">setCI</span> <span class="id">setCK</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>/<span class="id">disjoints_subset</span> =&gt; <span class="id">y</span> -[<span class="id">Ay</span> <span class="id">Cy</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">BAC</span> <span class="id">BAD</span> =&gt; /<span class="id">closureI</span>[<span class="id">_</span>]; <span class="id">move</span>/<span class="id">closure_id</span> : <span class="id">cD</span> =&gt; &lt;- <span class="id">Dy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> : <span class="id">B</span> <span class="id">y</span>; [<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">BAD</span>; <span class="id">split</span>|<span class="id">rewrite</span> <span class="id">BAC</span> =&gt; -[]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedP</span> <span class="id">A</span> : <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">E</span> : <span class="id">bool</span> -&gt; <span class="id">set</span> <span class="id">T</span>, ~ [/\ <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">E</span> <span class="id">b</span> !=<span class="id">set0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> = <span class="id"><a href="mathcomp.analysis.topology.html#separated">E</a></span> <span class="id">false</span> `|` <span class="id">E</span> <span class="id">true</span> &amp; <span class="id">separated</span> (<span class="id">E</span> <span class="id">false</span>) (<span class="id">E</span> <span class="id">true</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof327')">Proof.</span></div>
<div class="proofscript" id="proof327">
<span class="id">rewrite</span> -<span class="id">propeqE</span> <span class="id">forallNE</span>; <span class="id">apply</span>: <span class="id">notRL</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">exact</span>: <span class="id">connectedPn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_subset</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> -&gt; <span class="id">C</span> `&lt;=` <span class="id">A</span> `|` <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">C</span> -&gt; <span class="id">C</span> `&lt;=` <span class="id">A</span> \/ <span class="id">C</span> `&lt;=` <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof328')">Proof.</span></div>
<div class="proofscript" id="proof328">
<span class="id">move</span>=&gt; <span class="id">AB</span> <span class="id">CAB</span>; <span class="id">have</span> -&gt; : <span class="id">C</span> = (<span class="id">C</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">C</span> `&amp;` <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span>=&gt; [<span class="id">Cx</span>|[] [] //].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Ax</span>|<span class="id">Bx</span>] := <span class="id">CAB</span> <span class="id">_</span> <span class="id">Cx</span>; [<span class="id">left</span>|<span class="id"><a href="mathcomp.classical.classical_sets.html#set0U">right</a></span>].<br/>
<span class="id">move</span>/<span class="id">connectedP</span>/(<span class="id">_</span> (<span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">C</span> `&amp;` <span class="id">B</span> <span class="kwd">else</span> <span class="id">C</span> `&amp;` <span class="id">A</span>)) =&gt; /<span class="id">not_and3P</span>[]//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">existsNP</span> =&gt; [<span class="id">b</span> /<span class="id">set0P</span>/<span class="id">negP</span>/<span class="id">negPn</span>]; <span class="id">case</span>: <span class="id">b</span> =&gt; /<span class="id">eqP</span> -&gt;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !(<span class="id">setU0</span>,<span class="id">set0U</span>); [<span class="id">left</span>|<span class="id">right</span>]; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>.<br/>
<span class="id">case</span>/<span class="id">not_andP</span> =&gt; /<span class="id">eqP</span>/<span class="id">set0P</span>[<span class="id">x</span> []].<br/>
- <span class="id">move</span>=&gt; /<span class="id">closureI</span>[<span class="id">cCx</span> <span class="id">cAx</span>] [<span class="id">Cx</span> <span class="id">Bx</span>]; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[] + <span class="id"><a href="mathcomp.analysis.topology.html#connected">_</a></span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
- <span class="id">move</span>=&gt; [<span class="id">Cx</span> <span class="id">Ax</span>] /<span class="id">closureI</span>[<span class="id">cCx</span> <span class="id">cBx</span>]; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[] <span class="id">_</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected1</span> <span class="id">x</span> : <span class="id">connected</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof329')">Proof.</span></div>
<div class="proofscript" id="proof329">
<span class="id">move</span>=&gt; <span class="id">X</span> [<span class="id">y</span> +] [<span class="id">O</span> <span class="id">Oopen</span> <span class="id">XO</span>] [<span class="id">C</span> <span class="id">Cclosed</span> <span class="id">XC</span>]; <span class="id">rewrite</span> <span class="id">XO</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [{<span class="id">y</span>}-&gt; <span class="id">Ox</span>]; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span>=&gt; <span class="id">y</span> =&gt; [[-&gt;//]|-&gt;].<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">connected1</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bigcup_connected</span> <span class="id">I</span> (<span class="id">A</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) (<span class="id">P</span> : <span class="id">I</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) (<span class="id">A</span> <span class="id">i</span>) !=<span class="id">set0</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">connected</span> (<span class="id">A</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) (<span class="id">A</span> <span class="id">i</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof330')">Proof.</span></div>
<div class="proofscript" id="proof330">
<span class="id"><a href="mathcomp.classical.boolp.html#predeqE">move</a></span>=&gt; [<span class="id">c</span> <span class="id">AIc</span>] <span class="id">cA</span>; <span class="id">have</span> [[<span class="id">i</span> <span class="id">Pi</span>]|] := <span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span>); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">forallNP</span> =&gt; <span class="id">P0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">P</span> = <span class="id">set0</span>) ?<span class="id">bigcup_set0</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">connected0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">P0</span>.<br/>
<span class="id">apply</span>/<span class="id">connectedP</span> =&gt; [<span class="id">E</span> [<span class="id">E0</span> <span class="id">EU</span> <span class="id">sE</span>]].<br/>
<span class="id">wlog</span> <span class="id">E0c</span> : <span class="id">E</span> <span class="id">E0</span> <span class="id">EU</span> <span class="id">sE</span> / <span class="id">E</span> <span class="id">false</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">G</span>; <span class="id">have</span> : (\<span class="id"><a href="mathcomp.analysis.topology.html#separatedC">bigcup_</a></span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) <span class="id">A</span> <span class="id">i</span>) <span class="id">c</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">i</a></span> =&gt; //; <span class="id">exact</span>: <span class="id">AIc</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">EU</span> =&gt; -[<span class="id">E0c</span>|<span class="id">E1c</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">G</span> (<span class="id">E</span> \<span class="id">o</span> <span class="id">negb</span>)) =&gt; //;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">case</span> =&gt; /=|<span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setUC</span>|<span class="id">rewrite</span> <span class="id">separatedC</span>].<br/>
<span class="id">move</span>: (<span class="id">E0</span> <span class="id">true</span>) =&gt; /<span class="id">set0P</span>/<span class="id">eqP</span>; <span class="id">apply</span>.<br/>
<span class="id">have</span> [/<span class="id">eqP</span> //|/<span class="id">set0P</span>[<span class="id">d</span> <span class="id">E1d</span>]] := <span class="id">boolP</span> (<span class="id">E</span> <span class="id">true</span> == <span class="id">set0</span>).<br/>
<span class="id">have</span> : \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) <span class="id">A</span> <span class="id">i</span> `&lt;=` <span class="id">E</span> <span class="id">false</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> <span class="id">AE</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">A</span> <span class="id">i</span> `&lt;=` <span class="id">E</span> <span class="id">false</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">j</span> ? ?]; <span class="id">exact</span>: (<span class="id">AE</span> <span class="id">j</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#separated_disjoint">j</a></span> <span class="id">Pj</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: (@<span class="id">connected_subset</span> <span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">_</a></span> (<span class="id">A</span> <span class="id">j</span>) <span class="id">sE</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">EU</span> =&gt; /(<span class="id">_</span> (<span class="id">bigcup_sup</span> <span class="id">_</span>) (<span class="id">cA</span> <span class="id">_</span> <span class="id">Pj</span>)) [//| | <span class="id">AjE1</span>]; <span class="id">first</span> <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="id">exfalso</span>; <span class="id">have</span> <span class="id">E1c</span> := <span class="id">AjE1</span> <span class="id">_</span> (<span class="id">AIc</span> <span class="id">_</span> <span class="id">Pj</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">separated_disjoint</span> : <span class="id">sE</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">c</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#connected">rewrite</a></span> <span class="id">EU</span> <span class="id">subUset</span> =&gt; -[<span class="id">_</span>] /(<span class="id">_</span> <span class="id">_</span> <span class="id">E1d</span>) <span class="id">E0d</span>; <span class="id">exfalso</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">separated_disjoint</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcup2inE">sE</a></span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">d</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedU</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span> -&gt; <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">connected</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof331')">Proof.</span></div>
<div class="proofscript" id="proof331">
<span class="id">move</span>=&gt; [<span class="id">x</span> [<span class="id">Ax</span> <span class="id">Bx</span>]] <span class="id">Ac</span> <span class="id">Bc</span>; <span class="id">rewrite</span> -<span class="id">bigcup2inE</span>; <span class="id">apply</span>: <span class="id">bigcup_connected</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span> =&gt; //= -[|[|[]]].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [|[|[]]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_closure</span> <span class="id">A</span> : <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected</span> (<span class="id">closure</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof332')">Proof.</span></div>
<div class="proofscript" id="proof332">
<span class="id">move</span>=&gt; <span class="id">ctdA</span> <span class="id">U</span> <span class="id">U0</span> [<span class="id">C1</span> <span class="id">oC1</span> <span class="id">C1E</span>] [<span class="id">C2</span> <span class="id">cC2</span> <span class="id">C2E</span>]; <span class="id">rewrite</span> <span class="id">eqEsubset</span> <span class="id">C2E</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">suff</span> : <span class="id">A</span> `&lt;=` <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">closure_subset</span>; <span class="id">rewrite</span> [<span class="id">_</span> `&amp;` <span class="id">_</span>](<span class="id">iffLR</span> (<span class="id">closure_id</span> <span class="id">_</span>)) ?<span class="id">C2E</span>//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedI</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> -<span class="id">setIidPl</span>; <span class="id">apply</span>: <span class="id">ctdA</span>.<br/>
- <span class="id">move</span>: <span class="id">U0</span>; <span class="id">rewrite</span> <span class="id">C1E</span> =&gt; -[<span class="id">z</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#setIA">clAx</a></span> <span class="id">C1z</span>]]; <span class="id">have</span> [] := <span class="id">clAx</span> <span class="id">C1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> [<span class="id">Aw</span> <span class="id">C1w</span>]; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">w</a></span>; <span class="id">rewrite</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C1</span> =&gt; //; <span class="id">rewrite</span> <span class="id">C1E</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected">C2</a></span> =&gt; //; <span class="id">rewrite</span> <span class="id">C2E</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">connected_component</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">C</span> : <span class="id">set</span> <span class="id">T</span> | [/\ <span class="id">C</span> <span class="id">x</span>, <span class="id">C</span> `&lt;=` <span class="id">A</span> &amp; <span class="id">connected</span> <span class="id">C</span>]]) <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">component_connected</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">connected</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof333')">Proof.</span></div>
<div class="proofscript" id="proof333">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_connected</span>; [<span class="kwd">exists</span> <span class="id">x</span> =&gt; <span class="id">C</span> []|<span class="id">move</span>=&gt; <span class="id">C</span> []]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_sub</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof334')">Proof.</span></div>
<div class="proofscript" id="proof334">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [<span class="id">B</span> [<span class="id">_</span> + <span class="id">_</span>]] =&gt; /[<span class="id">apply</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_id</span> <span class="id">A</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof335')">Proof.</span></div>
<div class="proofscript" id="proof335">
<span class="id">move</span>=&gt; <span class="id">Ax</span> <span class="id">Ac</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">connected_component_sub</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Ay</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_out</span> <span class="id">A</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof336')">Proof.</span></div>
<div class="proofscript" id="proof336">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">NAx</span>; <span class="id">rewrite</span> -<span class="id">subset0</span> =&gt; <span class="id">y</span> [<span class="id">B</span> [/[<span class="id">swap</span>]/[<span class="id">apply</span>]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_max</span> <span class="id">A</span> <span class="id">B</span> <span class="id">x</span> : <span class="id">B</span> <span class="id">x</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">B</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof337')">Proof.</span></div>
<div class="proofscript" id="proof337">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Bx</span> <span class="id">BA</span> <span class="id">Bc</span> <span class="id">y</span> <span class="id">By</span>; <span class="kwd">exists</span> <span class="id">B</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_refl</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqP">A</a></span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof338')">Proof.</span></div>
<div class="proofscript" id="proof338">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Ax</span>; <span class="kwd">exists</span> [<span class="id"><a href="mathcomp.analysis.topology.html#connected_component_sub">set</a></span> <span class="id">x</span>] =&gt; //; <span class="id">split</span> =&gt; // <span class="id">_</span> -&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected_component">connected_component_cover</a></span> <span class="id">A</span> :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id">connected_component</span> <span class="id">A</span> @` <span class="id">A</span>) <span class="id">A</span> = <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof339')">Proof.</span></div>
<div class="proofscript" id="proof339">
<span class="id">apply</span>/<span class="id">predeqP</span> =&gt; <span class="id">x</span>; <span class="id">split</span>=&gt; [[<span class="id">B</span> [<span class="id">y</span> <span class="id">By</span> &lt;- /<span class="id">connected_component_sub</span>//]]|<span class="id">Ax</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>) =&gt; //; <span class="id">apply</span>: <span class="id">connected_component_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_sym</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">y</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof340')">Proof.</span></div>
<div class="proofscript" id="proof340">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> [*]]; <span class="kwd">exists</span> <span class="id">B</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_trans</span> <span class="id">A</span> <span class="id">y</span> <span class="id">x</span> <span class="id">z</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">y</span> <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id"><a name="same_connected_component">A</a></span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof341')">Proof.</span></div>
<div class="proofscript" id="proof341">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">Bx</span> <span class="id">BA</span> <span class="id">Ac</span> <span class="id">Ay</span>]] [<span class="id">C</span> [<span class="id">Cy</span> <span class="id">CA</span> <span class="id">Cc</span> <span class="id">Cz</span>]]; <span class="kwd">exists</span> (<span class="id">B</span> `|` <span class="id">C</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">right</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">left</span> | <span class="id">rewrite</span> <span class="id">subUset</span> | <span class="id">apply</span>: <span class="id">connectedU</span>=&gt; //; <span class="kwd">exists</span> <span class="id">y</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">same_connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id">connected_component</span> <span class="id">A</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof342')">Proof.</span></div>
<div class="proofscript" id="proof342">
<span class="id">move</span>=&gt; <span class="id">Axy</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span> =&gt; <span class="id">z</span>; <span class="id">apply</span>: <span class="id">connected_component_trans</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">connected_component_sym</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">component_closed</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof343')">Proof.</span></div>
<div class="proofscript" id="proof343">
<span class="id">move</span>=&gt; <span class="id">clA</span>; <span class="id">have</span> [<span class="id">Ax</span>|<span class="id">Ax</span>] := <span class="id">pselect</span> (<span class="id">A</span> <span class="id">x</span>); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">connected_component_out</span> //; <span class="id">exact</span>: <span class="id">closed0</span>.<br/>
<span class="id">rewrite</span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#closure_subset">z</a></span> <span class="id">Axz</span>; <span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>)) =&gt; //.<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">subset_closure</span>/<span class="id">connected_component_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&lt;=` <span class="id">X</span>](<span class="id">closure_id</span> <span class="id">A</span>).1//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closure_subset</span>; <span class="id">exact</span>: <span class="id">connected_component_sub</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">connected_closure</span>; <span class="id">exact</span>: <span class="id">component_connected</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_separatedP</span> <span class="id">A</span> : <span class="id">clopen</span> <span class="id">A</span> &lt;-&gt; <span class="id">separated</span> <span class="id">A</span> (~` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof344')">Proof.</span></div>
<div class="proofscript" id="proof344">
<span class="id">split</span>=&gt; [[<span class="id">oA</span> <span class="id">cA</span>]|[] /[!(@<span class="id">disjoints_subset</span> <span class="id">T</span>)] /[!(@<span class="id">setCK</span> <span class="id">T</span>)] <span class="id">clAA</span> <span class="id">AclA</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">separated</span> -((<span class="id">closure_id</span> <span class="id">A</span>).1 <span class="id">cA</span>) <span class="id"><a href="mathcomp.analysis.topology.html#closedC">setICr</a></span> ; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -((<span class="id">closure_id</span> <span class="id">_</span>).1 (<span class="id">open_closedC</span> <span class="id">oA</span>)) <span class="id">setICr</span>.<br/>
<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a name="DiscreteTopology">closedC</a></span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span>;<br/>
&nbsp;&nbsp;[<span class="id">exact</span>: <span class="id">subset_closure</span>|<span class="id">exact</span>: <span class="id">subsetCr</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">connected_sets</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">connected</span> {<span class="id">T</span>}.<br/>
<span class="kwd">Arguments</span> <span class="id">connected_component</span> {<span class="id">T</span>}.<br/>
<span class="kwd">Section</span> <span class="id">DiscreteTopology</span>.<br/>
<span class="kwd">Section</span> <span class="id">DiscreteMixin</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="kwd">Type</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_sing</span> (<span class="id">p</span> : <span class="id">X</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">principal_filter</span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof345')">Proof.</span></div>
<div class="proofscript" id="proof345">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">principal_filterP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_nbhs</span> (<span class="id">p</span> : <span class="id">X</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">principal_filter</span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">principal_filter</span> <span class="id">p</span> (<span class="id">principal_filter</span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof346')">Proof.</span></div>
<div class="proofscript" id="proof346">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>/<span class="id">principal_filterP</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_topological_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfFilterMixin</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">principal_filter_proper</a></span> <span class="id">discrete_sing</span> <span class="id">discrete_nbhs</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">DiscreteMixin</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_space</span> (<span class="id">X</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">nbhs</span> <span class="id">X</span> <span class="id"><a href="mathcomp.analysis.topology.html#DiscreteTopology.dsc">_</a></span> = @<span class="id">principal_filter</span> <span class="id">X</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>} {<span class="id">dsc</span>: <span class="id">discrete_space</span> <span class="id">X</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">open</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof347')">Proof.</span></div>
<div class="proofscript" id="proof347">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openE</span> =&gt; ? ?; <span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">dsc</span>; <span class="id">exact</span>/<span class="id">principal_filterP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_set1</span> (<span class="id">x</span> : <span class="id">X</span>) : <span class="id">nbhs</span> <span class="id">x</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof348')">Proof.</span></div>
<div class="proofscript" id="proof348">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a name="discrete_cvg">open_nbhs_nbhs</a></span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#DiscreteTopology.X">discrete_open</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof349')">Proof.</span></div>
<div class="proofscript" id="proof349">
 <span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">A</span>]<span class="id">setCK</span> <span class="id">closedC</span>; <span class="id">exact</span>: <span class="id">discrete_open</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">X</span>)) (<span class="id">x</span> : <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; <span class="id">x</span> &lt;-&gt; <span class="id">F</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof350')">Proof.</span></div>
<div class="proofscript" id="proof350">
<span class="id">rewrite</span> /<span class="id">filter_of</span> <span class="id">dsc</span> <span class="id">nbhs_simpl</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fx</span> <span class="id">U</span> /<span class="id">principal_filterP</span> ?; <span class="id"><a name="bool_discrete_topology">apply</a></span>: <span class="id">filterS</span> <span class="id">Fx</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id">X</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof351')">Proof.</span></div>
<div class="proofscript" id="proof351">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">q</span> /(<span class="id"><a name="discrete_bool">_</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id">discrete_set1</span> <span class="id">p</span>) (<span class="id">discrete_set1</span> <span class="id">q</span>))[<span class="id">x</span> [] -&gt; -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">bool_discrete_topology</span> : <span class="id">topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">bool</span> <span class="id">discrete_topological_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_bool</span> : <span class="id">discrete_space</span> <span class="id">bool_discrete_topology</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof352')">Proof.</span></div>
<div class="proofscript" id="proof352">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bool_compact</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">bool</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof353')">Proof.</span></div>
<div class="proofscript" id="proof353">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">rewrite</a></span> <span class="id">setT_bool</span>; <span class="id">apply</span>/<span class="id">compactU</span>; <span class="id">exact</span>: <span class="id">compact_set1</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">DiscreteTopology</span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">discrete_bool</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">perfect_sets</span>.<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">T</span> : <span class="id">topologicalType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">perfect_set</a></span> {<span class="id">T</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">closed</span> <span class="id">A</span> /\ <span class="id">limit_point</span> <span class="id">A</span> = <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfectTP</span> {<span class="id">T</span>} : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>] &lt;-&gt; <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">T</span>, ~ <span class="id">open</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof354')">Proof.</span></div>
<div class="proofscript" id="proof354">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">case</span>=&gt; <span class="id">_</span> + <span class="id">x</span> <span class="id">Ox</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">I</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>; [<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> |] =&gt; <span class="id">y</span> [+ <span class="id">_</span>] =&gt; /[<span class="id">swap</span>] -&gt; /<span class="id">eqP</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">NOx</span>; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">closedT</span> |]; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span> // <span class="id">_</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span>; <span class="id">rewrite</span> <span class="id">nbhsE</span>; <span class="id">case</span>=&gt; <span class="id">V</span> [] <span class="id">oV</span> <span class="id">Vx</span> <span class="id">VU</span>.<br/>
<span class="id">have</span> <span class="id">Vnx</span>: <span class="id">V</span> != [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">M</span>; <span class="id">apply</span>: (<span class="id">NOx</span> <span class="id">x</span>); <span class="id">rewrite</span> -<span class="id">M</span>.<br/>
<span class="id">have</span> /<span class="id">existsNP</span> [<span class="id">y</span> /<span class="id">existsNP</span> [<span class="id">Vy</span> <span class="id">Ynx</span>]] : ~ <span class="kwd">forall</span> <span class="id">y</span>, <span class="id"><a name="perfect_prod">V</a></span> <span class="id">y</span> -&gt; <span class="id">y</span> = <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">negP</span>: <span class="id">Vnx</span>; <span class="id">apply</span>: <span class="id">contra_not</span> =&gt; <span class="id">Vxy</span>; <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; // ? -&gt;.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span> =&gt; //; [<span class="id">exact</span>/<span class="id">eqP</span> | <span class="id"><a href="mathcomp.analysis.topology.html#perfectTP">exact</a></span>: <span class="id">VU</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_prod</span> {<span class="id">I</span> : <span class="kwd">Type</span>} (<span class="id">i</span> : <span class="id">I</span>) (<span class="id">K</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;<span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">K</span> <span class="id">i</span>] -&gt; <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">product_topologicalType</span> <span class="id">K</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof355')">Proof.</span></div>
<div class="proofscript" id="proof355">
<span class="id">move</span>=&gt; /<span class="id">perfectTP</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">KPo</a></span>; <span class="id">apply</span>/<span class="id">perfectTP</span> =&gt; <span class="id">f</span> <span class="id">oF</span>; <span class="id">apply</span>: (<span class="id">KPo</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<span class="id">rewrite</span> (<span class="id">_</span> : [<span class="id">set</span> <span class="id">f</span> <span class="id">i</span>] = <span class="id">proj</span> <span class="id">i</span> @` [<span class="id">set</span> <span class="id">f</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType">apply</a></span>: (@<span class="id">proj_open</span> (<span class="id">classicType_choiceType</span> <span class="id">I</span>) <span class="id">_</span> <span class="id">i</span>); <span class="id">exact</span>: <span class="id">oF</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; ? //; [<span class="id">move</span>=&gt; -&gt; /=; <span class="kwd">exists</span> <span class="id">f</span> | <span class="id">case</span>=&gt; <span class="id">g</span> -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_diagonal</span> (<span class="id">K</span> : <span class="id">nat_topologicalType</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="kwd">exists</span> (<span class="id">xy</span>: <span class="id">K</span> <span class="id">i</span> * <span class="id">K</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">i</a></span>), <span class="id">xy</span>.1 != <span class="id">xy</span>.2) -&gt;<br/>
&nbsp;&nbsp;<span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">product_topologicalType</span> <span class="id">K</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof356')">Proof.</span></div>
<div class="proofscript" id="proof356">
<span class="id">move</span>=&gt; <span class="id">npts</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">closedT</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">f</span> // <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">_</a></span>.<br/>
<span class="id">pose</span> <span class="id">distincts</span> (<span class="id">i</span> : <span class="id">nat</span>) := <span class="id">projT1</span> (<span class="id">sigW</span> (<span class="id">npts</span> <span class="id">i</span>)).<br/>
<span class="id">pose</span> <span class="id">derange</span> (<span class="id">i</span> : <span class="id">nat</span>) (<span class="id">z</span> : <span class="id"><a href="mathcomp.analysis.topology.html#product_topologicalType">K</a></span> <span class="id">i</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">z</span> == (<span class="id">distincts</span> <span class="id">i</span>).1 <span class="kwd">then</span> (<span class="id">distincts</span> <span class="id">i</span>).2 <span class="kwd">else</span> (<span class="id">distincts</span> <span class="id">i</span>).1.<br/>
<span class="id">pose</span> <span class="id">g</span> (<span class="id">N</span> <span class="id">i</span> : <span class="id">nat</span>) := <span class="kwd">if</span> (<span class="id">i</span> &lt; <span class="id">N</span>)%<span class="id">nat</span> <span class="kwd">then</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">f</a></span> <span class="id">i</span> <span class="kwd">else</span> <span class="id">derange</span> <span class="id">_</span> (<span class="id">f</span> <span class="id">i</span>).<br/>
<span class="id">have</span> <span class="id">gcvg</span> : <span class="id">g</span> @ \<span class="id">oo</span> --&gt; (<span class="id">f</span> : <span class="id">product_topologicalType</span> <span class="id">K</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/(@<span class="id">cvg_sup</span> (<span class="id">product_topologicalType</span> <span class="id">K</span>)) =&gt; <span class="id">N</span> <span class="id">U</span> [<span class="id">V</span>] [][<span class="id">W</span>] <span class="id">oW</span> &lt;- <span class="id">WfN</span> <span class="id">WU</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">WU</span>); <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /<span class="id">g</span>; <span class="kwd">exists</span> <span class="id">N</span>.+1 =&gt; // <span class="id">i</span> /= -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">gcvg</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>; <span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">_</span> <span class="id">An</span>.<br/>
<span class="kwd">exists</span> (<span class="id">g</span> <span class="id">N</span>); <span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">An</span>; <span class="id">rewrite</span> /= ?<span class="id">leqnn</span> //.<br/>
<span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">M</span>; <span class="id">suff</span>: <span class="id">g</span> <span class="id">N</span> <span class="id">N</span> != <span class="id">f</span> <span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">M</span>; <span class="id">move</span>/<span class="id">eqP</span>.<br/>
<span class="id">rewrite</span> /<span class="id">g</span> <span class="id">ltnn</span> /<span class="id">derange</span> <span class="id">eq_sym</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> (<span class="id">f</span> <span class="id">N</span>) (<span class="id">distincts</span> <span class="id">N</span>).1) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">have</span> := <span class="id">projT2</span> (<span class="id">sigW</span> (<span class="id">npts</span> <span class="id">N</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_set2</span> {<span class="id">T</span>} : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>] &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>), <span class="id">open</span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; <br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">x</span> <span class="id">y</span>, [/\ <span class="id">U</span> <span class="id">x</span>, <span class="id">U</span> <span class="id">y</span> &amp; <span class="id">x</span> != <span class="id">y</span>] .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof357')">Proof.</span></div>
<div class="proofscript" id="proof357">
<span class="id">apply</span>: <span class="id">iff_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">perfectTP</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">nx1</span> <span class="id">U</span> <span class="id">oU</span> [] <span class="id">x</span> <span class="id">Ux</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> : <span class="id">U</span> &lt;&gt; [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Ux1</span>; <span class="id">apply</span>: (<span class="id">nx1</span> <span class="id">x</span>); <span class="id">rewrite</span> -<span class="id">Ux1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">contra_notP</span>; <span class="id">move</span>/<span class="id">not_existsP</span>/<span class="id">contrapT</span>=&gt; <span class="id">Uyx</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
&nbsp;&nbsp;(<span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? -&gt;); <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Uy</span>; <span class="id">have</span>  /<span class="id">not_and3P</span> := <span class="id">Uyx</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; // /<span class="id">negP</span>; <span class="id">rewrite</span> <span class="id">negbK</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">Unxy</span> <span class="id">x</span> <span class="id">Ox</span>; <span class="id">have</span> [] := <span class="id">Unxy</span> <span class="id">_</span> <span class="id">Ox</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] ? [-&gt;] -&gt; /<span class="id">eqP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">perfect_sets</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">totally_disconnected</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">totally_disconnected</span> {<span class="id">T</span>} (<span class="id"><a href="mathcomp.analysis.topology.html#discrete_open">A</a></span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#discrete_closed">x</a></span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id"><a name="zero_dimension_totally_disconnected">A</a></span> <span class="id">x</span> = [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">zero_dimensional</span> <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimensional">T</a></span> :=<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt; <span class="kwd">exists</span> <span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>, [/\ <span class="id">clopen</span> <span class="id">U</span>, <span class="id">U</span> <span class="id">x</span> &amp; ~ <span class="id">U</span> <span class="id">y</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">zero_dimension_prod</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">zero_dimensional</span> (<span class="id">T</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof358')">Proof.</span></div>
<div class="proofscript" id="proof358">
<span class="id">move</span>=&gt; <span class="id">dctTI</span> <span class="id">x</span> <span class="id">y</span> /<span class="id">eqP</span> <span class="id">xneqy</span>.<br/>
<span class="id">have</span> [<span class="id">i</span>/<span class="id">eqP</span>/<span class="id">dctTI</span> [<span class="id">U</span> [<span class="id">clU</span> <span class="id">Ux</span> <span class="id">nUy</span>]]] : <span class="kwd">exists</span> <span class="id">i</span>, <span class="id">x</span> <span class="id">i</span> &lt;&gt; <span class="id">y</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">existsNP</span>=&gt; <span class="id">W</span>; <span class="id">exact</span>/<span class="id">xneqy</span>/<span class="id">functional_extensionality_dep</span>.<br/>
<span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">i</span> @^-1` <span class="id">U</span>); <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">clopen_comp</span> =&gt; //.<br/>
<span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">proj_continuous</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_zero_dimension</span> {<span class="id">T</span>} : <span class="id">discrete_space</span> <span class="id">T</span> -&gt; <span class="id">zero_dimensional</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof359')">Proof.</span></div>
<div class="proofscript" id="proof359">
<span class="id">move</span>=&gt; <span class="id">dctT</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xny</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">x</span>]; <span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="id">exact</span>/<span class="id">nesym</span>/<span class="id">eqP</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">discrete_open</span> | <span class="id">exact</span>: <span class="id">discrete_closed</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">zero_dimension_totally_disconnected</span> {<span class="id">T</span>} :<br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span> <span class="id">T</span> -&gt; <span class="id">totally_disconnected</span> [<span class="id">set</span>: <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof360')">Proof.</span></div>
<div class="proofscript" id="proof360">
<span class="id">move</span>=&gt; <span class="id">zdA</span> <span class="id">x</span> <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">z</span> [<span class="id">R</span> [<span class="id">Rx</span> <span class="id">_</span> <span class="id">ctdR</span> <span class="id">Rz</span>]]|<span class="id">_</span> -&gt;]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">connected_component_refl</span>.<br/>
<span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">eqP</span> <span class="id">znx</span>; <span class="id">have</span> [<span class="id">U</span> [[<span class="id">oU</span> <span class="id">cU</span>] <span class="id">Uz</span> <span class="id">Ux</span>]] := <span class="id">zdA</span> <span class="id">_</span> <span class="id">_</span>  <span class="id">znx</span>.<br/>
<span class="id">suff</span> : <span class="id">R</span> `&amp;` <span class="id">U</span> = <span class="id">R</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">Rx</span> =&gt; /[<span class="id">swap</span>] &lt;- [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ctdR</span>; [<span class="kwd">exists</span> <span class="id">z</span>|<span class="kwd">exists</span> <span class="id">U</span>|<span class="kwd">exists</span> <span class="id">U</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">totally_disconnected_cvg</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">zero_dimensional</span> <span class="id">T</span> -&gt; <span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> [<span class="id">set</span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span> | <span class="id">D</span> <span class="id">x</span> /\ <span class="id">clopen</span> <span class="id">D</span>] <span class="id">id</span> --&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#contra_notN">x</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof361')">Proof.</span></div>
<div class="proofscript" id="proof361">
<span class="id">pose</span> <span class="id">F</span> := <span class="id">filter_from</span> [<span class="id">set</span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span> | <span class="id">D</span> <span class="id">x</span> /\ <span class="id">clopen</span> <span class="id">D</span>] <span class="id">id</span>.<br/>
<span class="id">have</span> <span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">clopenT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_powerset_filter_fromP">move</a></span>=&gt; <span class="id">A</span> <span class="id">B</span> [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //; <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">clopenI</span>.<br/>
<span class="id">have</span> <span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_from_proper</span>; <span class="id">move</span>=&gt; ? [? <span class="id">_</span>]; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">hsdfT</span> <span class="id">zdT</span> <span class="id">cmpT</span> <span class="id">U</span> <span class="id">Ux</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> -/<span class="id">F</span>.<br/>
<span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">Ux</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Ux</span>; <span class="id">rewrite</span> /= <span class="id">nbhsE</span> =&gt; -[] <span class="id">V</span> [? ?] /<span class="id">filterS</span> + /(<span class="id">_</span> <span class="id">V</span>) <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">P</span> =&gt; //; <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="id">have</span> /(<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">_</span>)) : <span class="id">compact</span> (~` <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cmpT</span>) =&gt; //; <span class="id">exact</span>: <span class="id">open_closedC</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">setC</span> (<span class="id">powerset_filter_from_filter</span> <span class="id">PF</span>))[].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">nUy</span>; <span class="id">have</span> /<span class="id">zdT</span> [<span class="id">C</span> [[<span class="id">oC</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">cC</a></span>] <span class="id">Cx</span> <span class="id">Cy</span>]] : <span class="id">x</span> != <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">contra_notN</span> <span class="id">nUy</span> =&gt; /<span class="id">eqP</span> &lt;-; <span class="id">exact</span>: <span class="id">nbhs_singleton</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (~` <span class="id">C</span>, [<span class="id">set</span> <span class="id">U</span> | <span class="id">U</span> `&lt;=` <span class="id">C</span>]); <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#set_nbhs_filter">split</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_openC</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#set_nbhs.T">near_powerset_filter_fromP</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span> =&gt; //; <span class="kwd">exists</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">i</span> <span class="id">j</span> [? /<span class="id">subsetC</span>]; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">D</span> [<span class="id">DF</span> <span class="id">_</span> [<span class="id">C</span> <span class="id">DC</span>]]/(<span class="id">_</span> <span class="id">_</span> <span class="id">DC</span>)/<span class="id">subsetC2</span>/<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">DF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">totally_disconnected</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">set_nbhs</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<span class="kwd">Definition</span> <span class="id">set_nbhs</span> := \<span class="id">bigcap_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">A</span>) (<span class="id">nbhs</span> <span class="id">x</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">set_nbhs_filter</span> : <span class="id">Filter</span> <span class="id">set_nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof362')">Proof.</span></div>
<div class="proofscript" id="proof362">
<span class="id">split</span> =&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Px</span> <span class="id">Qx</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">apply</span>: <span class="id">filterI</span>; [<span class="id">exact</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">Px</a></span> | <span class="id">exact</span>: <span class="id">Qx</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">PQ</span> + <span class="id">x</span> <span class="id">Ax</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ax</span>)/<span class="id">filterS</span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">set_nbhs_pfilter</span> : <span class="id">A</span>!=<span class="id">set0</span> -&gt; <span class="id">ProperFilter</span> <span class="id">set_nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof363')">Proof.</span></div>
<div class="proofscript" id="proof363">
<span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">set_nbhs_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">_</span> <span class="id">x</span> <span class="id">Ax</span>)/<span class="id">nbhs_singleton</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_nbhsP</span> (<span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">set_nbhs</span> <span class="id">B</span> &lt;-&gt; (<span class="kwd">exists</span> <span class="id">C</span>, [/\ <span class="id">open</span> <span class="id">C</span>, <span class="id">A</span> `&lt;=` <span class="id">C</span> &amp; <span class="id">C</span> `&lt;=` <span class="id">B</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof364')">Proof.</span></div>
<div class="proofscript" id="proof364">
<span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">V</span> [? <span class="id">AV</span> /<span class="id">filterS</span> +] <span class="id">x</span> /<span class="id">AV</span> ?; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">snB</span>; <span class="id">have</span> <span class="id">Ux</span> <span class="id">x</span> : <span class="kwd">exists</span> <span class="id">U</span>, <span class="id">A</span> <span class="id">x</span> -&gt; [/\ <span class="id">U</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_">open</a></span> <span class="id">U</span> &amp; <span class="id">U</span> `&lt;=` <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [/<span class="id">snB</span>|?] := <span class="id">pselect</span> (<span class="id">A</span> <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; -[<span class="id">V</span> [? ? ?]]; <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">A</span>) (<span class="id">projT1</span> (<span class="id"><a name="Uniform.entourage">cid</a></span> (<span class="id">Ux</span> <span class="id">x</span>)))); <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">x</span>)).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">x</span>)).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">y</span> <span class="id">Ay</span>]; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">y</span>)); <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">set_nbhs</span>.<br/>
<br/>
<h1> Uniform spaces </h1>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "'<span class="id">to_set</span>' <span class="id">A</span> <span class="id">x</span>" := ([<span class="id">set</span> <span class="id">y</span> | <span class="id">A</span> (<span class="id">x</span>, <span class="id"><a name="Uniform.base">y</a></span>)])<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 0) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_</span> {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>'))) (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a name="Uniform.sort">filter_from</a></span> <span class="id">ent</span> (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">to_set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.sort">A</a></span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_E</span> {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>'))) <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs_</span> <span class="id">ent</span> <span class="id">x</span> = <span class="id">filter_from</span> <span class="id">ent</span> (<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.Pack">A</a></span> =&gt; <span class="id">to_set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">A</a></span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof365')">Proof.</span></div>
<div class="proofscript" id="proof365">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">Uniform</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">mixin_of</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class">M</a></span> : <span class="kwd">Type</span>) (<span class="id">nbhs</span> : <span class="id">M</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">M</span>)) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">entourage</a></span> : (<span class="id">M</span> * <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_filter</span> : <span class="id">Filter</span> <span class="id">entourage</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_refl</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2] `&lt;=` <span class="id">A</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_inv</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.mixin_of">entourage</a></span> <span class="id">A</span> -&gt; <span class="id">entourage</span> (<span class="id">A</span>^-1)%<span class="id">classic</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_split_ex</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">entourage</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.mixin_of">A</a></span> ;<br/>
&nbsp;&nbsp;<span class="id">nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">entourage</span><br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.Class">class_of</a></span> (<span class="id">M</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Topological.class_of</span> <span class="id">M</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id"><a name="Uniform.choiceType">mixin_of</a></span> (<span class="id">Filtered.nbhs_op</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">base</a></span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.xclass">sort</a></span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id"><a name="Uniform.filteredType">sort</a></span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.eqType">Topological.class_of</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">nbhs</span> (<span class="id">m</span> : @<span class="id">mixin_of</span> <span class="id">T</span> <span class="id">nbhs</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> (<span class="id">b</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.pointedType">Topological.class_of</a></span> <span class="id">T</span>) <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Topological.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.filteredType">m</a></span>'   <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id">mixin_of</span> <span class="id">T</span> (<span class="id">Filtered.nbhs_op</span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Topological.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">uniformType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> <span class="id">UniformType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">Notation</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">UniformMixin</a></span> := <span class="id">Mixin</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">uniformType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">uniformType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">uniformType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">uniformType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Uniform</span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id">Uniform.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">UniformTopology</span>.<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">topologyOfEntourageMixin</span> (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">nbhs</span> : <span class="id">T</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">m</span> : <span class="id">Uniform.mixin_of</span> <span class="id">nbhs</span>) :<br/>
&nbsp;&nbsp;<span class="id">Topological.mixin_of</span> <span class="id">nbhs</span> := <span class="id">topologyOfFilterMixin</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof366')">Next Obligation.</span></div>
<div class="proofscript" id="proof366">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span>.<br/>
<span class="id">rewrite</span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span>; <span class="id"><a href="mathcomp.analysis.topology.html#entourage">apply</a></span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="nbhs_entourageE">move</a></span>=&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entA</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: @<span class="id">filterT</span> (<span class="id">Uniform.entourage_filter</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //.<br/>
<span class="id">exact</span>: (@<span class="id">filterI</span> <span class="id"><a name="filter_from_entourageE">_</a></span> <span class="id">_</span> (<span class="id">Uniform.entourage_filter</span> <span class="id">m</span>)).<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof367')">Next Obligation.</span></div>
<div class="proofscript" id="proof367">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span>  =&gt; - [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBpA</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sBpA</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entB</span> <span class="id">_</span> <span class="id">_</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof368')">Next Obligation.</span></div>
<div class="proofscript" id="proof368">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span> =&gt; - [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBpA</span>].<br/>
<span class="id">have</span> /<span class="id">Uniform.entourage_split_ex</span> [<span class="id">C</span> <span class="id">entC</span> <span class="id">sC2B</span>] := <span class="id">entB</span>.<br/>
<span class="kwd">exists</span> <span class="id">C</span> =&gt; // <span class="id">q</span> <span class="id">Cpq</span>; <span class="id">rewrite</span> <span class="id">nbhs_E</span>; <span class="kwd">exists</span> <span class="id">C</span> =&gt; // <span class="id">r</span> <span class="id"><a name="filter_inv">Cqr</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">sBpA</span>/<span class="id">sC2B</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">q</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">UniformTopology</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage</span> {<span class="id">M</span> : <span class="id">uniformType</span>} := <span class="id">Uniform.entourage</span> (<span class="id">Uniform.class</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_entourageE</span> {<span class="id">M</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filterT">uniformType</a></span>} : <span class="id">nbhs_</span> (@<span class="id">entourage</span> <span class="id">M</span>) = <span class="id">nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof369')">Proof.</span></div>
<div class="proofscript" id="proof369">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">M</a></span>=&gt; [?[?[]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_sym</span> {<span class="id">X</span> <span class="id">Y</span> : <span class="kwd">Type</span>} <span class="id">E</span> (<span class="id">x</span> : <span class="id">X</span>) (<span class="id">y</span> : <span class="id">Y</span>) :<br/>
&nbsp;&nbsp;<span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>) &lt;-&gt; (<span class="id">E</span> ^-1)%<span class="id">classic</span> (<span class="id">y</span>, <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof370')">Proof.</span></div>
<div class="proofscript" id="proof370">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_from_entourageE</span> {<span class="id">M</span> : <span class="id">uniformType</span>} <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">M</span>) (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">to_set</span> <span class="id">A</span> <span class="id">x</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof371')">Proof.</span></div>
<div class="proofscript" id="proof371">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id">NbhsEntourage</span>.<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_simpl</span> :=<br/>
&nbsp;&nbsp;(<span class="id">nbhs_simpl</span>,@<span class="id">filter_from_entourageE</span>,@<span class="id">nbhs_entourageE</span>).<br/>
<span class="kwd">End</span> <span class="id">NbhsEntourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhsP</span> {<span class="id">M</span> : <span class="id">uniformType</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">P</span> : <span class="id">nbhs</span> <span class="id">x</span> <span class="id">P</span> &lt;-&gt; <span class="id">nbhs_</span> <span class="id">entourage</span> <span class="id">x</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof372')">Proof.</span></div>
<div class="proofscript" id="proof372">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_inv</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">Filter</span> [<span class="id">set</span> (<span class="id">V</span>^-1)%<span class="id">classic</span> | <span class="id">V</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">F</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof373')">Proof.</span></div>
<div class="proofscript" id="proof373">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id"><a href="mathcomp.analysis.topology.html#filterT">split</a></span> =&gt; /=.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span>: <span class="id">T</span> * <span class="id">T</span>] =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">exact</a></span>: <span class="id">filterT</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">R</span> <span class="id">FR</span> &lt;-] [<span class="id">S</span> <span class="id">FS</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">R</span> `&amp;` <span class="id">S</span>) =&gt; //; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span> [<span class="id">R</span> <span class="id">FR</span> <span class="id">RP</span>]; <span class="kwd">exists</span> <span class="id">Q</span>^-1%<span class="id">classic</span> =&gt; //; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ex">filterS</a></span> <span class="id">FR</span>; <span class="id">case</span>=&gt; ? ? /= ?; <span class="id">apply</span>: <span class="id">PQ</span>; <span class="id">rewrite</span> -<span class="id">RP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">uniformType1</span>.<br/>
<span class="kwd">Context</span> {<span class="id">M</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_refl</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) <span class="id">x</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">A</span> (<span class="id">x</span>, <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof374')">Proof.</span></div>
<div class="proofscript" id="proof374">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">entA</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entA</span> <span class="id">_</span> <span class="id">_</span>. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">entourage_pfilter</span> : <span class="id">ProperFilter</span> (@<span class="id">entourage</span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof375')">Proof.</span></div>
<div class="proofscript" id="proof375">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Uniform.entourage_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>); <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourageT</span> : <span class="id">entourage</span> [<span class="id">set</span>: <span class="id">M</span> * <span class="id">M</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof376')">Proof.</span></div>
<div class="proofscript" id="proof376">
 <span class="id">exact</span>: <span class="id">filterT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_inv</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof377')">Proof.</span></div>
<div class="proofscript" id="proof377">
 <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">exact</a></span>: <span class="id">Uniform.entourage_inv</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split_ex</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">entourage</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof378')">Proof.</span></div>
<div class="proofscript" id="proof378">
 <span class="id">exact</span>: <span class="id">Uniform.entourage_split_ex</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">split_ent</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">get</span> (<span class="id">entourage</span> `&amp;` [<span class="id">set</span> <span class="id">B</span> | <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">split_entP</a></span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">A</span>) /\ <span class="id">split_ent</span> <span class="id">A</span> \; <span class="id">split_ent</span> <span class="id">A</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof379')">Proof.</span></div>
<div class="proofscript" id="proof379">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">entourage_split_ex</span>/<span class="id">exists2P</span>/<span class="id">getPex</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split_ent</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof380')">Proof.</span></div>
<div class="proofscript" id="proof380">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">split_entP</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_split_ent</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">M</a></span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">A</span> \; <span class="id"><a href="mathcomp.analysis.topology.html#entourage">split_ent</a></span> <span class="id">A</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof381')">Proof.</span></div>
<div class="proofscript" id="proof381">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">split_entP</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) <span class="id">A</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">A</span> (<span class="id">x</span>,<span class="id">z</span>) -&gt; <span class="id">split_ent</span> <span class="id">A</span> (<span class="id">z</span>,<span class="id">y</span>) -&gt; <span class="id">A</span> (<span class="id">x</span>,<span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof382')">Proof.</span></div>
<div class="proofscript" id="proof382">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subset_split_ent</span> <span class="id">sA</span> ??; <span class="id">apply</span>: <span class="id">sA</span>; <span class="kwd">exists</span> <span class="id">z</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_entourage</span> (<span class="id">x</span> : <span class="id">M</span>) <span class="id">A</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span> <span class="id">x</span> (<span class="id">to_set</span> <span class="id">A</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">x</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof383')">Proof.</span></div>
<div class="proofscript" id="proof383">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_entourageP</span> <span class="id">F</span> (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id">p</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">p</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">q</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">p</span>, <span class="id">q</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof384')">Proof.</span></div>
<div class="proofscript" id="proof384">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">filter_fromP</span> !<span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_entourage</span> {<span class="id">F</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ent">FF</a></span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">y</span>,<span class="id">y</span>').<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof385')">Proof.</span></div>
<div class="proofscript" id="proof385">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">cvg_entourageP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_app_entourageP</span> <span class="id">T</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">F</span> (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) <span class="id">p</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">p</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">t</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">p</span>, <span class="id">f</span> <span class="id">t</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof386')">Proof.</span></div>
<div class="proofscript" id="proof386">
 <span class="id">exact</span>: <span class="id">cvg_entourageP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_invI</span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">M</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">entourage</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof387')">Proof.</span></div>
<div class="proofscript" id="proof387">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent_subset</a></span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">split_ent</span> <span class="id">E</span> `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof388')">Proof.</span></div>
<div class="proofscript" id="proof388">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">splitxy</span>; <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> <span class="id">y</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_refl</span>; <span class="id">exact</span>: <span class="id"><a name="continuous_withinNx">entourage_split_ent</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">uniformType1</span>.<br/>
<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">entourage_split_ent</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">get</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">entourage_split_ent</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">_</span>^-1)%<span class="id">classic</span>) =&gt; <span class="id">exact</span>: <span class="id">entourage_inv</span> : <span class="id">core</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">entourage_split</span> {<span class="id">M</span>} <span class="id">z</span> {<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">y</a></span> <span class="id">A</span>}.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">nbhs</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">nbhs_entourage</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ent_closure</span> {<span class="id">M</span> : <span class="id">uniformType</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">E</span> : <span class="id">entourage</span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span>) `&lt;=` <span class="id">to_set</span> <span class="id">E</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof389')">Proof.</span></div>
<div class="proofscript" id="proof389">
<span class="id">pose</span> <span class="id">E</span>' := (<span class="id">split_ent</span> <span class="id">E</span>) `&amp;` ((<span class="id">split_ent</span> <span class="id">E</span>)^-1)%<span class="id">classic</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entE</span> <span class="id">z</span> /(<span class="id">_</span> [<span class="id">set</span> <span class="id">y</span> | <span class="id">E</span>' (<span class="id">z</span>, <span class="id">y</span>)])[].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>; <span class="kwd">exists</span> <span class="id">E</span>' =&gt; //; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [/=] + [<span class="id">_</span>]; <span class="id">exact</span>: <span class="id">entourage_split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_withinNx</span> {<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">x</a></span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> <span class="id">f</span>} &lt;-&gt; <span class="id">f</span> @ <span class="id">x</span>^' --&gt; <span class="id">f</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof390')">Proof.</span></div>
<div class="proofscript" id="proof390">
<span class="id">split</span>=&gt; - <span class="id">cfx</span> <span class="id">P</span> /= <span class="id">fxP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">dnbhs</span> !<span class="id">near_simpl</span> <span class="id">near_withinE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">dnbhs</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>; <span class="id">apply</span>: <span class="id">cfx</span>.<br/>
<span class="id">rewrite</span> !<span class="id">nbhs_nearE</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#unsquash">near_map</a></span> !<span class="id">near_nbhs</span> <span class="kwd">in</span> <span class="id">fxP</span> *; <span class="id">have</span> /= := <span class="id">cfx</span> <span class="id">P</span> <span class="id">fxP</span>.<br/>
<span class="id">rewrite</span> !<span class="id">near_simpl</span> <span class="id">near_withinE</span> <span class="id">near_simpl</span> =&gt; <span class="id">Pf</span>; <span class="id">near</span>=&gt; <span class="id">y</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> [-&gt;|] := <span class="id">eqVneq</span> <span class="id">y</span> <span class="id">x</span>; [<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>|<span class="id">near</span>: <span class="id">y</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniformity</span> (<span class="id">T</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">R</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id"><a name="open_nbhs_entourage">T</a></span>)), [/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">countable</span> <span class="id">R</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">R</span> `&lt;=` <span class="id">entourage</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">entourage</span> <span class="id">P</span> -&gt; <span class="kwd">exists2</span> <span class="id">Q</span>, <span class="id">R</span> <span class="id">Q</span> &amp; <span class="id">Q</span> `&lt;=` <span class="id">P</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniformityP</span> {<span class="id">T</span> : <span class="id">uniformType</span>} :<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">T</span> &lt;-&gt; <span class="kwd">exists2</span> <span class="id">f</span> : <span class="id">nat</span> -&gt; <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">f</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">n</a></span>, <span class="id">entourage</span> (<span class="id">f</span> <span class="id">n</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof391')">Proof.</span></div>
<div class="proofscript" id="proof391">
<span class="id">split</span>=&gt; [[<span class="id">M</span> []]|[<span class="id">f</span> <span class="id">fsubE</span> <span class="id">entf</span>]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">pfcard_geP</span>[-&gt; <span class="id">_</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">entourageT</span>)[]//|/<span class="id">unsquash</span> <span class="id">f</span> <span class="id">eM</span> <span class="id">Msub</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourage">n</a></span>; <span class="id">apply</span>: <span class="id">eM</span>; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">Msub</span> [<span class="id">Q</span> + ?] =&gt; /(@<span class="id">surj</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">f</span>)[<span class="id">n</span> <span class="id">_</span> <span class="id">fQ</span>]; <span class="kwd">exists</span> <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">fQ</span>.<br/>
<span class="kwd">exists</span> (<span class="id">range</span> <span class="id">f</span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">card_image_le</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">n</span> <span class="id">_</span>] &lt;-; <span class="id">exact</span>: <span class="id">entf</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">move</a></span>=&gt; <span class="id">E</span> /<span class="id">fsubE</span> [<span class="id">n</span> <span class="id">fnA</span>]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">n</span>) =&gt; //; <span class="kwd">exists</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">uniform_closeness</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">U</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_nbhs_entourage</span> (<span class="id">x</span> : <span class="id">U</span>) (<span class="id">A</span> : <span class="id">set</span> (<span class="id">U</span> * <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">open_nbhs</span> <span class="id">x</span> (<span class="id">to_set</span> <span class="id">A</span> <span class="id">x</span>)^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof392')">Proof.</span></div>
<div class="proofscript" id="proof392">
<span class="id">move</span>=&gt; <span class="id">entA</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>; <span class="id">apply</span>: <span class="id">nbhs_entourage</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_close</span> (<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">y</a></span> : <span class="id">U</span>) : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">A</span> (<span class="id">x</span>, <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof393')">Proof.</span></div>
<div class="proofscript" id="proof393">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [<span class="id">cxy</span> <span class="id">A</span> <span class="id">entA</span>|<span class="id">cxy</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">entourage_split_ent</span> <span class="id">entsA</span> := <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">closeEnbhs</span> <span class="kwd">in</span> <span class="id">cxy</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">yl</span> := <span class="id">nbhs_entourage</span> <span class="id">_</span> (<span class="id">entourage_inv</span> <span class="id">entsA</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">yr</span> := <span class="id">nbhs_entourage</span> <span class="id">_</span> <span class="id">entsA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">z</span> [<span class="id">zx</span> <span class="id">zy</span>]] := <span class="id">cxy</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">yr</span> <span class="id">x</span>) (<span class="id">yl</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">entourage_split</span> <span class="id">z</span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#cvgP">rewrite</a></span> <span class="id">closeEnbhs</span> =&gt; <span class="id">A</span> <span class="id">B</span> /<span class="id">nbhsP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#cvg_close">E1</a></span> <span class="id">entE1</span> <span class="id">sE1A</span>] /<span class="id">nbhsP</span>[<span class="id">E2</span> <span class="id">entE2</span> <span class="id">sE2B</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span>;[<span class="id">apply</span>: <span class="id">sE1A</span>; <span class="id">apply</span>: <span class="id">cxy</span>|<span class="id">apply</span>: <span class="id">sE2B</span>; <span class="id"><a name="unif_continuous">apply</a></span>: <span class="id">entourage_refl</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_trans</span> (<span class="id">y</span> <span class="id">x</span> <span class="id">z</span> : <span class="id">U</span>) : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">close</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof394')">Proof.</span></div>
<div class="proofscript" id="proof394">
<span class="id">rewrite</span> !<span class="id">entourage_close</span> =&gt; <span class="id">cxy</span> <span class="id">cyz</span> <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">exact</span>: <span class="id"><a name="prod_Uniform">entourage_split</a></span> (<span class="id">cxy</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">cyz</span> <span class="id">_</span> <span class="id">_</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_cvgxx</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">U</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.V">close</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">x</a></span> <span class="id">y</span> -&gt; <span class="id">x</span> --&gt; <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof395')">Proof.</span></div>
<div class="proofscript" id="proof395">
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">cxy</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.V">P</a></span> /= /<span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">nbhsP</a></span>[<span class="id">A</span> <span class="id">entA</span> <span class="id">sAP</span>].<br/>
<span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">A</span>) =&gt; // <span class="id">z</span> <span class="id">xz</span>; <span class="id">apply</span>: <span class="id">sAP</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> <span class="id">x</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">have</span> := <span class="id">cxy</span> <span class="id">_</span> (<span class="id">entourage_inv</span> (<span class="id">entourage_split_ent</span> <span class="id">entA</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">cvg_closeP</a></span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">U</span>)) (<span class="id">l</span> : <span class="id">U</span>) : <span class="id">ProperFilter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">l</span> &lt;-&gt; ([<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">U</span>] /\ <span class="id">close</span> (<span class="id">lim</span> <span class="id">F</span>) <span class="id">l</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof396')">Proof.</span></div>
<div class="proofscript" id="proof396">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>=&gt; [<span class="id">Fl</span>|[<span class="id">cvF</span>]<span class="id">Cl</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">cvgP</span> := <span class="id">Fl</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: (@<span class="id">cvg_close</span> <span class="id">_</span> <span class="id">F</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span> (<span class="id">close_cvgxx</span> <span class="id">Cl</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">uniform_closeness</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">unif_continuous</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :=<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">xy</span> =&gt; (<span class="id">f</span> <span class="id">xy</span>.1, <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_ent">xy</a></span>.2)) @ <span class="id">entourage</span> --&gt; <span class="id">entourage</span>.<br/>
<br/>
<div class="doc">product of two uniform spaces </div>
<br/>
<span class="kwd">Section</span> <span class="id">prod_Uniform</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">U</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setMTT">V</a></span> : <span class="id">uniformType</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">A</a></span> : <span class="id">set</span> ((<span class="id">U</span> * <span class="id">V</span>) * (<span class="id">U</span> * <span class="id">V</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">prod_ent</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">A</span> : <span class="id">set</span> ((<span class="id">U</span> * <span class="id">V</span>) * (<span class="id">U</span> * <span class="id">V</span>)) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">filter_prod</span> (@<span class="id">entourage</span> <span class="id">U</span>) (@<span class="id">entourage</span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> ((<span class="id">xy</span>.1.1,<span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)) | <span class="id">xy</span> <span class="kwd">in</span> <span class="id">A</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_entP</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">U</span> * <span class="id">U</span>)) (<span class="id">B</span> : <span class="id">set</span> (<span class="id">V</span> * <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">prod_ent</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1) /\ <span class="id">B</span> (<span class="id">xy</span>.1.2, <span class="id">xy</span>.2.2)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof397')">Proof.</span></div>
<div class="proofscript" id="proof397">
<span class="id">move</span>=&gt; <span class="id">entA</span> <span class="id">entB</span>; <span class="kwd">exists</span> (<span class="id">A</span>,<span class="id">B</span>) =&gt; // <span class="id">xy</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">ABxy</a></span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> ((<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)); <span class="id">rewrite</span> /= -!<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_filter</span> : <span class="id">Filter</span> <span class="id">prod_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof398')">Proof.</span></div>
<div class="proofscript" id="proof398">
<span class="id">have</span> <span class="id">prodF</span> := <span class="id">filter_prod_filter</span> (@<span class="id">entourage_pfilter</span> <span class="id">U</span>) (@<span class="id">entourage_pfilter</span> <span class="id">V</span>).<br/>
<span class="id">split</span>; <span class="id">rewrite</span> /<span class="id">prod_ent</span>; <span class="id">last</span> 1 <span class="id">first</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> /=; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; ? [<span class="id">xy</span> /<span class="id">sAB</span> ??]; <span class="kwd">exists</span> <span class="id">xy</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setMTT</span>; <span class="id">apply</span>: <span class="id">prod_entP</span> <span class="id">filterT</span> <span class="id">filterT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> /= <span class="id">entA</span> <span class="id">entB</span>; <span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">filterI</span> <span class="id">entA</span> <span class="id">entB</span>) =&gt; <span class="id">xy</span> [].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> <span class="id">ztexy</span>] [<span class="id">zt</span>' <span class="id">Bzt</span>' <span class="id">zt</span>'<span class="id">exy</span>]; <span class="kwd">exists</span> <span class="id">zt</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#filterS">split</a></span>=&gt; //.<br/>
<span class="id">move</span>/<span class="id">eqP</span>: <span class="id">ztexy</span>; <span class="id">rewrite</span> -<span class="id">zt</span>'<span class="id">exy</span> !<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>-&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_refl</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof399')">Proof.</span></div>
<div class="proofscript" id="proof399">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">entB1</span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_ent">entB2</a></span>] <span class="id">sBA</span>] <span class="id">xy</span> /<span class="id">eqP</span>.<br/>
<span class="id">rewrite</span> [<span class="id">_</span>.1]<span class="id">surjective_pairing</span> [<span class="id">xy</span>.2]<span class="id">surjective_pairing</span> <span class="id">xpair_eqE</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">andP</span> [/<span class="id">eqP</span> <span class="id">xy1e</span> /<span class="id">eqP</span> <span class="id">xy2e</span>].<br/>
<span class="id">have</span> /<span class="id">sBA</span> : (<span class="id">B</span>.1 `*` <span class="id">B</span>.2) ((<span class="id">xy</span>.1.1, <span class="id"><a href="mathcomp.analysis.topology.html#prod_entP">xy</a></span>.2.1), (<span class="id">xy</span>.1.2, <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ent">xy</a></span>.2.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">xy1e</span> <span class="id">xy2e</span>; <span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_inv</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; <span class="id">prod_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof400')">Proof.</span></div>
<div class="proofscript" id="proof400">
<span class="id">move</span>=&gt; [<span class="id">B</span> [/<span class="id">entourage_inv</span> <span class="id">entB1</span> /<span class="id">entourage_inv</span> <span class="id">entB2</span>] <span class="id">sBA</span>].<br/>
<span class="id">have</span>:= <span class="id">prod_entP</span> <span class="id">entB1</span> <span class="id">entB2</span>; <span class="id">rewrite</span> /<span class="id">prod_ent</span>/=; <span class="id">apply</span>: <span class="id">filterS</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">p</span> /(<span class="id">sBA</span> (<span class="id">_</span>,<span class="id">_</span>)) [[<span class="id">x</span> <span class="id">y</span>] ? <span class="id">xyE</span>] &lt;-]; <span class="kwd">exists</span> (<span class="id">y</span>,<span class="id">x</span>) =&gt; //; <span class="id">move</span>/<span class="id">eqP</span>: <span class="id">xyE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> =&gt; /<span class="id">andP</span>[/<span class="id">andP</span>[/<span class="id">eqP</span>-&gt; /<span class="id">eqP</span>-&gt;] /<span class="id">andP</span>[/<span class="id">eqP</span>-&gt; /<span class="id">eqP</span>-&gt;]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_split</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">prod_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof401')">Proof.</span></div>
<div class="proofscript" id="proof401">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">entB1</span> <span class="id">entB2</span>]] <span class="id">sBA</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">split_ent</span> <span class="id">B</span>.1 (<span class="id">xy</span>.1.1,<span class="id">xy</span>.2.1) /\<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">B</span>.2 (<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">prod_entP</span>; <span class="id">apply</span>: <span class="id">entourage_split_ent</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">xy</span> [<span class="id">uv</span> /= [<span class="id">hB1xyuv1</span> <span class="id">hB2xyuv1</span>] [<span class="id">hB1xyuv2</span> <span class="id">hB2xyuv2</span>]].<br/>
<span class="id">have</span> /<span class="id">sBA</span> : (<span class="id">B</span>.1 `*` <span class="id">B</span>.2) ((<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; [<span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">uv</a></span>.1|<span class="kwd">exists</span> <span class="id">uv</span>.2].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">prod_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof402')">Proof.</span></div>
<div class="proofscript" id="proof402">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">xy</span> <span class="id">A</span>; <span class="id">split</span>=&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">B</a></span> []] | [<span class="id">B</span> [<span class="id">C</span> [<span class="id">entC1</span> <span class="id">entC2</span>] <span class="id">sCB</span>] <span class="id">sBA</span>]].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -!<span class="id">nbhs_entourageE</span> =&gt; - [<span class="id">C1</span> <span class="id">entC1</span> <span class="id">sCB1</span>] [<span class="id">C2</span> <span class="id">entC2</span> <span class="id">sCB2</span>] <span class="id">sBA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">C1</a></span> (<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1) /\ <span class="id">C2</span> (<span class="id">xy</span>.1.2, <span class="id">xy</span>.2.2)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.m">prod_entP</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">uv</span> [/= /<span class="id">sCB1</span> <span class="id">Buv1</span> /<span class="id">sCB2</span> /(<span class="id">conj</span> <span class="id">Buv1</span>) /<span class="id">sBA</span>].<br/>
<span class="kwd">exists</span> (<span class="id">to_set</span> (<span class="id">C</span>.1) (<span class="id">xy</span>.1), <span class="id">to_set</span> (<span class="id">C</span>.2) (<span class="id">xy</span>.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -!<span class="id">nbhs_entourageE</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">C</span>.1|<span class="kwd">exists</span> <span class="id">C</span>.2].<br/>
<span class="id">move</span>=&gt; <span class="id">uv</span> [/= <span class="id">Cxyuv1</span> <span class="id">Cxyuv2</span>]; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
<span class="id">have</span> /<span class="id">sCB</span> : (<span class="id">C</span>.1 `*` <span class="id">C</span>.2) ((<span class="id"><a href="mathcomp.analysis.topology.html#Filter">xy</a></span>.1,<span class="id">uv</span>.1),(<span class="id">xy</span>.2,<span class="id">uv</span>.2)) <span class="kwd">by</span> [].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Bzt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">prod_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">Uniform.Mixin</span> <span class="id">prod_ent_filter</span> <span class="id">prod_ent_refl</span> <span class="id">prod_ent_inv</span> <span class="id">prod_ent_split</span><br/>
&nbsp;&nbsp;<span class="id">prod_ent_nbhsE</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">prod_Uniform</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">prod_uniformType</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> (<span class="id">U</span> * <span class="id">V</span>) (@<span class="id">prod_uniformType_mixin</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<br/>
<div class="doc">matrices </div>
<br/>
<span class="kwd">Section</span> <span class="id">matrix_Uniform</span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) (<span class="id">T</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">A</span> : <span class="id">set</span> ('<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mx_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> : '<span class="id">I_m</span> -&gt; '<span class="id">I_n</span> -&gt; <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">entourage</span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)]<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">MN</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> (<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_filter</span> : <span class="id">Filter</span> <span class="id">mx_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof403')">Proof.</span></div>
<div class="proofscript" id="proof403">
<span class="id">apply</span>: <span class="id">filter_from_filter</span> =&gt; [|<span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">setT</span>) =&gt; <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.m">_</a></span>; <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.n">apply</a></span>: <span class="id">filterT</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">A</span> <span class="id">i</span> <span class="id">j</span> `&amp;` <span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">i</a></span> <span class="id">j</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id">ABMN</span>; <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> [] := <span class="id">ABMN</span> <span class="id">i</span> <span class="id">j</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_refl</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">MN</span> | <span class="id">MN</span>.1 = <span class="id">MN</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof404')">Proof.</span></div>
<div class="proofscript" id="proof404">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">entB</a></span> <span class="id">sBA</span>] <span class="id">MN</span> <span class="id">MN1e2</span>; <span class="id">apply</span>: <span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">MN1e2</span>; <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_inv</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; <span class="id">mx_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof405')">Proof.</span></div>
<div class="proofscript" id="proof405">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; ((<span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourageE">i</a></span> <span class="id">j</span>)^-1)%<span class="id">classic</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id">BMN</span>; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_split</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">mx_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof406')">Proof.</span></div>
<div class="proofscript" id="proof406">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>].<br/>
<span class="id">have</span> <span class="id">Bsplit</span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.T">j</a></span>, <span class="kwd">exists</span> <span class="id">C</span>, <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id"><a href="mathcomp.classical.classical_sets.html#get">C</a></span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">apply</span>/<span class="id">exists2P</span>/<span class="id">entourage_split_ex</span>.<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">MN</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) |<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">get</span> [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>]<br/>
&nbsp;&nbsp;(<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">get</span> [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>]).<br/>
<span class="id">move</span>=&gt; <span class="id">MN</span> [<span class="id">P</span> <span class="id">CMN1P</span> <span class="id">CPMN2</span>]; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="id">have</span> /<span class="id">getPex</span> [<span class="id">_</span>] := <span class="id">Bsplit</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>; <span class="kwd">exists</span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">CMN1P</span>.<br/>
<span class="id">exact</span>: <span class="id">CPMN2</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_nbhsE</span> : <span class="id">nbhs</span> = <span class="id"><a href="mathcomp.analysis.topology.html#mx_ent_inv">nbhs_</a></span> <span class="id">mx_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof407')">Proof.</span></div>
<div class="proofscript" id="proof407">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">M</span> <span class="id">A</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">B</span>]; <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; <span class="id">M_B</span> <span class="id">sBA</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span> <span class="id">sB</span> := <span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">to_set</span> <span class="id">C</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>) `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">j</a></span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> {}<span class="id">M_B</span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">sB</span> <span class="id">i</span> <span class="id">j</span> !=<span class="id">set0</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">apply</span>/<span class="id">exists2P</span>/<span class="id">M_B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">MN</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get</span> (<span class="id">sB</span> <span class="id">i</span> <span class="id">j</span>) (<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">get</span> (<span class="id">sB</span> <span class="id">i</span> <span class="id">j</span>)) =&gt; // <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">M_B</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">CMN</span>; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> /<span class="id">getPex</span> [<span class="id">_</span>] := <span class="id">M_B</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">CMN</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">C</span> <span class="id">entC</span> <span class="id">sCB</span>] <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">to_set</span> (<span class="id">C</span> <span class="id">i</span> <span class="id">j</span>) (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> (<span class="id">C</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">CMN</span>; <span class="id">apply</span>/<span class="id">sBA</span>/<span class="id">sCB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">matrix_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">Uniform.Mixin</span> <span class="id">mx_ent_filter</span> <span class="id">mx_ent_refl</span> <span class="id">mx_ent_inv</span> <span class="id">mx_ent_split</span><br/>
&nbsp;&nbsp;<span class="id">mx_ent_nbhsE</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">matrix_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">matrix_Uniform</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_mx_entourageP</span> (<span class="id">T</span> : <span class="id">uniformType</span>) <span class="id">m</span> <span class="id">n</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> '<span class="id">M</span>[<span class="id"><a name="fct_Uniform.U">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">m</a></span>,<span class="id">n</span>)))<br/>
&nbsp;&nbsp;(<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id"><a name="fct_ent">M</a></span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>,<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">n</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">M</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">N</span> \<span class="id">near</span> <span class="id">F</span>,<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">A</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>, (<span class="id">N</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>,<span class="id">n</span>)) <span class="id">i</span> <span class="id">j</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof408')">Proof.</span></div>
<div class="proofscript" id="proof408">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_fromP</a></span> =&gt; <span class="id">FM</span> <span class="id">A</span> ?; <span class="id">apply</span>: (<span class="id">FM</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">to_set</span> <span class="id">A</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>))).<br/>
<span class="id">move</span>=&gt; <span class="id">FM</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">A</span> [<span class="id">P</span> <span class="id">entP</span> <span class="id">sPA</span>]; <span class="id">near</span>=&gt; <span class="id">N</span>.<br/>
<span class="id">apply</span>: <span class="id">sPA</span> =&gt; /=; <span class="id">near</span>: <span class="id">N</span>; <span class="id">set</span> <span class="id">Q</span> := \<span class="id">bigcap_ij</span> <span class="id">P</span> <span class="id">ij</span>.1 <span class="id">ij</span>.2.<br/>
<span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">FM</span> <span class="id">Q</span> <span class="id">_</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">QN</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>: (<span class="id">QN</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">i</span>, <span class="id">j</span>)).<br/>
<span class="id">have</span> -&gt; : <span class="id">Q</span> =<br/>
&nbsp;&nbsp;\<span class="id">bigcap_</span>(<span class="id">ij</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">k</span> | <span class="id">k</span> \<span class="kwd">in</span> [<span class="id">fset</span> <span class="id">x</span> <span class="kwd">in</span> <span class="id">predT</span>]%<span class="id">fset</span>]) <span class="id">P</span> <span class="id">ij</span>.1 <span class="id"><a name="fct_ent_inv">ij</a></span>.2.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; <span class="id">Qt</span> <span class="id">ij</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Qt</span> =&gt; //=; <span class="id">rewrite</span> !<span class="id">inE</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; ??; <span class="id">apply</span>: <span class="id">entP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<div class="doc">Functional metric spaces </div>
<br/>
<span class="kwd">Section</span> <span class="id">fct_Uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;(@<span class="id">entourage</span> <span class="id">U</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">P</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_filter</span> : <span class="id">Filter</span> <span class="id">fct_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof409')">Proof.</span></div>
<div class="proofscript" id="proof409">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">first</a></span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>.<br/>
<span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">A</a></span> `&amp;` <span class="id">B</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">ABfg</span>; <span class="id">split</span>=&gt; <span class="id">t</span>; <span class="id">have</span> [] := <span class="id">ABfg</span> <span class="id">t</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_refl</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof410')">Proof.</span></div>
<div class="proofscript" id="proof410">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>] <span class="id">fg</span> <span class="id">feg</span>; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">t</span>; <span class="id">rewrite</span> <span class="id">feg</span>.<br/>
<span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_inv</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Source">fct_ent</a></span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof411')">Proof.</span></div>
<div class="proofscript" id="proof411">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">Bgf</span>; <span class="id">apply</span>/<span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_split</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">fct_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id"><a href="mathcomp.analysis.topology.html#fct_Uniform">B</a></span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof412')">Proof.</span></div>
<div class="proofscript" id="proof412">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>].<br/>
<span class="comment">(*&nbsp;have&nbsp;Bsplit&nbsp;:&nbsp;exists&nbsp;C,&nbsp;entourage&nbsp;C&nbsp;/\&nbsp;C&nbsp;\o&nbsp;C&nbsp;`&lt;=`&nbsp;B.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;exact/exists2P/entourage_split_ex.&nbsp;*)</span><br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">split_ent</span> <span class="id">B</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">B</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">fg</span> [<span class="id">h</span> <span class="id">spBfh</span> <span class="id">spBhg</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sBA</span> =&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id">entourage_split</span> (<span class="id">spBfh</span> <span class="id">t</span>) (<span class="id">spBhg</span> <span class="id">t</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformMixin</span> <span class="id">fct_ent_filter</span> <span class="id">fct_ent_refl</span> <span class="id">fct_ent_inv</span> <span class="id">fct_ent_split</span> <span class="id">erefl</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_topologicalTypeMixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfEntourageMixin</span> <span class="id">fct_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">generic_source_filter</span> := @<span class="id">Filtered.Source</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhs_</span> <span class="id">fct_ent</span>).<br/>
<span class="kwd">Canonical</span> <span class="id">fct_topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_topologicalTypeMixin</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">fct_uniformType</span> := <span class="id">UniformType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">fct_Uniform</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_fct_entourageP</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> -&gt; <span class="id">U</span>))) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">A</span> (<span class="id">f</span> <span class="id">t</span>, <span class="id">g</span> <span class="id">t</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof413')">Proof.</span></div>
<div class="proofscript" id="proof413">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">cvg_entourageP</span> <span class="id">Ff</span> <span class="id">A</span> <span class="id">entA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">Ff</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">A</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)]); <span class="kwd">exists</span> <span class="id">A</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">Ff</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">A</span> [<span class="id">P</span> <span class="id">entP</span> <span class="id"><a name="map_pair">sPA</a></span>].<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">g</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">sPA</span>; <span class="id">apply</span>: <span class="id">Ff</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage_set</span> (<span class="id">U</span> : <span class="id">uniformType</span>) (<span class="id">A</span> : <span class="id"><a name="weak_uniform.U">set</a></span> ((<span class="id">set</span> <span class="id">U</span>) * (<span class="id">set</span> <span class="id">U</span>))) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">entourage</span> <span class="id">B</span> &amp; <span class="kwd">forall</span> <span class="id">PQ</span>, <span class="id">A</span> <span class="id">PQ</span> -&gt; <span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PQ</span>.1 <span class="id">p</span> -&gt; <span class="id">PQ</span>.2 <span class="id">q</span> -&gt; <span class="id">B</span> (<span class="id">p</span>,<span class="id">q</span>).<br/>
<span class="kwd">Canonical</span> <span class="id">set_filter_source</span> (<span class="id">U</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">Filtered.Source</span> <span class="kwd">Prop</span> <span class="id">_</span> <span class="id">U</span> (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">nbhs_</span> (@<span class="id">entourage_set</span> <span class="id">U</span>) <span class="id">A</span>).<br/>
<br/>
<h1> PseudoMetric spaces defined using balls </h1>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage_</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ball</span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>') :=<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> | 0 &lt; <span class="id">x</span>] (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_E</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_refl">ball</a></span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>') :<br/>
&nbsp;&nbsp;<span class="id">entourage_</span> <span class="id">ball</span> =<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> | 0 &lt; <span class="id">x</span>] (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof414')">Proof.</span></div>
<div class="proofscript" id="proof414">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">map_pair</span> {<span class="id">S</span> <span class="id">U</span>} (<span class="id">f</span> : <span class="id">S</span> -&gt; <span class="id">U</span>) (<span class="id">x</span> : (<span class="id">S</span> * <span class="id">S</span>)) : (<span class="id">U</span> * <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;(<span class="id">f</span> <span class="id">x</span>.1, <span class="id">f</span> <span class="id">x</span>.2).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">weak_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">pS</span> : <span class="id">pointedType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>) (<span class="id">f</span> : <span class="id">pS</span> -&gt; <span class="id">U</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">S</span> := <span class="id">weak_topologicalType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">S</span> * <span class="id">S</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">U</span>) (<span class="kwd">fun</span> <span class="id">V</span> =&gt; (<span class="id">map_pair</span> <span class="id">f</span>)@^-1` <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_filter</span> : <span class="id">Filter</span> <span class="id">weak_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof415')">Proof.</span></div>
<div class="proofscript" id="proof415">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_">setT</a></span>; <span class="id"><a href="mathcomp.analysis.topology.html#weak_ent">exact</a></span>: <span class="id">entourageT</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> ??; (<span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>) =&gt; ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_refl</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">fg</a></span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof416')">Proof.</span></div>
<div class="proofscript" id="proof416">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> ? <span class="id">sBA</span>] [<span class="id">x</span> <span class="id">y</span>] /= -&gt;; <span class="id">apply</span>/<span class="id">sBA</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_inv</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; <span class="id">weak_ent</span> (<span class="id">A</span>^-1)%<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">classic</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof417')">Proof.</span></div>
<div class="proofscript" id="proof417">
<span class="id">move</span>=&gt; [<span class="id">B</span> ? <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform.U">entourage_inv</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">exact</span>/<span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_split</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">weak_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof418')">Proof.</span></div>
<div class="proofscript" id="proof418">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="id">have</span> : <span class="kwd">exists</span> <span class="id">C</span>, <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform.S">B</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">exists2P</span>/<span class="id"><a href="mathcomp.analysis.topology.html#weak_ent_filter">entourage_split_ex</a></span>.<br/>
<span class="id">case</span>=&gt; <span class="id">C</span> [<span class="id"><a href="mathcomp.analysis.topology.html#weak_ent_inv">entC</a></span> <span class="id">CsubB</span>]; <span class="kwd">exists</span> ((<span class="id">map_pair</span> <span class="id">f</span>)@^-1` <span class="id">C</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">a</a></span> ? ?]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform_mixin">sBA</a></span>/<span class="id">CsubB</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">a</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_nbhs</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">weak_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof419')">Proof.</span></div>
<div class="proofscript" id="proof419">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; [? [[<span class="id">B</span>  ? &lt;-] ? <span class="id">BsubV</span>]]; <span class="id">have</span>: <span class="id">nbhs</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">nbhsP</span> [<span class="id">W</span> ? <span class="id">WsubB</span>]; <span class="kwd">exists</span> ((<span class="id">map_pair</span> <span class="id">f</span>) @^-1` <span class="id">W</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt;??; <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.T">exact</a></span>/<span class="id">BsubV</span>/<span class="id">WsubB</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">W</span> [<span class="id">V</span>' <span class="id">entV</span>' <span class="id">V</span>'<span class="id">subW</span>] /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">have</span> : <span class="id">nbhs</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">to_set</span> <span class="id">V</span>' (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">V</span>'.<br/>
<span class="id">rewrite</span> (@<span class="id"><a name="IEnt_pointT">nbhsE</a></span> <span class="id">U</span>) =&gt; [[<span class="id">O</span> [<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.I">openU</a></span> <span class="id">Ofx</span> <span class="id">Osub</span>]]].<br/>
(<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">O</span>); <span class="id">repeat</span> <span class="id">split</span> =&gt; //); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">O</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> ? ; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.T">V</a></span>'<span class="id">subW</span>; <span class="id">exact</span>: <span class="id">Osub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_uniform_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">S</span> <span class="id">nbhs</span> <span class="id">weak_ent</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">weak_ent_filter</span> <span class="id">weak_ent_refl</span> <span class="id">weak_ent_inv</span> <span class="id">weak_ent_split</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">weak_ent_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> <span class="id">S</span> <span class="id">weak_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">weak_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sup_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">Ii</span> : <span class="kwd">Type</span>) (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id">Uniform.class_of</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">I</span> : <span class="id">choiceType</span> := <span class="id">classicType_choiceType</span> <span class="id">Ii</span>.<br/>
<span class="kwd">Let</span> <span class="id">TS</span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">Uniform.Pack</span> (<span class="id">Tc</span> <span class="id">i</span>).<br/>
<span class="kwd">Let</span> <span class="id">Tt</span> := @<span class="id">sup_topologicalType</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent">T</a></span> <span class="id">I</span> <span class="id">Tc</span>.<br/>
<span class="kwd">Let</span> <span class="id">ent_of</span> (<span class="id">p</span> : <span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) := `[&lt; @<span class="id">entourage</span> (<span class="id">TS</span> <span class="id">p</span>.1) <span class="id">p</span>.2&gt;].<br/>
<span class="kwd">Let</span> <span class="id">IEnt</span> := <span class="id">ChoiceType</span> {<span class="id">p</span> : (<span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) | <span class="id">ent_of</span> <span class="id">p</span>} (<span class="id">sig_choiceMixin</span> <span class="id">_</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">IEnt_pointT</span> (<span class="id">i</span> : <span class="id">I</span>) : <span class="id">ent_of</span> (<span class="id">i</span>, <span class="id">setT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof420')">Proof.</span></div>
<div class="proofscript" id="proof420">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">exact</span>: <span class="id">entourageT</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_ent</span> : (<span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (<span class="id">finI_from</span> [<span class="id">set</span>: <span class="id">IEnt</span>] (<span class="kwd">fun</span> <span class="id">p</span> =&gt; (<span class="id">projT1</span> <span class="id">p</span>).2)) <span class="id">id</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">IEntP</span> := <span class="id">move</span>=&gt; [[ /= + + /[<span class="id">dup</span>] /<span class="id">asboolP</span>]].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_ent_filter</span> : <span class="id">Filter</span> <span class="id">sup_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof421')">Proof.</span></div>
<div class="proofscript" id="proof421">
<span class="id">apply</span>: <span class="id">finI_filter</span>; <span class="id">move</span>=&gt; <span class="id">J</span> <span class="id">JsubEnt</span> /=; <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>).<br/>
<span class="kwd">by</span> <span class="id">IEntP</span> =&gt; <span class="id">i</span> <span class="id">b</span> /= /<span class="id">entourage_refl</span> ? ? <span class="id">_</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_refl</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof422')">Proof.</span></div>
<div class="proofscript" id="proof422">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">B</a></span> [<span class="id">F</span> ? &lt;-] <span class="id">BA</span>] [??] /= -&gt;; <span class="id">apply</span>/<span class="id">BA</span>; <span class="id">IEntP</span> =&gt; <span class="id">i</span> <span class="id">w</span> /= /<span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_inv</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">A</a></span> -&gt; <span class="id">sup_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof423')">Proof.</span></div>
<div class="proofscript" id="proof423">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">F</span> ? <span class="id">FB</span>] <span class="id">BA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">last</a></span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">BA</span>.<br/>
<span class="id">have</span> <span class="id">inv</span> : <span class="kwd">forall</span> <span class="id">ie</span> : <span class="id">IEnt</span>, <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id">ie</span>).1, ((<span class="id">projT1</span> <span class="id">ie</span>).2)^-1)%<span class="id">classic</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">IEntP</span>=&gt; ?? /<span class="id">entourage_inv</span> ??; <span class="id">exact</span>/<span class="id">asboolP</span>.<br/>
<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; @<span class="id">exist</span> (<span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) <span class="id">_</span> <span class="id">_</span> (<span class="id">inv</span> <span class="id">x</span>)) <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">imfsetP</span>; <span class="id">IEntP</span> =&gt; ???? -&gt;; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
<span class="id">rewrite</span> -<span class="id">FB</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> + <span class="id">ie</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">_</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">inv</span> <span class="id">ie</span>))) + ?; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">ie</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + /<span class="id">imfsetP</span> [<span class="id">v</span> <span class="id">vW</span> -&gt;]; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_split</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">sup_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof424')">Proof.</span></div>
<div class="proofscript" id="proof424">
<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">have</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.Tt">spt</a></span> : (<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent">ie</a></span> : <span class="id">IEnt</span>, <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id">ie</span>).1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((@<span class="id">split_ent</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">ie</span>).1) (<span class="id">projT1</span> <span class="id">ie</span>).2)))).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; [[/= ??] /<span class="id">asboolP</span>/<span class="id">entourage_split_ent</span> ?]; <span class="id">exact</span>/<span class="id">asboolP</span>.<br/>
<span class="id">pose</span> <span class="id">g</span> : (<span class="id">IEnt</span> -&gt; <span class="id">IEnt</span>) := <span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">spt</span> <span class="id">x</span>).<br/>
<span class="id">case</span> =&gt; <span class="id">W</span> [<span class="id">F</span> <span class="id">_</span> &lt;-] <span class="id">sA</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">g</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">x</a></span>)).2).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">ie</span> <span class="kwd">in</span> [<span class="id">set</span>`<span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">g</span> <span class="id">ie</span>)).2) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="id">g</span> <span class="id">ie</span>) | <span class="id">ie</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; /= ??; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">Igxy</span> <span class="id">ie</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span> =&gt; ?; <span class="id">apply</span>/(<span class="id">Igxy</span> (<span class="id">g</span> <span class="id">ie</span>))/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">ie</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">imfsetP</span> [?? -&gt;]; <span class="id">exact</span>: <span class="id">Igxy</span>.<br/>
<span class="id">case</span> =&gt; ?? [<span class="id">z</span> <span class="id">Fxz</span> <span class="id">Fzy</span>]; <span class="id">apply</span>: <span class="id">sA</span>; <span class="id">IEntP</span>=&gt; <span class="id">i</span> <span class="id">e</span> ? ? <span class="id">eF</span>.<br/>
<span class="id">apply</span>: ((@<span class="id">entourage_split</span> (<span class="id">TS</span> <span class="id">i</span>)) <span class="id">z</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">Fxz</span> <span class="id">_</span> <span class="id">eF</span>).<br/>
<span class="id">exact</span>: (<span class="id">Fzy</span> <span class="id">_</span> <span class="id">eF</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_nbhs</span> : @<span class="id">nbhs</span> <span class="id">Tt</span> <span class="id">Tt</span> = <span class="id">nbhs_</span> <span class="id">sup_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof425')">Proof.</span></div>
<div class="proofscript" id="proof425">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">nbhs_of_open</span> =&gt; [[? [[<span class="id">B</span>  + &lt;-] [<span class="id">W</span> <span class="id">BW</span> <span class="id">Wx</span>] <span class="id">BV</span>]]] =&gt; /(<span class="id">_</span> <span class="id">W</span> <span class="id">BW</span>) [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">Fsup</span> <span class="id">Weq</span>; <span class="id">move</span>: <span class="id">Weq</span> <span class="id">Wx</span> <span class="id">BW</span> =&gt; &lt;- <span class="id">Fx</span> <span class="id">BF</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span> (<span class="id">pselect</span> ([<span class="id">set</span>: <span class="id">I</span>] = <span class="id">set0</span>)) =&gt; [<span class="id">I0</span> | /<span class="id">eqP</span>/<span class="id">set0P</span> [<span class="id">i0</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> -&gt; : <span class="id">V</span> = <span class="id">setT</span>  <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: <span class="id">filterT</span>; <span class="id">exact</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">sup_ent_filter</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">subTset</span> =&gt; ??; <span class="id">apply</span>: <span class="id">BV</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> /<span class="id">Fsup</span>/<span class="id">set_mem</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">sup_subbase</a></span> <span class="id">I0</span> <span class="id">bigcup_set0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">f</span> : <span class="kwd">forall</span> <span class="id">w</span>, {<span class="id">p</span> : <span class="id">IEnt</span> |  <span class="id">w</span> \<span class="kwd">in</span> <span class="id">F</span> -&gt; <span class="id">to_set</span> ((<span class="id">projT1</span> <span class="id">p</span>).2) <span class="id">x</span> `&lt;=` <span class="id">w</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /= <span class="id">v</span>; <span class="id">apply</span>: <span class="id">cid</span>; <span class="id">case</span> (<span class="id">pselect</span> (<span class="id">v</span> \<span class="kwd">in</span> <span class="id">F</span>)); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">IEnt_pointT</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">i0</a></span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">dup</span>] /<span class="id">Fx</span> <span class="id">vx</span> /<span class="id">Fsup</span>/<span class="id">set_mem</span> [<span class="id">i</span> <span class="id">_</span>]; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">vx</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /(@<span class="id">nbhsP</span> (<span class="id">TS</span> <span class="id">i</span>)) [<span class="id">w</span> /<span class="id">asboolP</span> <span class="id">ent</span> ?]; <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">i</span>, <span class="id">w</span>) <span class="id">ent</span>).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">w</span>))).2); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">v</span> /= <span class="id">Fgw</span>; <span class="id">apply</span>: <span class="id">BV</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> /[<span class="id">dup</span>] ? /<span class="id">Fgw</span> /= /(<span class="id">projT2</span> (<span class="id">f</span> <span class="id">w</span>)); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">w</span>))).2) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">i</span>))) <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">u</span> ?; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">y</span> + <span class="id">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt;/(<span class="id">_</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">z</span>))) =&gt; + ?; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fgy</span> /<span class="id">imfsetP</span> [/= <span class="id">u</span> <span class="id">uF</span> -&gt;]; <span class="id">exact</span>: <span class="id">Fgy</span>.<br/>
<span class="id">case</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent_nbhs">E</a></span> [<span class="id">D</span> [/= <span class="id">F</span> <span class="id">FsubEnt</span> &lt;-] <span class="id">FsubE</span> <span class="id">EsubV</span>]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">filterS</a></span> <span class="id">EsubV</span>).<br/>
<span class="id">pose</span> <span class="id">f</span> : <span class="id">IEnt</span> -&gt; <span class="id">set</span> <span class="id">T</span> := <span class="kwd">fun</span> <span class="id">w</span> =&gt;<br/>
&nbsp;&nbsp;@<span class="id">interior</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">w</span>).1) (<span class="id">to_set</span> ((<span class="id">projT1</span> <span class="id">w</span>).2) (<span class="id">x</span>)).<br/>
<span class="kwd">exists</span> (\<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.TS">bigcap_</a></span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">f</span> <span class="id">w</span>); <span class="id">repeat</span> <span class="id">split</span>.<br/>
- <span class="kwd">exists</span> [<span class="id">set</span> \<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">f</span> <span class="id">w</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigcup_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; ? -&gt;; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">f</span> <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">fset</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /= ? /<span class="id">imfsetP</span> [[[/= <span class="id">i</span> <span class="id">w</span> /[<span class="id">dup</span>] /<span class="id">asboolP</span> <span class="id">entw</span> ? <span class="id">Fiw</span> -&gt;]]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">mem_set</span>; <span class="id">rewrite</span> /<span class="id">f</span> /=; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_imfset</span> <span class="id">bigcap_image</span> //=.<br/>
- <span class="kwd">by</span> <span class="id">IEntP</span>=&gt; ? ? /<span class="id">open_nbhs_entourage</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#sub_bigcap">entw</a></span> ??; <span class="id">apply</span> <span class="id">entw</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> /= <span class="id">Ifwt</span>; <span class="id">apply</span>: <span class="id">FsubE</span> =&gt; <span class="id">it</span> /<span class="id">Ifwt</span>/<span class="id">interior_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_uniform_mixin</span>:=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">Tt</span> <span class="id">nbhs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sup_ent</span> <span class="id">sup_ent_filter</span> <span class="id">sup_ent_refl</span> <span class="id">sup_ent_inv</span> <span class="id">sup_ent_split</span> <span class="id">sup_ent_nbhs</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_uniformType</span> := <span class="id">UniformType</span> <span class="id">Tt</span> <span class="id">sup_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_sup_ent</span> :<br/>
&nbsp;&nbsp;<span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>] -&gt; (<span class="kwd">forall</span> <span class="id">n</span>, <span class="id">countable_uniformity</span> (<span class="id">TS</span> <span class="id">n</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">sup_uniformType</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof426')">Proof.</span></div>
<div class="proofscript" id="proof426">
<span class="id">move</span>=&gt; <span class="id">Icnt</span> <span class="id">countable_ent</span>; <span class="id">pose</span> <span class="id">f</span> <span class="id">n</span> := <span class="id">cid</span> (<span class="id">countable_ent</span> <span class="id">n</span>).<br/>
<span class="id">pose</span> <span class="id">g</span> (<span class="id">n</span> : <span class="id">Ii</span>) : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) := <span class="id">projT1</span> (<span class="id">f</span> <span class="id">n</span>).<br/>
<span class="id"><a href="mathcomp.classical.boolp.html#asboolP">have</a></span> [<span class="id">I0</span> | /<span class="id">set0P</span> [<span class="id">i0</span> <span class="id">_</span>]] := <span class="id">eqVneq</span> [<span class="id">set</span>: <span class="id">I</span>] <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">setT</span>]; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">countable1</span>|<span class="id">move</span>=&gt; <span class="id">A</span> -&gt;; <span class="id">exact</span>: <span class="id">entourageT</span>|].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">w</span> [<span class="id">A</span> <span class="id">_</span>]] &lt;- <span class="id">subP</span>; <span class="kwd">exists</span> <span class="id">setT</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">subP</span>; <span class="id">apply</span>: <span class="id">sub_bigcap</span> =&gt; <span class="id">i</span> <span class="id">_</span> ? <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">suff</span> : [<span class="id">set</span>: <span class="id">I</span>] (<span class="id">projT1</span> <span class="id">i</span>).1 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">I0</span>.<br/>
<span class="kwd">exists</span> (<span class="id">finI_from</span> (\<span class="id">bigcup_n</span> <span class="id">g</span> <span class="id">n</span>) <span class="id">id</span>); <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#svalP">split</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">finI_from_countable</span>/<span class="id">bigcup_countable</span> =&gt; //<span class="id">i</span> <span class="id">_</span>; <span class="id">case</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">projT2</a></span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
- <span class="id">move</span>=&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">E</a></span> [<span class="id">A</span> <span class="id">AsubGn</span> <span class="id">AE</span>]; <span class="kwd">exists</span> <span class="id">E</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">h</a></span> (<span class="id">w</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) : { <span class="id">p</span> : <span class="id">IEnt</span> | <span class="id">w</span> \<span class="kwd">in</span> <span class="id">A</span> -&gt; <span class="id">w</span> = (<span class="id">projT1</span> <span class="id">p</span>).2 }.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cid</span>; <span class="id">have</span> [|] := <span class="id">boolP</span> (<span class="id">w</span> \<span class="kwd">in</span> <span class="id">A</span>); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">IEnt_pointT</span> <span class="id">i0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.ent_of">dup</a></span>] /<span class="id">AsubGn</span> /<span class="id">set_mem</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">gnw</span>] <span class="id">wA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> <span class="id">ent</span> : <span class="id">ent_of</span> (<span class="id">n</span>, <span class="id">w</span>) <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> (<span class="id">n</span>, <span class="id">w</span>) <span class="id">ent</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">have</span> [<span class="id">_</span> + <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">f</span> <span class="id">n</span>); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">sval</span> (<span class="id">h</span> <span class="id">w</span>) | <span class="id">w</span> <span class="kwd">in</span> <span class="id">A</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">AE</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">t</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">Ia</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> <span class="id">Aw</span>; <span class="id">rewrite</span> (<span class="id">svalP</span> (<span class="id">h</span> <span class="id">w</span>) <span class="id">Aw</span>); <span class="id">apply</span>/<span class="id">Ia</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; [[<span class="id">n</span> <span class="id">w</span>]] <span class="id">p</span> /<span class="id">imfsetP</span> [<span class="id">x</span> /= <span class="id">xA</span> <span class="id">M</span>]; <span class="id">apply</span>: <span class="id">Ia</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">w</span> = <span class="id">x</span>) // (<span class="id">svalP</span> (<span class="id">h</span> <span class="id">x</span>) <span class="id">xA</span>) -<span class="id">M</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">w</span>] [ <span class="id">A</span> <span class="id">_</span> <span class="id">wIA</span> <span class="id">wsubE</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">ent_Ip</span> (<span class="id">i</span> : <span class="id">IEnt</span>) : @<span class="id">entourage</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">i</span>).1) (<span class="id">projT1</span> <span class="id">i</span>).2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">exact</span>: (<span class="id">projT2</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">h</span> (<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniformType">i</a></span> : <span class="id">IEnt</span>) : {<span class="id">x</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id"><a href="mathcomp.analysis.topology.html#class">T</a></span>) | <span class="id">_</span>} := <span class="id">cid2</span> (<span class="id">and3_rec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="id">P</span> =&gt; <span class="id">P</span>) (<span class="id">projT2</span> (<span class="id">f</span> (<span class="id">projT1</span> <span class="id">i</span>).1)) (<span class="id">projT1</span> <span class="id">i</span>).2 (<span class="id">ent_Ip</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">ehi</span> (<span class="id"><a name="discrete_uniform">i</a></span> : <span class="id">IEnt</span>) : <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id">i</span>).1, <span class="id">projT1</span> (<span class="id">h</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">asboolP</span> =&gt; /=; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">have</a></span> [<span class="id">_</span> + <span class="id">_</span> ? ?] := <span class="id">projT2</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#range">f</a></span> (<span class="id">projT1</span> <span class="id">i</span>).1); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">AH</span> := [<span class="id">fset</span> <span class="id">projT1</span> (<span class="id">h</span> <span class="id">w</span>) | <span class="id">w</span> <span class="kwd">in</span> <span class="id">A</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">AH</span>]) <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">AH</span> =&gt; // <span class="id">p</span> /<span class="id">imfsetP</span> [<span class="id">i</span> <span class="id">iA</span> -&gt;]; <span class="id">rewrite</span> <span class="id">inE</span> //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">projT1</span> <span class="id">i</span>).1 =&gt; //; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">wsubE</span>; <span class="id">rewrite</span> -<span class="id">wIA</span> =&gt; ? <span class="id">It</span> <span class="id">i</span> ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [?] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>); <span class="id">apply</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#range">It</a></span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">sup_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">product_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">sup_uniformType</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">Uniform.class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_uniformType</span> (<span class="kwd">fun</span> <span class="id">f</span> : <span class="id">dep_arrow_pointedType</span> <span class="id">T</span> =&gt; <span class="id">f</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">End</span> <span class="id">product_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">discrete_uniform</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">dsc</span>: <span class="id">discrete_space</span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformType">T</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">globally</span> (<span class="id">range</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))).<br/>
<br/>
<span class="id"><a name="PseudoMetric.mixin_of">Program</a></span> <span class="kwd">Definition</span> <span class="id">discrete_uniform_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">T</span> <span class="id">nbhs</span> <span class="id">discrete_ent</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a name="PseudoMetric.ball">_</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof427')">Next Obligation.</span></div>
<div class="proofscript" id="proof427">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? + <span class="id">x</span> <span class="id">x12</span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">x</span>.1; <span class="id">rewrite</span> // {2}<span class="id">x12</span> -<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof428')">Next Obligation.</span></div>
<div class="proofscript" id="proof428">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">dA</span> <span class="id">x</span> [<span class="id">i</span> <span class="id">_</span> &lt;-]; <span class="id">apply</span>: <span class="id">dA</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof429')">Next Obligation.</span></div>
<div class="proofscript" id="proof429">
<span class="id">move</span>=&gt; ? <span class="id">dA</span>; <span class="kwd">exists</span> (<span class="id">range</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_compose_diag</span> =&gt; <span class="id">x</span> [<span class="id">i</span> <span class="id">_</span> &lt;-]; <span class="id">apply</span>: <span class="id">dA</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof430')">Next Obligation.</span></div>
<div class="proofscript" id="proof430">
<span class="id">rewrite</span> <span class="id">dsc</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span> =&gt; [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.mixin_of">Px</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.entourage">range</a></span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id">i</span> <span class="id">_</span>] [+ &lt;-] =&gt; -&gt;; <span class="id">exact</span>/<span class="id">principal_filterP</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">U</span> <span class="id">dV</span> <span class="id">UV</span>; <span class="id">apply</span>/<span class="id">principal_filterP</span>/<span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.sort">UV</a></span>/<span class="id">dV</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_uniformType</span> := <span class="id"><a name="PseudoMetric.ClassDef.cT">UniformType</a></span> <span class="id">T</span> <span class="id">discrete_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">discrete_uniform</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="PseudoMetric.clone">mixin_of</a></span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">entourage</span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Pack">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#T">set</a></span> (<span class="id">M</span> * <span class="id">M</span>))) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id">ball</span> : <span class="id">M</span> -&gt; <span class="id">R</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.class_of">M</a></span> -&gt; <span class="kwd">Prop</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_center</span> : <span class="kwd">forall</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>), 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_sym</span> : <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">e</span> : <span class="id">R</span>), <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_triangle</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">e1</span> <span class="id">e2</span>, <span class="id">ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class_of">e1</a></span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">ball</a></span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>;<br/>
&nbsp;&nbsp;<span class="id">entourageE</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">ball</span><br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Uniform.class_of</span> <span class="id">M</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">mixin_of</span> <span class="id">R</span> (<span class="id">Uniform.entourage</span> <span class="id">base</span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id">sort</span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">R</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">R</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">R</span> <span class="id">xT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">ent</span> (<span class="id">m</span> : @<span class="id">mixin_of</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.choiceType">T</a></span> <span class="id">ent</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> (<span class="id">b</span> : <span class="id">Uniform.class_of</span> <span class="id">T</span>) <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Uniform.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">m</span>'   <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id">mixin_of</span> <span class="id">R</span> <span class="id">T</span> (<span class="id">Uniform.entourage</span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">R</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Mixin">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.clone">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">type</a></span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">pseudoMetricType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> <span class="id">PseudoMetricType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">_</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">Notation</span> <span class="id">PseudoMetricMixin</span> := <span class="id">Mixin</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">pseudoMetricType</span>' <span class="id">R</span> '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" := (@<span class="id">clone</span> <span class="id">R</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">pseudoMetricType</span>'  <span class="id">R</span>  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">pseudoMetricType</span>' <span class="id">R</span> '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">R</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">pseudoMetricType</span>'  <span class="id">R</span>  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id">PseudoMetric.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">PseudoMetricUniformity</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ball_le</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>) (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m</span> : <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">PseudoMetric.mixin_of</a></span> <span class="id">R</span> <span class="id">ent</span>) :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">x</span> : <span class="id">M</span>), {<span class="id">homo</span> <span class="id">PseudoMetric.ball</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">m</a></span> <span class="id">x</span> : <span class="id">e1</span> <span class="id">e2</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetricUniformity.ball_le">e1</a></span> `&lt;=` <span class="id">e2</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof431')">Proof.</span></div>
<div class="proofscript" id="proof431">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> + <span class="id">y</span> <span class="id">xe1_y</span>.<br/>
<span class="id">rewrite</span> <span class="id">le_eqVlt</span> =&gt; /<span class="id">predU1P</span>[&lt;- //|]; <span class="id">rewrite</span> -<span class="id">subr_gt0</span> =&gt; <span class="id">lt12</span>.<br/>
<span class="id">rewrite</span> -[<span class="id">e2</span>](<span class="id">subrK</span> <span class="id">e1</span>); <span class="id">apply</span>: <span class="id">PseudoMetric.ball_triangle</span> <span class="id">xe1_y</span>.<br/>
<span class="id">suff</span> : <span class="id">PseudoMetric.ball</span> <span class="id">m</span> <span class="id">x</span> (<span class="id">PosNum</span> <span class="id">lt12</span>)%:<span class="id">num</span> <span class="id">x</span> <span class="kwd">by</span> [].<br/>
<span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>.<br/>
Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">uniformityOfBallMixin</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) (<span class="id">nbhs</span> : <span class="id">T</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">ent</span>)<br/>
&nbsp;&nbsp;(<span class="id">m</span> : <span class="id">PseudoMetric.mixin_of</span> <span class="id">R</span> <span class="id">ent</span>) : <span class="id">Uniform.mixin_of</span> <span class="id">nbhs</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformMixin</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">nbhsE</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof432')">Next Obligation.</span></div>
<div class="proofscript" id="proof432">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 1 =&gt; /=.<br/>
<span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">e1</span>] /<span class="id">posnumP</span>[<span class="id">e2</span>]; <span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">e1</span> <span class="id">e2</span>)%:<span class="id">num</span> =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">subsetI</span>; <span class="id">split</span>=&gt; ?; <span class="id">apply</span>: <span class="id">ball_le</span>;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">leEsub</span>// <span class="id">le_minl</span> <span class="id">lexx</span> ?<span class="id">orbT</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof433')">Next Obligation.</span></div>
<div class="proofscript" id="proof433">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">e</span> <span class="id">egt0</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType">sbeA</a></span>] <span class="id">xy</span> <span class="id">xey</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage_">sbeA</a></span>; <span class="id">rewrite</span> /= <span class="id">xey</span>; <span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof434')">Next Obligation.</span></div>
<div class="proofscript" id="proof434">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>) =&gt; - [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; // <span class="id">xy</span> <span class="id">xye</span>; <span class="id">apply</span>: <span class="id">sbeA</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#ball">PseudoMetric.ball_sym</a></span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof435')">Next Obligation.</span></div>
<div class="proofscript" id="proof435">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">PseudoMetric.ball</span> <span class="id">m</span> <span class="id">xy</span>.1 (<span class="id">e</span>%:<span class="id">num</span> / 2) <span class="id">xy</span>.2].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">e</span>%:<span class="id">num</span> / 2) =&gt; /=.<br/>
<span class="id">move</span>=&gt; <span class="id">xy</span> [<span class="id">z</span> <span class="id">xzhe</span> <span class="id">zyhe</span>]; <span class="id">apply</span>: <span class="id">sbeA</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">e</span>%:<span class="id">num</span>]<span class="id">splitr</span>; <span class="id">apply</span>: <span class="id">PseudoMetric.ball_triangle</span> <span class="id">zyhe</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PseudoMetricUniformity</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.ball</span> (<span class="id">PseudoMetric.class</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}<br/>
&nbsp;&nbsp;: <span class="id">entourage_</span> (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span>) = <span class="id">entourage</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof436')">Proof.</span></div>
<div class="proofscript" id="proof436">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">M</span>=&gt; [?[?[]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_from_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> : <span class="id">R</span> | 0 &lt; <span class="id">x</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">xy</a></span> | @<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]) = <span class="id">entourage</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof437')">Proof.</span></div>
<div class="proofscript" id="proof437">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} (<span class="id">M</span> : <span class="id"><a name="filter_from_ballE">pseudoMetricType</a></span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;(<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">entourage</span> [<span class="id">set</span> <span class="id">xy</span> : <span class="id">M</span> * <span class="id">M</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof438')">Proof.</span></div>
<div class="proofscript" id="proof438">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="kwd">exists</span> <span class="id">e</span>%:<span class="id">num</span> =&gt; /=. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">entourage_ball</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_ball_</span> {<span class="id">R</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_ballE">numDomainType</a></span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ball</span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>')<br/>
&nbsp;&nbsp;(<span class="id">x</span> : <span class="id">T</span>) := @<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">e</span> | <span class="id">e</span> &gt; 0] (<span class="id">ball</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :=<br/>
&nbsp;&nbsp;<span class="id">nbhs_ball_</span> (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} : (@<span class="id">nbhs_ball</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">M</a></span>) = <span class="id">nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof439')">Proof.</span></div>
<div class="proofscript" id="proof439">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">P</span>; <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbxeP</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="id">move</span>=&gt; [<span class="id">A</span> [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>] <span class="id">sAP</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; // ??; <span class="id">apply</span>/<span class="id">sAP</span>/<span class="id">sbeA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_from_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} <span class="id">x</span> :<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.R">x</a></span> : <span class="id">R</span> | 0 &lt; <span class="id">x</span>] (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span> <span class="id">x</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof440')">Proof.</span></div>
<div class="proofscript" id="proof440">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_ballE</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id">NbhsBall</span>.<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_simpl</span> := (<span class="id">nbhs_simpl</span>,@<span class="id">filter_from_ballE</span>,@<span class="id">nbhs_ballE</span>).<br/>
<span class="kwd">End</span> <span class="id">NbhsBall</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ballP</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">P</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> <span class="id">x</span> <span class="id">P</span> &lt;-&gt; <span class="id">nbhs_ball</span> <span class="id">x</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof441')">Proof.</span></div>
<div class="proofscript" id="proof441">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_center</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} (<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) (<span class="id">x</span> : <span class="id">M</span>)<br/>
&nbsp;&nbsp;(<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span>%:<span class="id">num</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof442')">Proof.</span></div>
<div class="proofscript" id="proof442">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">ball_center</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">pseudoMetricType_numDomainType</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ballxx</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof443')">Proof.</span></div>
<div class="proofscript" id="proof443">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">e_gt0</a></span>; <span class="id">apply</span>: <span class="id">ball_center</span> (<span class="id">PosNum</span> <span class="id">e_gt0</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_sym</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof444')">Proof.</span></div>
<div class="proofscript" id="proof444">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_sym</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_symE</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> = <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof445')">Proof.</span></div>
<div class="proofscript" id="proof445">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">exact</a></span>/<span class="id">ball_sym</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_triangle</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">y</a></span> <span class="id">x</span> <span class="id">z</span> : <span class="id">M</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof446')">Proof.</span></div>
<div class="proofscript" id="proof446">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_triangle</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhsx_ballx</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">eps</a></span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">nbhs</span> <span class="id">x</span> (<span class="id">ball</span> <span class="id">x</span> <span class="id">eps</span>%:<span class="id">num</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof447')">Proof.</span></div>
<div class="proofscript" id="proof447">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">nbhs_ballP</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsx_ballx">eps</a></span>%:<span class="id">num</span> =&gt; /=. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_nbhs_ball</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">open_nbhs</span> <span class="id">x</span> ((<span class="id">ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.R">eps</a></span>%:<span class="id">num</span>)^°).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof448')">Proof.</span></div>
<div class="proofscript" id="proof448">
<span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>; <span class="id">apply</span>:<span class="id">nbhsx_ballx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">le_ball</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">R</a></span>) : <span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">ball</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof449')">Proof.</span></div>
<div class="proofscript" id="proof449">
<span class="id">move</span>=&gt; <span class="id">le12</span> <span class="id">y</span>. <span class="id">case</span>: <span class="id">comparableP</span> <span class="id">le12</span> =&gt; [<span class="id">lte12</span> <span class="id">_</span>|//|//|-&gt;//].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">e2</span>](<span class="id">subrK</span> <span class="id">e1</span>); <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">ball_triangle</a></span>/<span class="id">ballxx</span>; <span class="id">rewrite</span> <span class="id">subr_gt0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">entourage_proper_filter</span> : <span class="id">ProperFilter</span> (@<span class="id">entourage</span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof450')">Proof.</span></div>
<div class="proofscript" id="proof450">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; <span class="id">A</span> [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>); <span class="id">apply</span>: <span class="id">sbeA</span>; <span class="id">apply</span>: <span class="id">ballxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">near_ball</span> (<span class="id">y</span> : <span class="id">M</span>) (<span class="id">eps</span> : {<span class="id">posnum</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">R</a></span>}) :<br/>
&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">y</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span>%:<span class="id">num</span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof451')">Proof.</span></div>
<div class="proofscript" id="proof451">
 <span class="id">exact</span>: <span class="id">nbhsx_ballx</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ballP</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">y</a></span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof452')">Proof.</span></div>
<div class="proofscript" id="proof452">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">filter_fromP</span> !<span class="id">nbhs_simpl</span> /=. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">__deprecated__cvg_ballPpos</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}, \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span>%:<span class="id"><a name="cvgi_ballP">num</a></span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof453')">Proof.</span></div>
<div class="proofscript" id="proof453">
<span class="id">split</span> =&gt; [/<span class="id">fcvg_ballP</span> + <span class="id">eps</span>|<span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">pos</a></span>]; <span class="id">first</span> <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">fcvg_ballP</span>=&gt; <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>] //.<br/>
Qed.</div>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0",<br/>
&nbsp;&nbsp;<span class="id">note</span>="<span class="id">use</span> <span class="id">a</span> <span class="id">combination</span> <span class="id">of</span> `<span class="id">cvg_ballP</span>` <span class="id">and</span> `<span class="id">posnumP</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvg_ballPpos</span> := <span class="id">__deprecated__cvg_ballPpos</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ball</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof454')">Proof.</span></div>
<div class="proofscript" id="proof454">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_ballP</span> {<span class="id">T</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof455')">Proof.</span></div>
<div class="proofscript" id="proof455">
 <span class="id">exact</span>: <span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_ball</span> {<span class="id">T</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof456')">Proof.</span></div>
<div class="proofscript" id="proof456">
 <span class="id">exact</span>: <span class="id">fcvg_ball</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_ballP</span> <span class="id">T</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id">z</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">z</span> /\ <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof457')">Proof.</span></div>
<div class="proofscript" id="proof457">
<span class="id">split</span>=&gt; [<span class="id">Fy</span> <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>] |<span class="id">Fy</span> <span class="id">P</span>] /=; <span class="id">first</span> <span class="id">exact</span>/<span class="id">Fy</span>/<span class="id">nbhsx_ballx</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">nbhs_ballP</span>[<span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">eps</span>] <span class="id">subP</span>].<br/>
<span class="id">rewrite</span> <span class="id">near_simpl</span> <span class="id">near_mapi</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<span class="id">have</span> [//|<span class="id">z</span> [<span class="id">fxz</span> <span class="id">yz</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#ball">near</a></span> (<span class="id">Fy</span> <span class="id">_</span> (<span class="id">gt0</span> <span class="id">eps</span>)) <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">subP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Definition</span> <span class="id">cvg_toi_locally</span> := @<span class="id">cvgi_ballP</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_ball</span> <span class="id">T</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType.M">eps</a></span> -&gt; <span class="id">F</span> [<span class="id">set</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">z</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">z</span> /\ <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">z</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof458')">Proof.</span></div>
<div class="proofscript" id="proof458">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">cvgi_ballP</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball_sym">pseudoMetricType_numDomainType</a></span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nbhsx_ballx</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType.R">close_refl</a></span> : <span class="id">core</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">close_cvg</span> {<span class="id">T</span>} <span class="id">F1</span> <span class="id">F2</span> {<span class="id">FF2</span>} <span class="id">_</span>.<br/>
<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> `<span class="id">cvg_ball</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">app_cvg_locally</span> := <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyr">cvg_ball</a></span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">pseudoMetricType_numFieldType</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numFieldType</span>} {<span class="id">M</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ball_splitl">pseudoMetricType</a></span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_split</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closeEnbhs">M</a></span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">x</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof459')">Proof.</span></div>
<div class="proofscript" id="proof459">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">ball_triangle</span> <span class="id">h</span> /<span class="id">h</span>; <span class="id">rewrite</span> -<span class="id">splitr</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_splitr</span> (<span class="id">z</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType">y</a></span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">x</span> -&gt; <span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof460')">Proof.</span></div>
<div class="proofscript" id="proof460">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">ball_sym</span> /<span class="id">ball_split</span>; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_splitl</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">x</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">y</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof461')">Proof.</span></div>
<div class="proofscript" id="proof461">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">move</a></span>=&gt; <span class="id">bxz</span> /<span class="id">ball_sym</span> /(<span class="id">ball_split</span> <span class="id">bxz</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_close</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = <span class="kwd">forall</span> <span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}, <span class="id">ball</span> <span class="id">x</span> <span class="id">eps</span>%:<span class="id">num</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof462')">Proof.</span></div>
<div class="proofscript" id="proof462">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [<span class="id">cxy</span> <span class="id">eps</span>|<span class="id">cxy</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> := !! <span class="id">cxy</span> <span class="id">_</span> (<span class="id">open_nbhs_ball</span> <span class="id">_</span> (<span class="id">eps</span>%:<span class="id">num</span>/2)%:<span class="id">pos</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">closureEonbhs</span>/= <span class="id">meetsC</span> <span class="id">meets_globallyr</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/(<span class="id">_</span> <span class="id">_</span> (<span class="id">open_nbhs_ball</span> <span class="id">_</span> (<span class="id">eps</span>%:<span class="id">num</span>/2)%:<span class="id">pos</span>)) =&gt; [<span class="id">z</span> [<span class="id">zx</span> <span class="id">zy</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">ball_splitl</span> <span class="id">z</span>); <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
<span class="id">rewrite</span> <span class="id">closeEnbhs</span> =&gt; <span class="id">B</span> <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e2</span> <span class="id">e2B</span>]]<br/>
&nbsp;&nbsp;/<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">e1</a></span> <span class="id">e1A</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">split</a></span>; [<span class="id">apply</span>/<span class="id">e2B</span>|<span class="id">apply</span>/<span class="id">e1A</span>; <span class="id">exact</span>: <span class="id">ballxx</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">pseudoMetricType_numFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_interior">ball_hausdorff</a></span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_eq0">R</a></span> : <span class="id">numDomainType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id">T</span> =<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">a</span> <span class="id">b</span> : <span class="id">T</span>), <span class="id">a</span> != <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">r</span> : {<span class="id">posnum</span> <span class="id">R</span>} * {<span class="id">posnum</span> <span class="id">R</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">a</span> <span class="id">r</span>.1%:<span class="id"><a href="mathcomp.analysis.topology.html#entourages.R">num</a></span> `&amp;` <span class="id">ball</span> <span class="id">b</span> <span class="id">r</span>.2%:<span class="id"><a href="mathcomp.analysis.topology.html#unif_continuous">num</a></span> == <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof463')">Proof.</span></div>
<div class="proofscript" id="proof463">
<span class="id">rewrite</span> <span class="id">propeqE</span> <span class="id">open_hausdorff</span>; <span class="id">split</span> =&gt; <span class="id">T2T</span> <span class="id">a</span> <span class="id">b</span> /<span class="id">T2T</span>[[/=]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span>; <span class="id">rewrite</span> 2!<span class="id">inE</span> =&gt; [[<span class="id">aA</span> <span class="id">bB</span>] [<span class="id">oA</span> <span class="id">oB</span> /<span class="id">eqP</span> <span class="id">ABeq0</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">r</span>] <span class="id">rA</span>]: <span class="id">nbhs</span> <span class="id">a</span> <span class="id">A</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">s</span>] <span class="id">rB</span>]: <span class="id">nbhs</span> <span class="id">b</span> <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">r</span>, <span class="id">s</span>) =&gt; /=; <span class="id">rewrite</span> (<span class="id">subsetI_eq0</span> <span class="id"><a name="countable_uniformity_metric">_</a></span> <span class="id">_</span> <span class="id">ABeq0</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">r</span> <span class="id">s</span> /<span class="id">eqP</span> <span class="id">brs_eq0</span>; <span class="kwd">exists</span> ((<span class="id">ball</span> <span class="id">a</span> <span class="id">r</span>%:<span class="id">num</span>)^°, (<span class="id">ball</span> <span class="id">b</span> <span class="id">s</span>%:<span class="id">num</span>)^°) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inE</span>; <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">nbhs_ballP</span>; <span class="id">apply</span>: <span class="id">in_filter_from</span> =&gt; /=.<br/>
<span class="id">split</span>; <span class="id">do</span> ?<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">subsetI_eq0</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_ballE">brs_eq0</a></span>)//; <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">ball_hausdorff</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">entourages</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">unif_continuousP</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">unif_continuous</span> <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">e</span> &gt; 0 -&gt; <span class="kwd">exists2</span> <span class="id"><a href="mathcomp.analysis.reals.html#lt_succ_floor">d</a></span>, <span class="id">d</span> &gt; 0 &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ball</span> <span class="id">x</span>.1 <span class="id">d</span> <span class="id">x</span>.2 -&gt; <span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>.1) <span class="id">e</span> (<span class="id">f</span> <span class="id">x</span>.2).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof464')">Proof.</span></div>
<div class="proofscript" id="proof464">
<span class="id">have</span> <span class="id">fappF</span> : <span class="id">Filter</span> ((<span class="kwd">fun</span> <span class="id">xy</span> =&gt; (<span class="id">f</span> <span class="id">xy</span>.1, <span class="id">f</span> <span class="id"><a name="matrix_PseudoMetric.m">xy</a></span>.2)) @ <span class="id">entourage_</span> <span class="id">ball</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="matrix_PseudoMetric.T">rewrite</a></span> <span class="id">entourage_ballE</span>; <span class="id">apply</span>: <span class="id">fmap_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">unif_continuous</span> -!<span class="id">entourage_ballE</span> <span class="id">filter_fromP</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">entourages</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniformity_metric</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof465')">Proof.</span></div>
<div class="proofscript" id="proof465">
<span class="id">apply</span>/<span class="id">countable_uniformityP</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">n</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> : <span class="id">T</span> * <span class="id">T</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">n</span>.+1%:<span class="id">R</span>^-1 <span class="id">xy</span>.2]); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span>; <span class="id">exact</span>: (<span class="id">entourage_ball</span> <span class="id">_</span> <span class="id">n</span>.+1%:<span class="id">R</span>^-1%:<span class="id">pos</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">E</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">e</span> <span class="id">e0</span> <span class="id">subE</span>].<br/>
<span class="kwd">exists</span> `|<span class="id">floor</span> <span class="id">e</span>^-1|%<span class="id">N</span>; <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">subE</span> =&gt; <span class="id">xy</span>; <span class="id">apply</span>: <span class="id">le_ball</span>.<br/>
<span class="id">rewrite</span> /= -[<span class="id">leRHS</span>]<span class="id">invrK</span> <span class="id">lef_pinv</span> ?<span class="id">posrE</span> ?<span class="id">invr_gt0</span>// -<span class="id">natr1</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">natr_absz</span> <span class="id">ger0_norm</span> ?<span class="id">floor_ge0</span> ?<span class="id">invr_ge0</span>// 1?<span class="id">ltW</span>// <span class="id">lt_succ_floor</span>.<br/>
Qed.</div>
<br/>
<h2> Specific pseudoMetric spaces </h2>
<br/>
<div class="doc">matrices </div>
<span class="kwd">Section</span> <span class="id">matrix_PseudoMetric</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<span class="kwd">Implicit</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_PseudoMetric.T">Types</a></span> <span class="id">x</span> <span class="id">y</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>).<br/>
<span class="kwd">Definition</span> <span class="id">mx_ball</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>) <span class="id">y</span> := <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">ball</span> (<span class="id">x</span> <span class="id">i</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#xget">j</a></span>) <span class="id">e</span> (<span class="id">y</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ball_center</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof466')">Proof.</span></div>
<div class="proofscript" id="proof466">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ???; <span class="id">apply</span>: <span class="id">ballxx</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mx_ball_sym</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">mx_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof467')">Proof.</span></div>
<div class="proofscript" id="proof467">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xe_y</span> ??; <span class="id">apply</span>/<span class="id">ball_sym</span>/<span class="id">xe_y</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#le_ball">mx_ball_triangle</a></span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">mx_ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">mx_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof468')">Proof.</span></div>
<div class="proofscript" id="proof468">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xe1_y</span> <span class="id">ye2_z</span> ??; <span class="id">apply</span>: <span class="id">ball_triangle</span>; [<span class="id">apply</span>: <span class="id">xe1_y</span>| <span class="id">apply</span>: <span class="id">ye2_z</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_entourage</span> : <span class="id">entourage</span> = <span class="id"><a href="mathcomp.analysis.topology.html#mx_entourage">entourage_</a></span> <span class="id">mx_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof469')">Proof.</span></div>
<div class="proofscript" id="proof469">
<span class="id">rewrite</span> <span class="id">predeqE</span>=&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#matrix_PseudoMetric.m">_</a></span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2]).<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; <span class="id">entP</span> <span class="id">sPA</span>.<br/>
<span class="id">set</span> <span class="id">diag</span> := <span class="kwd">fun</span> (<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) =&gt; [<span class="id">set</span> <span class="id">xy</span> : <span class="id">T</span> * <span class="id">T</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="kwd">exists</span> (\<span class="id">big</span>[<span class="id">Num.min</span>/1%:<span class="id">pos</span>]<span class="id">_i</span> \<span class="id">big</span>[<span class="id">Num.min</span>/1%:<span class="id">pos</span>]<span class="id">_j</span> <span class="id">xget</span> 1%:<span class="id">pos</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>} =&gt; <span class="id">diag</span> <span class="id">e</span> `&lt;=` <span class="id">P</span> <span class="id">i</span> <span class="id">j</span>))%:<span class="id">num</span> =&gt; //=.<br/>
<span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">MN_min</a></span>; <span class="id">apply</span>: <span class="id">sPA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="id">have</span> /(<span class="id">xgetPex</span> 1%:<span class="id">pos</span>): <span class="kwd">exists</span> <span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}, <span class="id">diag</span> <span class="id">e</span> `&lt;=` <span class="id">P</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>]] := <span class="id">entP</span> <span class="id">i</span> <span class="id"><a name="prod_ball_sym">j</a></span>; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="id">apply</span>; <span class="id">apply</span>: <span class="id">le_ball</span> (<span class="id">MN_min</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="id">apply</span>: <span class="id">le_trans</span> (@<span class="id">bigmin_le</span> <span class="id">_</span> [<span class="id">orderType</span> <span class="id">of</span> {<span class="id">posnum</span> <span class="id">R</span>}] <span class="id">_</span> <span class="id">_</span> <span class="id">i</span> <span class="id">_</span>) <span class="id"><a href="mathcomp.analysis.topology.html#ball_sym">_</a></span>.<br/>
<span class="id">exact</span>: <span class="id">bigmin_le</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">matrix_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.Mixin</span> <span class="id">mx_ball_center</span> <span class="id">mx_ball_sym</span> <span class="id">mx_ball_triangle</span> <span class="id">mx_entourage</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">matrix_pseudoMetricType_mixin</span>.<br/>
<span class="kwd">End</span> <span class="id">matrix_PseudoMetric</span>.<br/>
<br/>
<div class="doc">product of two pseudoMetric spaces </div>
<span class="kwd">Section</span> <span class="id">prod_PseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">U</span> * <span class="id">V</span>).<br/>
<span class="kwd">Definition</span> <span class="id">prod_point</span> : <span class="id">U</span> * <span class="id">V</span> := (<span class="id">point</span>, <span class="id">point</span>).<br/>
<span class="kwd">Definition</span> <span class="id">prod_ball</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) <span class="id">y</span> :=<br/>
&nbsp;&nbsp;<span class="id">ball</span> (<span class="id">fst</span> <span class="id">x</span>) <span class="id">eps</span> (<span class="id">fst</span> <span class="id">y</span>) /\ <span class="id">ball</span> (<span class="id">snd</span> <span class="id">x</span>) <span class="id">eps</span> (<span class="id">snd</span> <span class="id">y</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ball_center</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) : 0 &lt; <span class="id">eps</span> -&gt; <span class="id">prod_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof470')">Proof.</span></div>
<div class="proofscript" id="proof470">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">posnumP</span>[?]. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_ball_sym</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">eps</span> : <span class="id">R</span>) : <span class="id">prod_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">y</span> -&gt; <span class="id">prod_ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof471')">Proof.</span></div>
<div class="proofscript" id="proof471">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">bxy1</span> <span class="id">bxy2</span>]; <span class="id">split</span>; <span class="id">apply</span>: <span class="id">ball_sym</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_ball_triangle</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">prod_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">prod_ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">prod_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof472')">Proof.</span></div>
<div class="proofscript" id="proof472">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">bxy1</span> <span class="id">bxy2</span>] [<span class="id">byz1</span> <span class="id">byz2</span>]; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#Mixin">apply</a></span>: <span class="id">ball_triangle</span>; <span class="id">eassumption</span>.<br/>
Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">prod_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof473')">Proof.</span></div>
<div class="proofscript" id="proof473">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">P</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeP</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2]) =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [[<span class="id">a</span> <span class="id">b</span>] [<span class="id">c</span> <span class="id">d</span>]] [<span class="id">bab</span> <span class="id">bcd</span>]; <span class="kwd">exists</span> ((<span class="id">a</span>, <span class="id">c</span>), (<span class="id">b</span>, <span class="id">d</span>))=&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sbeP</span>.<br/>
<span class="id">move</span>=&gt; [[<span class="id">A</span> <span class="id">B</span>]] /=; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">rewrite</a></span> -!<span class="id">entourage_ballE</span>.<br/>
<span class="id">move</span>=&gt; [[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eA</span>] <span class="id"><a href="mathcomp.analysis.topology.html#Filter">sbA</a></span>] [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eB</span>] <span class="id">sbB</span>] <span class="id">sABP</span>].<br/>
<span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">eA</span> <span class="id">eB</span>)%:<span class="id">num</span> =&gt; //= -[[<span class="id">a</span> <span class="id">b</span>] [<span class="id">c</span> <span class="id">d</span>] [/= <span class="id">bac</span> <span class="id">bbd</span>]].<br/>
<span class="id">suff</span> /<span class="id">sABP</span> [] : (<span class="id">A</span> `*` <span class="id">B</span>) ((<span class="id">a</span>, <span class="id">c</span>), (<span class="id">b</span>, <span class="id">d</span>)) <span class="kwd">by</span> <span class="id">move</span>=&gt; [[??] [??]] ? [&lt;-&lt;-&lt;-&lt;-].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">split</a></span>; [<span class="id">apply</span>: <span class="id">sbA</span>|<span class="id">apply</span>: <span class="id">sbB</span>] =&gt; /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">le_ball</span> <span class="id">bac</span>; <span class="id">rewrite</span> -<span class="id">leEsub</span> <span class="id">le_minl</span> <span class="id">lexx</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">le_ball</span> <span class="id">bbd</span>; <span class="id">rewrite</span> -<span class="id">leEsub</span> <span class="id">le_minl</span> <span class="id">lexx</span> <span class="id">orbT</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">prod_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.Mixin</span> <span class="id">prod_ball_center</span> <span class="id">prod_ball_sym</span> <span class="id">prod_ball_triangle</span> <span class="id">prod_entourage</span>.<br/>
<span class="kwd">End</span> <span class="id">prod_PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">prod_pseudoMetricType</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">U</span> * <span class="id">V</span>) (@<span class="id">prod_pseudoMetricType_mixin</span> <span class="id">R</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Nbhs_fct2</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ball2P</span> {<span class="id"><a name="fct_PseudoMetric.U">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType">set</a></span> (<span class="id">set</span> <span class="id">U</span>)} {<span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">V</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id">Filter</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.T">F</a></span>} {<span class="id">FG</span> : <span class="id">Filter</span> <span class="id">G</span>} (<span class="id">y</span> : <span class="id">U</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.U">z</a></span> : <span class="id">V</span>):<br/>
&nbsp;&nbsp;(<span class="id">F</span>, <span class="id">G</span>) --&gt; (<span class="id"><a href="mathcomp.analysis.topology.html#ball">y</a></span>, <span class="id">z</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, <span class="id"><a name="fct_ball_center">eps</a></span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">z</span>' \<span class="id">near</span> <span class="id">G</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">y</span>' /\ <span class="id">ball</span> <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">z</a></span> <span class="id">eps</span> <span class="id">z</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof474')">Proof.</span></div>
<div class="proofscript" id="proof474">
 <span class="id">exact</span>: <span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.T">cvg_ball2P</a></span> {<span class="id">I</span> <span class="id">J</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">F</a></span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">I</span>)} {<span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">G</a></span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">J</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id">Filter</span> <span class="id">G</span>} (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">J</span> -&gt; <span class="id">V</span>) (<span class="id">y</span> : <span class="id">U</span>) (<span class="id">z</span> : <span class="id">V</span>):<br/>
&nbsp;&nbsp;(<span class="id">f</span> @ <span class="id">F</span>, <span class="id">g</span> @ <span class="id">G</span>) --&gt; (<span class="id">y</span>, <span class="id">z</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, <span class="id">eps</span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">i</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">j</span> \<span class="id">near</span> <span class="id">G</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id"><a href="mathcomp.analysis.topology.html#ball_triangle">f</a></span> <span class="id">i</span>) /\ <span class="id">ball</span> <span class="id">z</span> <span class="id">eps</span> (<span class="id">g</span> <span class="id">j</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof475')">Proof.</span></div>
<div class="proofscript" id="proof475">
<span class="id">rewrite</span> <span class="id">fcvg_ball2P</span>; <span class="id">split</span>=&gt; + <span class="id">e</span> <span class="id">e0</span> =&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">e</a></span> <span class="id">e0</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">near_map2</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fgyz</span>; <span class="id">rewrite</span> <span class="id">near_map2</span>; <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">apply</a></span>: <span class="id">fgyz</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Nbhs_fct2</span>.<br/>
<br/>
<div class="doc">Functional metric spaces </div>
<span class="kwd">Section</span> <span class="id">fct_PseudoMetric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id"><a href="mathcomp.analysis.signed.html#posnumP">T</a></span> : <span class="id">choiceType</span>) (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">U</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<span class="kwd">Definition</span> <span class="id">fct_ball</span> (<span class="id">x</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">eps</span> : <span class="id">R</span>) (<span class="id">y</span> : <span class="id">T</span> -&gt; <span class="id"><a name="fct_pseudoMetricType_mixin">U</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">ball</span> (<span class="id">x</span> <span class="id">t</span>) <span class="id">eps</span> (<span class="id">y</span> <span class="id">t</span>).<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_ball_center">fct_ball_center</a></span> (<span class="id">x</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof476')">Proof.</span></div>
<div class="proofscript" id="proof476">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">posnumP</span>[{}<span class="id">e</span>] ?. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ball_sym</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">fct_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof477')">Proof.</span></div>
<div class="proofscript" id="proof477">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">t</span>; <span class="id">apply</span>: <span class="id">ball_sym</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fct_ball_triangle</span> (<span class="id">x</span> <span class="id">y</span> <span class="id">z</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">fct_ball</span> <span class="id">y</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">e2</a></span> <span class="id">z</span> -&gt; <span class="id">fct_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof478')">Proof.</span></div>
<div class="proofscript" id="proof478">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xy</span> <span class="id">yz</span> <span class="id">t</span>; <span class="id">apply</span>: (@<span class="id">ball_triangle</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">y</span> <span class="id">t</span>)). Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fct_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">fct_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof479')">Proof.</span></div>
<div class="proofscript" id="proof479">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id"><a name="quotient_choice">last</a></span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">_</span>/<span class="id"><a name="quotient_open">posnumP</a></span>[<span class="id">e</span>] <span class="id">sbeP</span>] <span class="id">sPA</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span>%:<span class="id">num</span> =&gt; //= <span class="id">fg</span> <span class="id">fg_e</span>; <span class="id">apply</span>: <span class="id">sPA</span> =&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id">sbeP</span>; <span class="id">apply</span>: <span class="id">fg_e</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">fct_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricMixin</span> <span class="id">fct_ball_center</span> <span class="id">fct_ball_sym</span> <span class="id">fct_ball_triangle</span> <span class="id">fct_entourage</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">fct_pseudoMetricType</span> := <span class="id">PseudoMetricType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_pseudoMetricType_mixin</span>.<br/>
<span class="kwd">End</span> <span class="id">fct_PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">quotient_topology</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">Q</span> : <span class="id">quotType</span> <span class="id">T</span>) := <span class="id">Q</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">quotients</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">quotient_scope</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">Q0</span> : <span class="id">quotType</span> <span class="id">T</span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">Q</span> := <span class="id">quotient_topology</span> <span class="id">Q0</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_subtype</span> := [<span class="id">subType</span> <span class="id">Q</span> <span class="id">of</span> <span class="id">T</span> <span class="kwd">by</span> %/].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_eq</span> := <span class="id">EqType</span> <span class="id">Q</span> [<span class="id">eqMixin</span> <span class="id">of</span> <span class="id">Q</span> <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_choice</span> := <span class="id">ChoiceType</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuousP">Q</a></span>  [<span class="id">choiceMixin</span> <span class="id">of</span> <span class="id">Q</span> <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_pointed</span> := <span class="id">PointedType</span> <span class="id">Q</span> (\<span class="id">pi_Q</span> <span class="id">point</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">quotient_open</span> <span class="id">U</span> := <span class="id">open</span> (\<span class="id">pi_Q</span> @^-1` <span class="id">U</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">quotient_topologicalType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">topologyOfOpenMixin</span> <span class="id">Q</span> <span class="id">quotient_open</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof480')">Next Obligation.</span></div>
<div class="proofscript" id="proof480">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">quotient_open</span> <span class="id">preimage_setT</span>; <span class="id">exact</span>: <span class="id">openT</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof481')">Next Obligation.</span></div>
<div class="proofscript" id="proof481">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ?; <span class="id">exact</span>: <span class="id">openI</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof482')">Next Obligation.</span></div>
<div class="proofscript" id="proof482">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">I</span> <span class="id">f</span> <span class="id">ofi</span>; <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">i</span> <span class="id">_</span>; <span class="id">exact</span>: <span class="id">ofi</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">quotient_filtered</span> := <span class="id">Filtered.Class</span> (<span class="id">Pointed.class</span> <span class="id">quotient_pointed</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#open">nbhs_of_open</a></span> <span class="id">quotient_open</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">Q</span><br/>
&nbsp;&nbsp;(@<span class="id">Topological.Class</span> <span class="id">_</span> <span class="id">quotient_filtered</span> <span class="id">quotient_topologicalType_mixin</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">Q</span>' := <span class="id">quotient_topologicalType</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pi_continuous</span> : <span class="id">continuous</span> (\<span class="id">pi_Q</span> : <span class="id">T</span> -&gt; <span class="id">Q</span>').<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof483')">Proof.</span></div>
<div class="proofscript" id="proof483">
 <span class="id">exact</span>/<span class="id">continuousP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">quotient_continuous</span> {<span class="id">Z</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">Q</span>' -&gt; <span class="id">Z</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt; <span class="id">continuous</span> (<span class="id">f</span> \<span class="id">o</span> \<span class="id">pi_Q</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof484')">Proof.</span></div>
<div class="proofscript" id="proof484">
<span class="id">split</span> =&gt; /<span class="id">continuousP</span> /= <span class="id">cts</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">A</span> <span class="id">oA</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">cts</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">comp_preimage</span>; <span class="id">move</span>/<span class="id">continuousP</span>: <span class="id">pi_continuous</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">cts</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">repr_comp_continuous</span> (<span class="id">Z</span> : <span class="id">topologicalType</span>) (<span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">Z</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">g</span> -&gt; {<span class="id">homo</span> <span class="id">g</span> : <span class="id">a</span> <span class="id">b</span> / <span class="id">a</span> == <span class="id">b</span> %[<span class="id">mod</span> <span class="id">Q</span>] &gt;-&gt; <span class="id">a</span> == <span class="id">b</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">g</span> \<span class="id">o</span> <span class="id">repr</span> : <span class="id">Q</span>' -&gt; <span class="id">Z</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof485')">Proof.</span></div>
<div class="proofscript" id="proof485">
<span class="id">move</span>=&gt; /<span class="id">continuousP</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">ctsG</a></span> <span class="id">rgE</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">A</span> <span class="id">oA</span>.<br/>
<span class="id">rewrite</span> /<span class="id">open</span>/= /<span class="id">quotient_open</span> (<span class="id">_</span> : <span class="id">_</span> @^-1` <span class="id">_</span> = <span class="id">g</span> @^-1` <span class="id">A</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">ctsG</span>.<br/>
<span class="id">have</span> <span class="id">greprE</span> <span class="id">x</span> : <span class="id">g</span> (<span class="id">repr</span> (\<span class="id">pi_Q</span> <span class="id">x</span>)) = <span class="id">g</span> <span class="id">x</span> <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">rgE</span>// <span class="id">reprK</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span> /=; <span class="id">rewrite</span> <span class="id">greprE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">quotients</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">discrete_pseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">dsc</span> : <span class="id">discrete_space</span> <span class="id">T</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_ball</span> (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">eps</span> : <span class="id">R</span>) <span class="id">y</span> : <span class="kwd">Prop</span> := <span class="id">x</span> = <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_ball_center</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) : 0 &lt; <span class="id">eps</span> -&gt; <span class="id">discrete_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof486')">Proof.</span></div>
<div class="proofscript" id="proof486">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">discrete_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">PseudoMetric.Mixin</a></span> <span class="id">R</span> <span class="id">T</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">discrete_ent</a></span> <span class="id">discrete_ball</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof487')">Next Obligation.</span></div>
<div class="proofscript" id="proof487">
 <span class="kwd">by</span> <span class="id">done</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof488')">Next Obligation.</span></div>
<div class="proofscript" id="proof488">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? -&gt;. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof489')">Next Obligation.</span></div>
<div class="proofscript" id="proof489">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ? -&gt; -&gt;. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof490')">Next Obligation.</span></div>
<div class="proofscript" id="proof490">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">P</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">e</span> <span class="id">_</span> + [<span class="id">a</span> <span class="id">b</span>] [<span class="id">i</span> <span class="id">_</span>] [-&gt; -&gt;]; <span class="id">apply</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entP</span>; <span class="kwd">exists</span> 1 =&gt; //= <span class="id">z</span> <span class="id">z12</span>; <span class="id">apply</span>: <span class="id">entP</span>; <span class="kwd">exists</span> <span class="id">z</span>.1 =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}<span class="id">z12</span> -<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_pseudoMetricType</span> := <span class="id">PseudoMetricType</span><br/>
&nbsp;&nbsp;(@<span class="id">discrete_uniformType</span> <span class="id">_</span> <span class="id">dsc</span>) <span class="id">discrete_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">discrete_pseudoMetric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_bool</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;@<span class="id">discrete_pseudoMetricType</span> <span class="id">R</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">bool</span>] <span class="id">discrete_bool</span>.<br/>
<br/>
<h2> Complete uniform spaces </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := (<span class="id">F</span>, <span class="id">F</span>) --&gt; <span class="id">entourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_cauchy</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; <span class="id">cauchy</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof491')">Proof.</span></div>
<div class="proofscript" id="proof491">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Complete.type">FF</a></span> <span class="id">cvF</span> <span class="id">A</span> <span class="id">entA</span>; <span class="id">have</span> /<span class="id">entourage_split_ex</span> [<span class="id">B</span> <span class="id">entB</span> <span class="id">sB2A</span>] := <span class="id">entA</span>.<br/>
<span class="kwd">exists</span> (<span class="id">to_set</span> ((<span class="id">B</span>^-1)%<span class="id">classic</span>) (<span class="id">lim</span> <span class="id">F</span>), <span class="id">to_set</span> <span class="id">B</span> (<span class="id">lim</span> <span class="id">F</span>)).<br/>
&nbsp;&nbsp;<span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">cvF</span>; <span class="id">rewrite</span> /= -<span class="id">nbhs_entourageE</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span> =&gt; //; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">ab</span> [/= <span class="id">Balima</span> <span class="id">Blimb</span>]; <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class">apply</a></span>: <span class="id">sB2A</span>; <span class="kwd">exists</span> (<span class="id">lim</span> <span class="id">F</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">Complete</span>.<br/>
<span class="kwd">Definition</span> <span class="id">axiom</span> (<span class="id">T</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)), <span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; <span class="id">lim</span> <span class="id">F</span>.<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">T</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Uniform.class_of</span> <span class="id">T</span> ;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">axiom</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Complete.ClassDef.cT">Uniform.Pack</a></span> <span class="id">base</span>)<br/>
}.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.axiom</span>.<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id"><a name="Complete.Exports">Pack</a></span> { <span class="id">sort</span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Complete.mixin">type</a></span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Complete.choiceType">Pack</a></span> <span class="id">T</span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Complete.pointedType">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">b0</span> (<span class="id">m0</span> : <span class="id">axiom</span> (@<span class="id">Uniform.Pack</span> <span class="id">T</span> <span class="id">b0</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> <span class="id">b</span> <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Uniform.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">m</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> <span class="id">m0</span> =&gt; @<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a name="Complete.Exports.CompleteType">mixin</a></span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">axiom</span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">sort</a></span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">topologicalType</a></span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">completeType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completeType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id"><a name="mx_complete">_</a></span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completeType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id"><a href="mathcomp.analysis.topology.html#cvg">form_scope</a></span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completeType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completeType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id">CompleteType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_map2">_</a></span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<span class="kwd">End</span> <span class="id">Complete</span>.<br/>
<span class="kwd">Export</span> <span class="id">Complete.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">completeType1</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">completeType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof492')">Proof.</span></div>
<div class="proofscript" id="proof492">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">T</span> <span class="id">F</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_split_ent">FF</a></span> =&gt; [? [?]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_cvgP</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) : <span class="id">cauchy</span> <span class="id">F</span> &lt;-&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof493')">Proof.</span></div>
<div class="proofscript" id="proof493">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [/<span class="id">cauchy_cvg</span>|/<span class="id">cvg_cauchy</span>]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">completeType1</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">cauchy_cvg</span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>} <span class="id">_</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">cauchy_cvgP</span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">matrix_Complete</span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="id">completeType</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#CompleteType">m</a></span> <span class="id">n</span> : <span class="id">nat</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_complete</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>))) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof494')">Proof.</span></div>
<div class="proofscript" id="proof494">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#completeType">FF</a></span> <span class="id">Fc</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>) /<span class="id"><a name="fun_complete">cauchy_cvg</a></span> /<span class="id">cvg_app_entourageP</span> <span class="id">cvF</span> :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> ((<span class="kwd">fun</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) =&gt; <span class="id">M</span> <span class="id">_</span> <span class="id">_</span>) @ <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">A</span> /= <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">near_simpl</span> -<span class="id">near2E</span> <span class="id">near_map2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">apply</a></span>: <span class="id">Fc</span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">A</span>).<br/>
<span class="id">apply</span>/<span class="id">cvg_ex</span>.<br/>
<span class="id">set</span> <span class="id">Mlim</span> := \<span class="id"><a href="mathcomp.analysis.topology.html#near2E">matrix_</a></span>(<span class="id">i</span>, <span class="id">j</span>) (<span class="id">lim</span> ((<span class="kwd">fun</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) =&gt; <span class="id">M</span> <span class="id">i</span> <span class="id">j</span>) @ <span class="id">F</span>) : <span class="id">T</span>).<br/>
<span class="kwd">exists</span> <span class="id">Mlim</span>; <span class="id">apply</span>/<span class="id">cvg_mx_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span>=&gt; <span class="id">M</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">M</span>'.<br/>
<span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> (<span class="id">M</span>' <span class="id">i</span> <span class="id">j</span>) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">M</span>'; <span class="id">rewrite</span> <span class="id">mxE</span>; <span class="id">apply</span>: <span class="id">cvF</span>.<br/>
<span class="id">move</span>: (<span class="id">i</span>) (<span class="id">j</span>); <span class="id">near</span>: <span class="id">M</span>'; <span class="id">near</span>: <span class="id">M</span>; <span class="id">apply</span>: <span class="id">nearP_dep</span>; <span class="id">apply</span>: <span class="id">Fc</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; (<span class="id">split_ent</span> <span class="id">A</span>)^-1%<span class="id">classic</span>) =&gt; ?? //; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_completeType</span> := <span class="id">CompleteType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">mx_complete</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">matrix_Complete</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">fun_Complete</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">choiceType</a></span>} {<span class="id">U</span> : <span class="id">completeType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fun_complete</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> -&gt; <span class="id">U</span>)))<br/>
&nbsp;&nbsp;{<span class="id">FF</span> :  <span class="id">ProperFilter</span> <span class="id">F</span>} : <span class="id"><a href="mathcomp.analysis.topology.html#Cvg_switch.T1">cauchy</a></span> <span class="id">F</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof495')">Proof.</span></div>
<div class="proofscript" id="proof495">
<span class="id">move</span>=&gt; <span class="id">Fc</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">_</span>) /<span class="id">cauchy_cvg</span> /<span class="id">cvg_app_entourageP</span> <span class="id">cvF</span> : <span class="id">cauchy</span> (@^~<span class="id">_</span> @ <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">A</span> /= <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">near_simpl</span> -<span class="id">near2E</span> <span class="id">near_map2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Fc</span>; <span class="kwd">exists</span> <span class="id">A</span>.<br/>
<span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">cvg_ex</a></span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">t</span> =&gt; <span class="id">lim</span> (@^~<span class="id">t</span> @ <span class="id">F</span>)).<br/>
<span class="id">apply</span>/<span class="id">cvg_fct_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">f</a></span> =&gt; <span class="id">t</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">g</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">t</span>)) =&gt; //; <span class="id">first</span> <span class="kwd">by</span> <span class="id">near</span>: <span class="id">g</span>; <span class="id">apply</span>: <span class="id">cvF</span>.<br/>
<span class="id">move</span>: (<span class="id">t</span>); <span class="id">near</span>: <span class="id">g</span>; <span class="id">near</span>: <span class="id">f</span>; <span class="id">apply</span>: <span class="id">nearP_dep</span>; <span class="id">apply</span>: <span class="id">Fc</span>.<br/>
<span class="kwd">exists</span> ((<span class="id">split_ent</span> <span class="id">A</span>)^-1)%<span class="id">classic</span>=&gt; //=.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">fun_completeType</span> := <span class="id">CompleteType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fun_complete</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">fun_Complete</span>.<br/>
<br/>
<h2> Limit switching </h2>
<span class="kwd">Section</span> <span class="id">Cvg_switch</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T1</span> <span class="id">T2</span> : <span class="id">choiceType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_switch_1</span> {<span class="id">U</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> {<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>} <span class="id">F2</span> {<span class="id">FF2</span> : <span class="id">Filter</span> <span class="id">F2</span>}<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">g</a></span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) (<span class="id">l</span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F1</span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x1</span>, <span class="id">f</span> <span class="id">x1</span> @ <span class="id">F2</span> --&gt; <span class="id">h</span> <span class="id">x1</span>) -&gt; <span class="id">h</span> @ <span class="id">F1</span> --&gt; <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">g</span> @ <span class="id">F2</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof496')">Proof.</span></div>
<div class="proofscript" id="proof496">
<span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">fh</span> <span class="id">hl</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">near</span> <span class="id">F1</span> =&gt; <span class="id">x1</span>; <span class="id">near</span>=&gt; <span class="id">x2</span>; <span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">h</span> <span class="id">x1</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x1</span>; <span class="id">apply</span>/(<span class="id">hl</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">l</span>)) =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">f</a></span> <span class="id">x1</span> <span class="id">x2</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">x1</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; /=.<br/>
<span class="id">move</span>: (<span class="id">x2</span>); <span class="id">near</span>: <span class="id">x1</span>; <span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> /(<span class="id">_</span> (<span class="id">_</span>^-1%<span class="id">classic</span>)):= <span class="id">fg</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_switch_2</span> {<span class="id">U</span> : <span class="id">completeType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> {<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>} <span class="id">F2</span> {<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">FF2</a></span> : <span class="id">ProperFilter</span> <span class="id">F2</span>}<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F1</span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">x</span> @ <span class="id">F2</span> --&gt; <span class="id">h</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">h</span> @ <span class="id">F1</span> <span class="kwd">in</span> <span class="id">U</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof497')">Proof.</span></div>
<div class="proofscript" id="proof497">
<span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">fh</span>; <span class="id">apply</span>: <span class="id">cauchy_cvg</span> =&gt; <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">rewrite</span> !<span class="id">near_simpl</span> -<span class="id">near2_pair</span> <span class="id">near_map2</span>; <span class="id">near</span>=&gt; <span class="id">x1</span> <span class="id">y1</span> =&gt; /=; <span class="id">near</span> <span class="id">F2</span> =&gt; <span class="id">x2</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x1</span> <span class="id">x2</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">y1</span> <span class="id">x2</span>)) =&gt; //; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">_</span> (<span class="id">to_set</span> ((<span class="id">_</span>^-1)%<span class="id">classic</span>) <span class="id">_</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">nbhs_entourage</span> (<span class="id">entourage_inv</span> <span class="id">_</span>).<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">x2</span>)) =&gt; //; <span class="id">move</span>: (<span class="id">x2</span>); [<span class="id">near</span>: <span class="id">x1</span>|<span class="id">near</span>: <span class="id">y1</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> /(<span class="id">_</span> (<span class="id">_</span>^-1)%<span class="id">classic</span>) := <span class="id">fg</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> := <span class="id">fg</span>; <span class="id">apply</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_switch</span> {<span class="id">U</span> : <span class="id">completeType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> (<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>) <span class="id">F2</span> (<span class="id">FF2</span> : <span class="id">ProperFilter</span> <span class="id">F2</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#entourage_ball">f</a></span> @ <span class="id">F1</span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x1</span>, <span class="id">f</span> <span class="id">x1</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#entourage_ballE">F2</a></span> --&gt; <span class="id">h</span> <span class="id">x1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">l</span> : <span class="id">U</span>, <span class="id">h</span> @ <span class="id">F1</span> --&gt; <span class="id">l</span> /\ <span class="id">g</span> @ <span class="id">F2</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof498')">Proof.</span></div>
<div class="proofscript" id="proof498">
<span class="id">move</span>=&gt; <span class="id">Hfg</span> <span class="id">Hfh</span>; <span class="id">have</span> <span class="id">hcv</span> := !! <span class="id">cvg_switch_2</span> <span class="id">Hfg</span> <span class="id">Hfh</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">lim</span> <span class="id">h</span> @ <span class="id">F1</span> <span class="kwd">in</span> <span class="id">U</span>]; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">cvg_switch_1</span> <span class="id">Hfg</span> <span class="id">Hfh</span> <span class="id">hcv</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Cvg_switch</span>.<br/>
<br/>
<h2> Complete pseudoMetric spaces </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy_ex</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">F</span> (<span class="id">ball</span> <span class="id">x</span> <span class="id">eps</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">e</span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">x</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_ballP</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">T</span>  : <span class="id">pseudoMetricType</span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy_ball</span> <span class="id">F</span> &lt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">cauchy</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof499')">Proof.</span></div>
<div class="proofscript" id="proof499">
<span class="id">split</span>=&gt; <span class="id">cauchyF</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>]; <span class="id">apply</span>/<span class="id">cauchyF</span>/<span class="id">entourage_ball</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; - [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#entourage_ball">eps</a></span>] <span class="id">xyepsU</span>].<br/>
<span class="kwd">by</span> <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">xyepsU</span>; <span class="id">apply</span>: <span class="id">cauchyF</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchy_ballP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_exP</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy_ex</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof500')">Proof.</span></div>
<div class="proofscript" id="proof500">
<span class="id">move</span>=&gt; <span class="id">Fc</span> <span class="id">A</span>; <span class="id">rewrite</span> !<span class="id">nbhs_simpl</span> /= -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">_</span>/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">posnumP</a></span>[<span class="id">e</span>] <span class="id">sdeA</span>].<br/>
<span class="id">have</span> /<span class="id">Fc</span> [<span class="id">z</span> /= <span class="id">Fze</span>] := [<span class="id">gt0</span> <span class="id">of</span> <span class="id">e</span>%:<span class="id">num</span> / 2]; <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">y</span>; <span class="id">apply</span>: <span class="id">sdeA</span> =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">apply</a></span>: (@<span class="id">ball_splitr</span> <span class="id">_</span> <span class="id">_</span> <span class="id">z</span>); [<span class="id">near</span>: <span class="id">x</span>|<span class="id">near</span>: <span class="id">y</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchy_exP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchyP</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">R</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> <span class="id">F</span> &lt;-&gt; <span class="id">cauchy_ex</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof501')">Proof.</span></div>
<div class="proofscript" id="proof501">
<span class="id">split</span>=&gt; [<span class="id">Fcauchy</span> <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] |/<span class="id">cauchy_exP</span>//].<br/>
<span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: (@<span class="id">nearP_dep</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F</span> <span class="id">F</span>).<br/>
<span class="id">exact</span>/<span class="id">Fcauchy</span>/<span class="id"><a name="CompletePseudoMetric.base">entourage_ball</a></span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchyP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">PF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.base">compact_cauchy_cvg</a></span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id"><a name="CompletePseudoMetric.base2">T</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">U</span> -&gt; <span class="id">compact</span> <span class="id">U</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof502')">Proof.</span></div>
<div class="proofscript" id="proof502">
<span class="id">move</span>=&gt; <span class="id">PF</span> <span class="id">cf</span> <span class="id">FU</span> /(<span class="id">_</span> <span class="id">F</span> <span class="id">PF</span> <span class="id">FU</span>) [<span class="id">x</span> [<span class="id">_</span> <span class="id">clFx</span>]]; <span class="id">apply</span>: (<span class="id"><a name="CompletePseudoMetric.sort">cvgP</a></span> <span class="id">x</span>).<br/>
<span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.sort">E</a></span> <span class="id">entE</span>.<br/>
<span class="id">have</span> : <span class="id">nbhs</span> <span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="kwd">by</span> <span class="id"><a name="CompletePseudoMetric.ClassDef.T">rewrite</a></span> <span class="id">nbhs_filterE</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">cf</span> (<span class="id">split_ent</span> <span class="id">E</span>))[] [<span class="id">D1</span> <span class="id">D2</span>]/= /[!<span class="id">nbhs_simpl</span>] -[<span class="id">FD1</span> <span class="id">FD2</span> <span class="id">D1D2E</span>].<br/>
<span class="id">have</span> : <span class="id">nbhs</span> <span class="id">x</span> <span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">nbhs_entourage</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">clFx</span> <span class="id">_</span> (<span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span>) <span class="id">FD1</span>)[<span class="id">z</span> [<span class="id">Dz</span> <span class="id">Exz</span>]].<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">t</span>; <span class="id">apply</span>/(<span class="id">entourage_split</span> <span class="id">z</span> <span class="id">entE</span> <span class="id">Exz</span>)/<span class="id">D1D2E</span>; <span class="id">split</span> =&gt; //; <span class="id">near</span>: <span class="id">t</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">CompletePseudoMetric</span>.<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">T</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">Complete.axiom</span> (<span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.xclass">Uniform.Pack</a></span> <span class="id">base</span>)<br/>
}.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">PseudoMetric.class_of</span>.<br/>
<span class="kwd">Definition</span> <span class="id">base2</span> <span class="id">T</span> <span class="id">m</span> := <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.cT">Complete.Class</a></span> (@<span class="id">mixin</span> <span class="id">T</span> <span class="id">m</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base2</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.class_of</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.cT">sort</a></span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Pack">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.R">class</a></span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.xclass">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef">Pack</a></span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> <span class="id">b</span> &amp; <span class="id">phant_id</span> (@<span class="id">PseudoMetric.class</span> <span class="id">R</span> <span class="id">bT</span>) (<span class="id">b</span> : <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">mT</span> <span class="id">m</span> &amp; <span class="id">phant_id</span> (<span class="id">Complete.class</span> <span class="id">mT</span>) (@<span class="id">Complete.Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id">Pack</span> (@<span class="kwd">Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">completeType</span> := @<span class="id">Complete.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetricType</span> := @<span class="id">PseudoMetric.Pack</span> <span class="id">R</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_completeType</span> := @<span class="id">Complete.Pack</span> <span class="id">pseudoMetricType</span> <span class="id">xclass</span>.<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">PseudoMetric.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.axiom</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base2</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.Exports">type</a></span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">completeType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Complete.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">completeType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pseudoMetricType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">PseudoMetric.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_completeType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">completePseudoMetricType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completePseudoMetricType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completePseudoMetricType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completePseudoMetricType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completePseudoMetricType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id">CompletePseudoMetricType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">_</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>).<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<span class="kwd">End</span> <span class="id">CompletePseudoMetric</span>.<br/>
<span class="kwd">Export</span> <span class="id">CompletePseudoMetric.Exports</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_completePseudoMetricType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">T</span> : <span class="id">completePseudoMetricType</span> <span class="id">R</span>) (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id">CompletePseudoMetricType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">mx_complete</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_completePseudoMetricType</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">R</span> : <span class="id">numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">U</span> : <span class="id">completePseudoMetricType</span> <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="id">CompletePseudoMetricType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fun_complete</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="ball_filter">pointed_of_zmodule</a></span> (<span class="id">R</span> : <span class="id">zmodType</span>) : <span class="id">pointedType</span> := <span class="id">PointedType</span> <span class="id">R</span> 0.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ball_</span><br/>
&nbsp;&nbsp;(<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">V</span> : <span class="id">zmodType</span>) (<span class="id">norm</span> : <span class="id">V</span> -&gt; <span class="id">R</span>) (<span class="id">x</span> : <span class="id">V</span>) (<span class="id">e</span> : <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">y</span> | <span class="id">norm</span> (<span class="id">x</span> - <span class="id">y</span>) &lt; <span class="id">e</span>].<br/>
<span class="kwd">Arguments</span> <span class="id">ball_</span> {<span class="id">R</span>} {<span class="id">V</span>} <span class="id">norm</span> <span class="id">x</span> <span class="id">e</span>%<span class="id">R</span> <span class="id">y</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_ball_prop_in_itv</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">x</span> : <span class="id">R</span>) <span class="id">e</span> <span class="id">P</span> :<br/>
&nbsp;&nbsp;(<span class="id">ball_</span> <span class="id">Num.Def.normr</span> <span class="id">x</span> <span class="id">e</span> `&lt;=` <span class="id">P</span>)%<span class="id">classic</span> &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> `](<span class="id">x</span> - <span class="id">e</span>), (<span class="id">x</span> + <span class="id">e</span>)[, <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">y</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof503')">Proof.</span></div>
<div class="proofscript" id="proof503">
<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">exP</span> <span class="id">y</span> /=; <span class="id">rewrite</span> ?<span class="id">in_itv</span> (<span class="id">ltr_distlC</span>, =^~<span class="id">ltr_distlC</span>); <span class="id">apply</span>: <span class="id">exP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_ball_prop_in_itvcc</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">x</span> : <span class="id">R</span>) <span class="id">e</span> <span class="id">P</span> : 0 &lt; <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">ball_</span> <span class="id">Num.Def.normr</span> <span class="id">x</span> (2 * <span class="id">e</span>) `&lt;=` <span class="id">P</span>)%<span class="id">classic</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> `[(<span class="id">x</span> - <span class="id">e</span>), (<span class="id">x</span> + <span class="id">e</span>)], <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">y</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof504')">Proof.</span></div>
<div class="proofscript" id="proof504">
<span class="id">move</span>=&gt; <span class="id">e_gt0</span> <span class="id">PP</span> <span class="id">y</span>; <span class="id">rewrite</span> <span class="id">in_itv</span>/= -<span class="id">ler_distlC</span> =&gt; <span class="id">ye</span>; <span class="id">apply</span>: <span class="id">PP</span> =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">le_lt_trans</span> <span class="id">ye</span>)// <span class="id">ltr_pmull</span>// <span class="id">ltr1n</span>.<br/>
Qed.</div>
<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#pointed_of_zmodule">Global</a></span> <span class="kwd">Instance</span> <span class="id">ball_filter</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">t</span> : <span class="id">R</span>) : <span class="id">Filter</span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | <span class="kwd">exists2</span> <span class="id">i</span> : <span class="id">R</span>, 0 &lt; <span class="id">i</span> &amp; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">t</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof505')">Proof.</span></div>
<div class="proofscript" id="proof505">
<span class="id">apply</span>: <span class="id">Build_Filter</span>; [<span class="kwd">by</span> <span class="kwd">exists</span> 1 | <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> | <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetric_of_normedDomain.K">PQ</a></span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#ball_">mkset</a></span>.<br/>
- <span class="id">move</span>=&gt; -[<span class="id">x</span> <span class="id">x0</span> <span class="id">xP</span>] [<span class="id">y</span> ? <span class="id">yQ</span>]; <span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">x</span> <span class="id">y</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">lt_minr</span> <span class="id">x0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">tz</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">xP</span>; <span class="id">rewrite</span> /= (<span class="id">lt_le_trans</span> <span class="id">tz</span>) // <span class="id">le_minl</span> <span class="id">lexx</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">yQ</span>; <span class="id">rewrite</span> /= (<span class="id">lt_le_trans</span> <span class="id">tz</span>) // <span class="id">le_minl</span> <span class="id">lexx</span> <span class="id">orbT</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; -[<span class="id"><a href="mathcomp.analysis.topology.html#ball_">x</a></span> ? <span class="id">xP</span>]; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#ball_">apply</a></span>: (<span class="id">subset_trans</span> <span class="id">xP</span>).<br/>
Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">Filter</span> [<span class="id">set</span> <span class="id">P</span> | <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id">_</span> &amp; <span class="id">ball_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>]) =&gt;<br/>
&nbsp;&nbsp;(<span class="id">apply</span>: <span class="id">ball_filter</span>) : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">filtered_of_normedZmod</span> (<span class="id">K</span> : <span class="id">numDomainType</span>) (<span class="id">R</span> : <span class="id">normedZmodType</span> <span class="id">K</span>)<br/>
&nbsp;&nbsp;: <span class="id">filteredType</span> <span class="id">R</span> := <span class="id">Filtered.Pack</span> (<span class="id">Filtered.Class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">Pointed.class</span> (<span class="id">pointed_of_zmodule</span> <span class="id">R</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#ball_norm_center">nbhs_ball_</a></span> (<span class="id">ball_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; `|<span class="id">x</span>|)))).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">pseudoMetric_of_normedDomain</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">K</span> : <span class="id">numDomainType</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#ball_">R</a></span> : <span class="id">normedZmodType</span> <span class="id">K</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">ball_norm_center</span> (<span class="id">x</span> : <span class="id">R</span>) (<span class="id">e</span> : <span class="id">K</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof506')">Proof.</span></div>
<div class="proofscript" id="proof506">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /=; <span class="id">rewrite</span> <span class="id">subrr</span> <span class="id">normr0</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">ball_norm_symmetric</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">R</span>) (<span class="id">e</span> : <span class="id">K</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof507')">Proof.</span></div>
<div class="proofscript" id="proof507">
 <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">distrC</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">ball_norm_triangle</span> (<span class="id">x</span> <span class="id">y</span> <span class="id">z</span> : <span class="id">R</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id"><a name="regular_topology">K</a></span>) :<br/>
&nbsp;&nbsp;<span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e1</span> <span class="id"><a name="regular_topology.regular_topology">y</a></span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof508')">Proof.</span></div>
<div class="proofscript" id="proof508">
<span class="id">move</span>=&gt; /= ? ?; <span class="id">rewrite</span> -(<span class="id">subr0</span> <span class="id">x</span>) -(<span class="id">subrr</span> <span class="id">y</span>) <span class="id">opprD</span> <span class="id">opprK</span> (<span class="id">addrA</span> <span class="id">x</span> <span class="id">_</span> <span class="id">y</span>) -<span class="id">addrA</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">ler_norm_add</span> <span class="id">_</span> <span class="id">_</span>)) // <span class="id">ltr_add</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_of_normedDomain</span><br/>
&nbsp;&nbsp;: <span class="id">PseudoMetric.mixin_of</span> <span class="id">K</span> (@<span class="id">entourage_</span> <span class="id">K</span> <span class="id">R</span> <span class="id">R</span> (<span class="id">ball_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; `|<span class="id">x</span>|)))<br/>
&nbsp;&nbsp;:= <span class="id">PseudoMetricMixin</span> <span class="id">ball_norm_center</span> <span class="id">ball_norm_symmetric</span> <span class="id">ball_norm_triangle</span> <span class="id">erefl</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ball_normE</span> :<br/>
&nbsp;&nbsp;@<span class="id">nbhs_ball_</span> <span class="id">K</span> <span class="id">R</span> <span class="id">R</span> (<span class="id">ball_</span> <span class="id">Num.norm</span>) = <span class="id">nbhs_</span> (<span class="id">entourage_</span> (<span class="id">ball_</span> <span class="id">Num.norm</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof509')">Proof.</span></div>
<div class="proofscript" id="proof509">
<span class="id">rewrite</span> /<span class="id">nbhs_</span> <span class="id">entourage_E</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">A</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2] =&gt; //; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">E</span> [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeE</span>] <span class="id">sEA</span>]; <span class="kwd">exists</span> <span class="id">e</span> =&gt; // ??; <span class="id">apply</span>/<span class="id">sEA</span>/<span class="id">sbeE</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">pseudoMetric_of_normedDomain</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">regular_topology</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">regular_topology</span>.<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">pointedType</span> (<span class="id">R</span> : <span class="id">zmodType</span>) : <span class="id">pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span> <span class="kwd">for</span> <span class="id">pointed_of_zmodule</span> <span class="id">R</span>].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">filteredType</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) : <span class="id">filteredType</span> <span class="id">R</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span> <span class="kwd">for</span> <span class="id">filtered_of_normedZmod</span> <span class="id">R</span>].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">topologicalType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) : <span class="id">topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">R</span>^<span class="id">o</span> (<span class="id">topologyOfEntourageMixin</span> (<span class="id">uniformityOfBallMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">nbhs_ball_normE</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realType.R">pseudoMetric_of_normedDomain</a></span> <span class="id">_</span>))).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">uniformType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) : <span class="id">uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> <span class="id">R</span>^<span class="id">o</span> (<span class="id">uniformityOfBallMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">nbhs_ball_normE</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realType.R">_</a></span>) (<span class="id">pseudoMetric_of_normedDomain</span> <span class="id">_</span>)).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">R</span>^<span class="id">o</span> (@<span class="id">pseudoMetric_of_normedDomain</span> <span class="id">R</span> <span class="id">R</span>).<br/>
<span class="kwd">End</span> <span class="id">regular_topology</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">regular_topology</span>.<br/>
<span class="kwd">Export</span> <span class="id">regular_topology.Exports</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">numFieldTopology</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.rcfType.R">realType</a></span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_pointedType</span> := [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.rcfType.R">filteredType</a></span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">real_uniformType</a></span> := [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">realType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">rcfType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">rcfType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_pointedType</span> := [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">of</a></span> <span class="id">R</span>^<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">o</a></span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_uniformType</span> := [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realFieldType.R">of</a></span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">rcfType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">archiFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">archiFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id"><a name="numFieldTopology.realField_uniformType">R</a></span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id"><a name="numFieldTopology.realField_pseudoMetricType">R</a></span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id"><a name="numFieldTopology.pointed_latticeType">of</a></span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realField_pointedType">Local</a></span> <span class="kwd">Canonical</span> <span class="id">archiField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">archiFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">realFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id"><a name="numFieldTopology.filtered_distrLatticeType">R</a></span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realField_filteredType">filteredType</a></span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_orderType</span> := [<span class="id"><a name="numFieldTopology.uniform_latticeType">orderType</a></span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id"><a name="numFieldTopology.pseudoMetric_distrLatticeType">realDomainType</a></span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_latticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">latticeType</span> <span class="id"><a name="numFieldTopology.pseudoMetric_orderType">of</a></span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_realDomainType</span> := [<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_latticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">realFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">numClosedFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="numFieldTopology.filtered_closedFieldType">R</a></span> : <span class="id">numClosedFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numClosedField_uniformType">R</a></span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_decFieldType</span> := [<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">numClosedFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">numFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">numFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a name="numFieldTopology.pointed_numDomainType">numField_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_filteredType">numField_pseudoMetricType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_comUnitRingType</span> := [<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_topologicalType">of</a></span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.topological_fieldType">filtered_comUnitRingType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_unitRingType">topological_ringType</a></span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_comUnitRingType">topological_comRingType</a></span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_idomainType">topological_unitRingType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_comUnitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">topological_numDomainType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">uniform_ringType</a></span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">of</a></span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_comUnitRingType</span> := [<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.pseudoMetric_porderType">uniform_idomainType</a></span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_comRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comRingType</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.real_filteredType">numField_pseudoMetricType</a></span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_unitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_comUnitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_idomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_numDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">numFieldType</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_pointedType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_filteredType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_topologicalType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_uniformType</span> : <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiField_filteredType">realType</a></span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_pseudoMetricType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_pointedType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_filteredType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_topologicalType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_uniformType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_pseudoMetricType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_pointedType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_filteredType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_topologicalType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_uniformType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_pseudoMetricType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_realDomainType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_pointedType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_filteredType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_topologicalType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_uniformType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_pseudoMetricType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_closedFieldType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_pointedType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_filteredType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_topologicalType</span> :<br/>
&nbsp;&nbsp;<span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_uniformType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_pseudoMetricType</span> :<br/>
&nbsp;&nbsp;<span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_numDomainType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_pointedType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_filteredType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_topologicalType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_uniformType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_pseudoMetricType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">numFieldTopology</span>.<br/>
<span class="kwd">Import</span> <span class="id">numFieldTopology.Exports</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">Proper_dnbhs_regular_numFieldType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">x</span> : <span class="id">R</span>^<span class="id">o</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof510')">Proof.</span></div>
<div class="proofscript" id="proof510">
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.V">Build_ProperFilter</a></span> =&gt; <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">Ae</span>].<br/>
<span class="kwd">exists</span> (<span class="id">x</span> + <span class="id">e</span>%:<span class="id">num</span> / 2)%<span class="id">R</span>; <span class="id">apply</span>: <span class="id">Ae</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eq_sym</span> <span class="id">addrC</span> -<span class="id">subr_eq</span> <span class="id">subrr</span> <span class="id">eq_sym</span>.<br/>
<span class="id">rewrite</span> /<span class="id">ball</span> /= <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.V">opprD</a></span> <span class="id">addrA</span> <span class="id">subrr</span> <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.A">distrC</a></span> <span class="id">subr0</span> <span class="id">ger0_norm</span> //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}(<span class="id">splitr</span> <span class="id">e</span>%:<span class="id">num</span>) <span class="id">ltr_spaddl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">Rhausdorff</span> (<span class="id">R</span> : <span class="id">realFieldType</span>) : <span class="id">hausdorff_space</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof511')">Proof.</span></div>
<div class="proofscript" id="proof511">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">clxy</span>; <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">eq_le</span>.<br/>
<span class="id">apply</span>/<span class="id">in_segment_addgt0Pr</span> =&gt; <span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">e</span>].<br/>
<span class="id">rewrite</span> <span class="id">in_itv</span> /= -<span class="id">ler_distl</span>; <span class="id"><a href="mathcomp.analysis.topology.html#fct_RestrictedUniformTopology">set</a></span> <span class="id">he</span> := (<span class="id">e</span>%:<span class="id">num</span> / 2)%:<span class="id">pos</span>.<br/>
<span class="id">have</span> [<span class="id">z</span> [<span class="id">zx_he</span> <span class="id">yz_he</span>]] := <span class="id">clxy</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhsx_ballx</span> <span class="id">x</span> <span class="id">he</span>) (<span class="id">nbhsx_ballx</span> <span class="id">y</span> <span class="id">he</span>).<br/>
<span class="id">have</span> := <span class="id">ball_triangle</span> <span class="id">yz_he</span> (<span class="id">ball_sym</span> <span class="id">zx_he</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">mulr2n</span> -<span class="id">mulr_natr</span> <span class="id">divfK</span> // =&gt; /<span class="id">ltW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">RestrictedUniformTopology</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">choiceType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) {<span class="id">V</span> : <span class="id">uniformType</span>} .<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_RestrictedUniform</span> := <span class="kwd">let</span> <span class="id">_</span> := <span class="id">A</span> <span class="kwd">in</span> <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<span class="kwd">Definition</span> <span class="id">fct_RestrictedUniformTopology</span> :=<br/>
&nbsp;&nbsp;@<span class="id">weak_uniformType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;([<span class="id">pointedType</span> <span class="id">of</span> @<span class="id">fct_RestrictedUniform</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fct_uniformType</span> [<span class="id">choiceType</span> <span class="id">of</span> { <span class="id">x</span> : <span class="id">U</span> | <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> }] <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">sigL</span> <span class="id">U</span> <span class="id">V</span> <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_RestrictUniformFilteredType</span>:=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">fct_RestrictedUniform</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.A">fct_RestrictedUniformTopology</a></span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_RestrictUniformTopologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span> <span class="id">fct_RestrictedUniformTopology</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_restrictedUniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span> <span class="id">fct_RestrictedUniformTopology</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_nbhs</span> (<span class="id">f</span> : <span class="id">fct_RestrictedUniformTopology</span>) <span class="id">P</span>:<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> <span class="id">f</span> <span class="id">P</span> &lt;-&gt; (<span class="kwd">exists</span> <span class="id">E</span>, <span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_restrictedUniformType">E</a></span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">y</a></span> -&gt; <span class="id">E</span>(<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)] `&lt;=` <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof512')">Proof.</span></div>
<div class="proofscript" id="proof512">
<span class="id">split</span>=&gt; [[<span class="id">Q</span> [[/= <span class="id">W</span> <span class="id">oW</span> &lt;- /=] <span class="id">Wf</span> <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.U">subP</a></span>]]|[<span class="id">E</span> [<span class="id">entE</span> <span class="id">subP</span>]]].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">openE</span> /= /<span class="id">interior</span> <span class="kwd">in</span> <span class="id">oW</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">oW</span> <span class="id">_</span> <span class="id">Wf</span>) =&gt; ? [ /= <span class="id">E</span> <span class="id">entE</span>] <span class="id">Esub</span> <span class="id">subW</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; // <span class="id">h</span> <span class="id">Eh</span>; <span class="id">apply</span>/<span class="id">subP</span>/<span class="id">subW</span>/<span class="id">Esub</span> =&gt; /= [[<span class="id">u</span> <span class="id">Au</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Eh</span> =&gt; /=; <span class="id">rewrite</span> -<span class="id">inE</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">subP</span> =&gt; <span class="id">y</span> /<span class="id">mem_set</span> <span class="id">Ay</span>; <span class="id">rewrite</span> -!(<span class="id">sigLE</span> <span class="id">A</span>).<br/>
<span class="id">move</span>: (<span class="id">SigSub</span> <span class="id">_</span>); <span class="id">near</span>: <span class="id">g</span>.<br/>
<span class="id">have</span> := (@<span class="id">cvg_image</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">sigL</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#mem_set">A</a></span>) <span class="id">_</span> <span class="id">f</span> (<span class="id">nbhs_filter</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;(<span class="id">image_sigL</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">point</a></span>)).1 <span class="id">cvg_id</span> [<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#in_mem">set</a></span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)].<br/>
<span class="id">case</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">fg</span>.1 <span class="id">y</span>, <span class="id">fg</span>.2 <span class="id">y</span>)]; [<span class="kwd">exists</span> <span class="id">E</span>|].<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">nbhsB</span> <span class="id">rBrE</span>; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">nbhsB</span>) =&gt; <span class="id">g</span> <span class="id">Bg</span> [<span class="id">y</span> <span class="id">yA</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">rBrE</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">case</span> =&gt; [+ <span class="id">_</span>]; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">g</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_entourage</span> :<br/>
&nbsp;&nbsp;@<span class="id">entourage</span> <span class="id">fct_restrictedUniformType</span> =<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">entourage</span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">U</span>, <span class="id">A</span> <span class="id">t</span> -&gt; <span class="id">P</span> (<span class="id">fg</span>.1 <span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">t</a></span>, <span class="id">fg</span>.2 <span class="id">t</span>)]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof513')">Proof.</span></div>
<div class="proofscript" id="proof513">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">P</span> /=.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; /= <span class="id">E</span> [<span class="id">F</span> <span class="id">entF</span> <span class="id">FsubE</span> <span class="id">EsubP</span>]; <span class="kwd">exists</span> <span class="id">F</span> =&gt; //; <span class="id">case</span>=&gt; <span class="id">f</span> <span class="id">g</span> <span class="id">Ffg</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">EsubP</span>/<span class="id">FsubE</span>=&gt; [[<span class="id">x</span> <span class="id">p</span>]] /=; <span class="id">apply</span>: <span class="id">Ffg</span>; <span class="id">move</span>/<span class="id">set_mem</span>: (<span class="id">p</span>).<br/>
<span class="id">case</span>=&gt; <span class="id">E</span> <span class="id">entE</span> <span class="id">EsubP</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">E</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">f</span> <span class="id">g</span> <span class="id">Efg</span>; <span class="id">apply</span>: <span class="id">EsubP</span> =&gt; <span class="id">t</span> /<span class="id">mem_set</span> <span class="id">At</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">Efg</span> =&gt; /= /(<span class="id">_</span> (@<span class="id">exist</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">in_mem</span> <span class="id">x</span> (<span class="id">mem</span> <span class="id">A</span>)) <span class="id">_</span> <span class="id">At</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">RestrictedUniformTopology</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>`' <span class="id">A</span> -&gt; <span class="id">V</span> }" := (@<span class="id">fct_RestrictedUniform</span> <span class="id">_</span> <span class="id">A</span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }" := ({<span class="id">uniform</span>` [<span class="id">set</span>: <span class="id">U</span>] -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">A</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">filter</a></span> <span class="id">of</span> <span class="id">F</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_RestrictedUniform</span> <span class="id">A</span>) <span class="id"><a href="mathcomp.analysis.topology.html#fct_Pointwise">f</a></span>)))<br/>
&nbsp;&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_RestrictedUniform</span> <span class="id">setT</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">restricted_cvgE</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) <span class="id">A</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof514')">Proof.</span></div>
<div class="proofscript" id="proof514">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_Pointwise</span> <span class="id">U</span> (<span class="id">V</span>: <span class="id">topologicalType</span>) := <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_PointwiseTopology</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">product_topologicalType</span> <span class="id">U</span> (<span class="kwd">fun</span>=&gt; <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_PointwiseFilteredType</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> @<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_PointwiseTopology</span> <span class="id">U</span> <span class="id">V</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_PointwiseTopologicalType</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_PointwiseTopology</span> <span class="id">U</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_of">V</a></span>].<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }" := (@<span class="id">fct_Pointwise</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">U</a></span> <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (@<span class="id">fct_Pointwise</span> <span class="id">_</span> <span class="id">_</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvgE</span> {<span class="id">U</span> : <span class="kwd">Type</span>} {<span class="id"><a href="mathcomp.classical.classical_sets.html#set">V</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">topologicalType</a></span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span>(<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">U</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof515')">Proof.</span></div>
<div class="proofscript" id="proof515">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">UniformCvgLemmas</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_set1</span> <span class="id">F</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">x</span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">uniform</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">set</a></span> <span class="id">x</span>], <span class="id">F</span> --&gt; <span class="id">f</span>} = ((<span class="id">g</span> <span class="id">x</span>) @[<span class="id"><a href="mathcomp.analysis.topology.html#Filter">g</a></span> --&gt; <span class="id">F</span>] --&gt; <span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof516')">Proof.</span></div>
<div class="proofscript" id="proof516">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">W</span> =&gt; /(<span class="id">_</span> [<span class="id">set</span> <span class="id">t</span> | <span class="id">W</span> (<span class="id">t</span> <span class="id">x</span>)]) +; <span class="id">rewrite</span> /<span class="id">filter_of</span> -<span class="id">nbhs_entourageE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">uniform_nbhs</span> =&gt; + [<span class="id">Q</span> <span class="id">entQ</span> <span class="id">subW</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">Q</span>; <span class="id">split</span> =&gt; // <span class="id">h</span> <span class="id">Qf</span>; <span class="id">exact</span>/<span class="id">subW</span>/<span class="id">Qf</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">Ff</span> <span class="id">W</span>; <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">rewrite</a></span> /<span class="id">filter_of</span> <span class="id">uniform_nbhs</span> =&gt; [[<span class="id">E</span>] [<span class="id">entE</span> <span class="id">subW</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">subW</span>); <span class="id">move</span>/(<span class="id">nbhs_entourage</span> (<span class="id">f</span> <span class="id">x</span>))/<span class="id">Ff</span>: <span class="id">entE</span> =&gt; //=; <span class="id">near_simpl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_app</span>; <span class="id">apply</span>: <span class="id">nearW</span>=&gt; ? ? ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_subset_nbhs</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt; <span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.classical.functions.html#cst">V</a></span>}) `=&gt;` <span class="id">nbhs</span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">f</a></span> : {<span class="id">uniform</span>` <span class="id">B</span> -&gt; <span class="id">V</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof517')">Proof.</span></div>
<div class="proofscript" id="proof517">
<span class="id">move</span> =&gt; <span class="id">BsubA</span> <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [<span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>); <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">h</span> <span class="id"><a name="cvg_sigL">Eh</a></span> <span class="id">y</span> /<span class="id">BsubA</span> <span class="id">Ay</span>; <span class="id">exact</span>: <span class="id">Eh</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">uniform_subset_cvg</a></span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) <span class="id">F</span> :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt; {<span class="id"><a href="mathcomp.classical.functions.html#sigL">uniform</a></span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">uniform</span> <span class="id">B</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof518')">Proof.</span></div>
<div class="proofscript" id="proof518">
<span class="id">move</span> =&gt; <span class="id">FF</span> /<span class="id">uniform_subset_nbhs</span> =&gt; /(<span class="id">_</span> <span class="id">f</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">nbhsF</span> <span class="id">Acvg</span>; <span class="id"><a href="mathcomp.analysis.topology.html#filterS">apply</a></span>: <span class="id">cvg_trans</span>; [<span class="id">exact</span>: <span class="id">Acvg</span>|<span class="id">exact</span>: <span class="id">nbhsF</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_uniform_cvg</span>  (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">uniform</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof519')">Proof.</span></div>
<div class="proofscript" id="proof519">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id">cvg_sup</span> =&gt; + <span class="id">i</span>; <span class="id">have</span> <span class="id">isubT</span> : [<span class="id">set</span> <span class="id">i</span>] `&lt;=` <span class="id">setT</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?.<br/>
<span class="id">move</span>=&gt; /(<span class="id">uniform_subset_cvg</span> <span class="id">_</span> <span class="id">isubT</span>); <span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
<span class="id">apply</span>: <span class="id">cvg_trans</span> =&gt; <span class="id">W</span> /=; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>; <span class="kwd">exists</span> (@^~ <span class="id">i</span> @^-1` <span class="id">W</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span> // <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; // <span class="id">j</span> <span class="id">_</span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_sigL</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span>, <span class="id">sigL</span> <span class="id">A</span> @ <span class="id">F</span> --&gt; <span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof520')">Proof.</span></div>
<div class="proofscript" id="proof520">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">cvgF</span> <span class="id">P</span>' /= /<span class="id">uniform_nbhs</span> [ <span class="id">E</span> [/= <span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>); <span class="id">apply</span>: <span class="id">cvgF</span> =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">filterS</a></span> ( <span class="id">P</span>:= [<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">A</a></span> <span class="id">y</span> -&gt; <span class="id">E</span>(<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">y</a></span>)])).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">h</span>/= <span class="id">Eh</span> [<span class="id">y</span> ?] <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Eh</span>; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.boolp.html#propeqE">inE</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="kwd">by</span> (<span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="id">eexists</span>; <span class="id">split</span>; <span class="id">eauto</span>).<br/>
- <span class="id">move</span>=&gt; <span class="id">cvgF</span> <span class="id">P</span>' /= /<span class="id">uniform_nbhs</span> [ <span class="id">E</span> [/= <span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>: (<span class="id">cvgF</span>  [<span class="id">set</span> <span class="id">h</span> | (<span class="kwd">forall</span> <span class="id">y</span> , <span class="id">E</span> (<span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>))]) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">set</span> <span class="id">Q</span> := (<span class="id">x</span> <span class="kwd">in</span> (<span class="id">_</span> -&gt; <span class="id">x</span>) -&gt; <span class="id">_</span>); <span class="id">move</span>=&gt; <span class="id">W</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span>: <span class="id">Q</span> <span class="kwd">by</span> <span class="id">apply</span> <span class="id">W</span>, <span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span> =&gt; // <span class="id">h</span> + ?; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> {}/<span class="id">W</span> {}/<span class="id">Q</span>; <span class="id">near_simpl</span> =&gt; /= <span class="id">R</span>; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">R</span>) =&gt; <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">forall_sig</span> /<span class="id">sigL</span> /=.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_in_close</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> <span class="id">g</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">close</span> <span class="id">f</span> <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof521')">Proof.</span></div>
<div class="proofscript" id="proof521">
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; /<span class="id">eq_sigLP</span> <span class="id">eqfg</span> ? [<span class="id">E</span> <span class="id">entE</span>]; <span class="id">apply</span>=&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">map_pair</span> <span class="id">eqfg</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">hausdorrf_close_eq_in</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> <span class="id">g</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">V</span> -&gt; <span class="id">close</span> <span class="id">f</span> <span class="id">g</span> = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof522')">Proof.</span></div>
<div class="proofscript" id="proof522">
<span class="id">move</span>=&gt; <span class="id">hV</span>.<br/>
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">eq_in_close</span>.<br/>
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; <span class="id">C</span> <span class="id">u</span>; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; <span class="id">uA</span>; <span class="id">apply</span>: <span class="id">hV</span>.<br/>
<span class="id">rewrite</span> /<span class="id">cluster</span> -<span class="id">nbhs_entourageE</span> /= =&gt; <span class="id">X</span> <span class="id">Y</span> [<span class="id">X</span>' <span class="id">eX</span> <span class="id">X</span>'<span class="id">X</span>] [<span class="id">Y</span>' <span class="id">eY</span> <span class="id">Y</span>'<span class="id">Y</span>].<br/>
<span class="kwd">exists</span> (<span class="id">g</span> <span class="id">u</span>); <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">X</span>'<span class="id">X</span>| <span class="id">apply</span>: <span class="id">Y</span>'<span class="id">Y</span>]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">apply</span>: (<span class="id">C</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id">X</span>' (<span class="id">fg</span>.1 <span class="id">y</span>, <span class="id">fg</span>.2 <span class="id">y</span>)]) =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">uniform_entourage</span>; <span class="kwd">exists</span> <span class="id">X</span>'.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_restrict_cvg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">V</a></span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id">A</span> : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">uniform</span>, <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">restrict</a></span> <span class="id">A</span> @ <span class="id">F</span> --&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">restrict</a></span> <span class="id">A</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof523')">Proof.</span></div>
<div class="proofscript" id="proof523">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">FF</a></span>; <span class="id">rewrite</span> <span class="id">cvg_sigL</span>; <span class="id">split</span>.<br/>
- <span class="id">rewrite</span> -<span class="id">sigLK</span>; <span class="id">move</span>/(<span class="id">cvg_app</span> <span class="id">valL</span>) =&gt; <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [/=<span class="id">entE</span> <span class="id">EsubP</span>]]; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; //= <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">sigL</span> =&gt; <span class="id">R</span> <span class="id">u</span> <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">oinv_set_val</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">insubP</span>=&gt; /= *; [<span class="id">apply</span>: <span class="id">R</span>|<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">apply</a></span>: <span class="id">entourage_refl</span>].<br/>
- <span class="id">move</span>/(@<span class="id">cvg_app</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">sigL</span> <span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">fmap_comp</span> <span class="id">sigL_restrict</span> =&gt; <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [/=<span class="id">entE</span> <span class="id">EsubP</span>]]; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; //= <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">sigL</span> =&gt; <span class="id">R</span> [<span class="id">u</span> <span class="id">Au</span>] <span class="id">_</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> := <span class="id">R</span> <span class="id">u</span> <span class="id">I</span>; <span class="id">rewrite</span> /<span class="id">patch</span> <span class="id">Au</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_nbhsT</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;(<span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id">uniform</span> <span class="id">U</span> -&gt; <span class="id">V</span>})) = <span class="id">nbhs</span> (<span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">f</a></span> : <span class="id">fct_topologicalType</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof524')">Proof.</span></div>
<div class="proofscript" id="proof524">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>/<span class="id">uniform_nbhs</span> =&gt; <span class="id">E</span> [<span class="id">entE</span>] /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fh</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">fh</span>.1 <span class="id">y</span>, <span class="id">fh</span>.2 <span class="id">y</span>)]; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /=.<br/>
<span class="id">case</span> =&gt; <span class="id">J</span> [<span class="id">E</span> <span class="id">entE</span> <span class="id">EJ</span>] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; // <span class="id"><a href="mathcomp.analysis.topology.html#Filter">z</a></span> /= <span class="id">Efz</span>; <span class="id">apply</span>: <span class="id">EJ</span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">t</a></span> /=; <span class="id">exact</span>: <span class="id">Efz</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_uniformU</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) <span class="id">A</span> <span class="id">B</span> : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">uniform</span> <span class="id">B</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> (<span class="id">A</span> `|` <span class="id">B</span>), <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof525')">Proof.</span></div>
<div class="proofscript" id="proof525">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">AFf</span> <span class="id">BFf</span> <span class="id">Q</span> /=/<span class="id">uniform_nbhs</span> [<span class="id">E</span> [<span class="id">entE</span> <span class="id">EsubQ</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubQ</span>).<br/>
<span class="id">rewrite</span> (<span class="id">_</span>:  [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">h</a></span> | (<span class="kwd">forall</span> <span class="id">y</span> : <span class="id">U</span>, (<span class="id">A</span> `|` <span class="id">B</span>) <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>))] =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#fct_restrictedUniformType">E</a></span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)] `&amp;`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">B</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)]).<br/>
- <span class="id">apply</span>: <span class="id">filterI</span>; [<span class="id">apply</span>: <span class="id">AFf</span>| <span class="id">apply</span>: <span class="id">BFf</span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
- <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">h</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">R</span>; <span class="id">split</span>=&gt; <span class="id">t</span> ?; <span class="id">apply</span>: <span class="id">R</span>;[<span class="id">left</span>| <span class="id"><a href="mathcomp.analysis.topology.html#fct_UniformFamily">right</a></span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">R1</span> <span class="id">R2</span>] <span class="id">y</span> [? | ?]; [<span class="id">apply</span>: <span class="id">R1</span>| <span class="id">apply</span>: <span class="id">R2</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_uniform_set0</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">set0</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof526')">Proof.</span></div>
<div class="proofscript" id="proof526">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">P</span> /= /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [? <span class="id">R</span>]].<br/>
<span class="id">suff</span> -&gt; : <span class="id">P</span> = <span class="id">setT</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">R</span> =&gt; <span class="id">g</span> <span class="id">_</span> ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fam_cvgP">fct_UniformFamily</a></span> (<span class="id">fam</span> : (<span class="id">set</span> <span class="id">U</span>) -&gt; <span class="kwd">Prop</span>) := <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">family_cvg_uniformType</span> (<span class="id">fam</span>: <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">sup_uniformType</span>  <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sigT</span> <span class="id">fam</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">k</span> =&gt; <span class="id">Uniform.class</span> (@<span class="id">fct_restrictedUniformType</span> <span class="id">U</span> (<span class="id">projT1</span> <span class="id">k</span>) <span class="id">V</span>)).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyFilteredType</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_sup">fam</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">family_cvg_uniformType</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">fam</a></span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyTopologicalType</span> <span class="id">fam</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">family_cvg_uniformType</span> <span class="id">fam</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyUniformType</span> <span class="id">fam</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#set">family_cvg_uniformType</a></span> <span class="id">fam</span>].<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id"><a href="mathcomp.analysis.topology.html#Filter">fam</a></span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_UniformFamily</span> <span class="id">fam</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_cvgP</span> (<span class="id">fam</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">family</span> <span class="id">fam</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>, <span class="id">fam</span> <span class="id">A</span> -&gt; {<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span> }).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof527')">Proof.</span></div>
<div class="proofscript" id="proof527">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#uniform_subset_cvg">cvg_sup</a></span> + <span class="id">A</span> <span class="id">FA</span>; <span class="id">move</span>/(<span class="id">_</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FA</span>)).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">famFf</span> /=; <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; [[? ?] <span class="id">FA</span>]; <span class="id">apply</span>: <span class="id">famFf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">family_cvg_subset</span> (<span class="id">famA</span> <span class="id">famB</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">famA</span> `&lt;=` <span class="id">famB</span> -&gt; {<span class="id">family</span> <span class="id">famB</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">family</span> <span class="id">famA</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof528')">Proof.</span></div>
<div class="proofscript" id="proof528">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">S</span> /<span class="id">fam_cvgP</span> <span class="id">famBFf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">A</span> ?; <span class="id">apply</span>/<span class="id">famBFf</span>/<span class="id">S</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">family_cvg_finite_covers</span> (<span class="id">famA</span> <span class="id">famB</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">famA</span> <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">f</a></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">famB</span> (<span class="id">f</span> <span class="id">i</span>)) /\ <span class="id">finite_subset_cover</span> [<span class="id">set</span>: <span class="id">I</span>] <span class="id">f</span> <span class="id">P</span>) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">family</span> <span class="id">famB</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">family</span> <span class="id">famA</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof529')">Proof.</span></div>
<div class="proofscript" id="proof529">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">ex_finCover</span> /<span class="id">fam_cvgP</span> <span class="id">rFf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">A</span> <span class="id">famAA</span>.<br/>
<span class="id">move</span>: <span class="id">ex_finCover</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">famAA</span>) [<span class="id">R</span> [<span class="id">g</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">g_famB</a></span> [<span class="id">D</span> <span class="id">_</span>]]]].<br/>
<span class="id">move</span>/<span class="id">uniform_subset_cvg</span>; <span class="id">apply</span>.<br/>
<span class="id">elim</span>/<span class="id">finSet_rect</span>: <span class="id">D</span> =&gt; <span class="id">X</span> <span class="id">IHX</span>.<br/>
<span class="id">have</span> [-&gt;|/<span class="id">set0P</span>[<span class="id">x</span> <span class="id">xX</span>]] := <span class="id">eqVneq</span> [<span class="id">set</span>` <span class="id">X</span>] <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">coverE</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">bigcup_set0</a></span>; <span class="id">apply</span>: <span class="id">cvg_uniform_set0</span>.<br/>
<span class="id">rewrite</span> <span class="id">coverE</span> (<span class="id">bigcup_fsetD1</span> <span class="id">x</span>)//; <span class="id">apply</span>: <span class="id">cvg_uniformU</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">rFf</span>/<span class="id">g_famB</span>.<br/>
<span class="id">exact</span>/<span class="id">IHX</span>/<span class="id">fproperD1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">UniformCvgLemmas</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">U</span> -&gt; <span class="id">V</span> }" :=  (@<span class="id">fct_UniformFamily</span> <span class="id">U</span> <span class="id">V</span> <span class="id">fam</span>).<br/>
<span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">of</a></span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_UniformFamily</span> <span class="id">fam</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_cvgE</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id">fam</span> :<br/>
&nbsp;&nbsp;{<span class="id">family</span> <span class="id">fam</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">family</span> <span class="id">fam</span>, <span class="id">U</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof530')">Proof.</span></div>
<div class="proofscript" id="proof530">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_nbhs</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">fam</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">U</a></span>) (<span class="id">E</span> : <span class="id">set</span> (<span class="id">V</span> * <span class="id">V</span>)) (<span class="id">f</span> : {<span class="id">family</span> <span class="id">fam</span>, <span class="id">U</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">fam</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span> <span class="id">f</span> [<span class="id">set</span> <span class="id">g</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">g</span> <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof531')">Proof.</span></div>
<div class="proofscript" id="proof531">
<span class="id">move</span>=&gt; <span class="id">entE</span> <span class="id">famA</span>; <span class="id">have</span> /<span class="id">fam_cvgP</span> /(<span class="id">_</span> <span class="id">A</span>) : (<span class="id">nbhs</span> <span class="id">f</span> --&gt; <span class="id">f</span>) <span class="kwd">by</span> []; <span class="id">apply</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span> <span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compactly_in</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">B</span> | <span class="id">B</span> `&lt;=` <span class="id">A</span> /\ <span class="id">compact</span> <span class="id">B</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cvg_within_compact</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">C</a></span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">compact</span> <span class="id">C</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">C</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">family</span> <span class="id">compactly_in</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">C</a></span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof532')">Proof.</span></div>
<div class="proofscript" id="proof532">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">CC</span>.<br/>
<span class="id">apply</span>: (<span class="id">iff_trans</span> <span class="id">_</span> (<span class="id">iff_sym</span> (<span class="id">fam_cvgP</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FF</span>))); <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">CFf</span> <span class="id">D</span> [/<span class="id">uniform_subset_cvg</span> + <span class="id">_</span>]; <span class="id">apply</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">Global</a></span> <span class="kwd">Instance</span> <span class="id">Proper_dnbhs_numFieldType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">x</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof533')">Proof.</span></div>
<div class="proofscript" id="proof533">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span> =&gt; <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">Ae</span>].<br/>
<span class="kwd">exists</span> (<span class="id">x</span> + <span class="id">e</span>%:<span class="id">num</span> / 2)%<span class="id">R</span>; <span class="id">apply</span>: <span class="id">Ae</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eq_sym</span> <span class="id">addrC</span> -<span class="id">subr_eq</span> <span class="id">subrr</span> <span class="id">eq_sym</span>.<br/>
<span class="id">rewrite</span> /<span class="id">ball</span> /= <span class="id">opprD</span> <span class="id">addrA</span> <span class="id">subrr</span> <span class="id">distrC</span> <span class="id">subr0</span> <span class="id">ger0_norm</span> //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}(<span class="id">splitr</span> <span class="id">e</span>%:<span class="id">num</span>) <span class="id">ltr_spaddl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">dense</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">S</a></span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">O</span> : <span class="id">set</span> <span class="id">T</span>), <span class="id">O</span> !=<span class="id">set0</span> -&gt; <span class="id">open</span> <span class="id">O</span> -&gt; <span class="id">O</span> `&amp;` <span class="id">S</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">denseNE</span> (<span class="id"><a href="mathcomp.analysis.topology.html#weak_uniformType">T</a></span> : <span class="id">topologicalType</span>) (<span class="id">S</span> : <span class="id">set</span> <span class="id">T</span>) : ~ <span class="id">dense</span> <span class="id">S</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">O</span>, (<span class="kwd">exists</span> <span class="id">x</span>, <span class="id">open_nbhs</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#weak_pseudoMetric.f">O</a></span>) /\ (<span class="id">O</span> `&amp;` <span class="id">S</span> = <span class="id">set0</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof534')">Proof.</span></div>
<div class="proofscript" id="proof534">
<span class="id">rewrite</span> /<span class="id">dense</span> /<span class="id">open_nbhs</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">existsNP</span>[<span class="id">X</span> /<span class="id">not_implyP</span>[[<span class="id">x</span> <span class="id">Xx</span>] /<span class="id">not_implyP</span>[ <span class="id">Ox</span> /<span class="id">forallNP</span> <span class="id">A</span>]]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">X</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="id">rewrite</span> -<span class="id">subset0</span>; <span class="id">apply</span>/<span class="id">A</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dense_rat</span> (<span class="id">R</span> : <span class="id">realType</span>) : <span class="id">dense</span> (@<span class="id">ratr</span> <span class="id">R</span> @` <span class="id">setT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof535')">Proof.</span></div>
<div class="proofscript" id="proof535">
<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">r</span> <span class="id">Ar</span>]; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ar</span>)/<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id"><a href="mathcomp.analysis.topology.html#entourage">reA</a></span>].<br/>
<span class="id">have</span> /<span class="id">rat_in_itvoo</span>[<span class="id">q</span> /<span class="id">itvP</span> <span class="id">qre</span>] : <span class="id">r</span> &lt; <span class="id">r</span> + <span class="id">e</span>%:<span class="id">num</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">ltr_addl</span>.<br/>
<span class="kwd">exists</span> (<span class="id">ratr</span> <span class="id"><a href="mathcomp.analysis.topology.html#weak_pseudoMetric.f">q</a></span>) =&gt; //; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span>.<br/>
<span class="id">apply</span>: <span class="id">reA</span>; <span class="id">rewrite</span> /<span class="id">ball</span> /= <span class="id">distrC</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">ltr_distl</a></span> <span class="id">qre</span> <span class="id">andbT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">le_lt_trans</span> <span class="id">_</span> <span class="id">_</span> <span class="id">r</span>)// ?<span class="id">qre</span>// <span class="id">ler_subl_addl</span> <span class="id">ler_addr</span> <span class="id">ltW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">separated_open_countable</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">R</span> : <span class="id">realType</span>} (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">R</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">open</span> (<span class="id">B</span> <span class="id">i</span>)) -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">B</span> <span class="id">i</span> !=<span class="id">set0</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">trivIset</span> <span class="id">D</span> <span class="id">B</span> -&gt; <span class="id">countable</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof536')">Proof.</span></div>
<div class="proofscript" id="proof536">
<span class="id">move</span>=&gt; <span class="id">oB</span> <span class="id">B0</span> <span class="id">tB</span>; <span class="id">have</span> [<span class="id">f</span> <span class="id">fB</span>] :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">rat</span> &amp; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">B</span> <span class="id">i</span> (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>))}.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id">choice</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> <span class="id">y</span> =&gt; <span class="id">D</span> <span class="id">x</span> -&gt; <span class="id">B</span> <span class="id">x</span> (<span class="id">ratr</span> <span class="id">y</span>))) =&gt; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">r</span> [<span class="id">Bir</span> [<span class="id">q</span> <span class="id">_</span> <span class="id">qr</span>]]] := <span class="id">dense_rat</span> (<span class="id">B0</span> <span class="id">_</span>) (<span class="id">oB</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span> =&gt; <span class="id">Di</span>; <span class="id">rewrite</span> <span class="id">qr</span>.<br/>
<span class="id">have</span> <span class="id">inj_f</span> : {<span class="kwd">in</span> <span class="id">D</span> &amp;, <span class="id">injective</span> <span class="id">f</span>}.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> /[!<span class="id">inE</span>] <span class="id">Di</span> <span class="id">Dj</span> /(<span class="id">congr1</span> <span class="id">ratr</span>) <span class="id">ratrij</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> ? : (<span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; [<span class="id">exact</span>: <span class="id">fB</span>|<span class="id">rewrite</span> <span class="id">ratrij</span>; <span class="id">exact</span>: <span class="id">fB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/(<span class="id">tB</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Di</span> <span class="id">Dj</span>); <span class="kwd">exists</span> (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<span class="id">apply</span>/<span class="id">pcard_injP</span>; <span class="id">have</span> /<span class="id">card_bijP</span>/<span class="id">cid</span>[<span class="id">g</span> <span class="id">bijg</span>] := <span class="id">card_rat</span>.<br/>
<span class="id">pose</span> <span class="id">nat_of_rat</span> (<span class="id">q</span> : <span class="id">rat</span>) : <span class="id">nat</span> := <span class="id">set_val</span> (<span class="id">g</span> (<span class="id">to_setT</span> <span class="id">q</span>)).<br/>
<span class="id">have</span> <span class="id">inj_nat_of_rat</span> : <span class="id">injective</span> <span class="id">nat_of_rat</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">nat_of_rat</span>; <span class="id">apply</span>: <span class="id">inj_comp</span> =&gt; //; <span class="id">apply</span>: <span class="id">inj_comp</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">bij_inj</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">nat_of_rat</span> \<span class="id">o</span> <span class="id">f</span>) =&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">Di</span> <span class="id">Dj</span> /<span class="id">inj_nat_of_rat</span>/<span class="id">inj_f</span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="weak_ballE">weak_pseudoMetric</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} (<span class="id">pS</span> : <span class="id">pointedType</span>) (<span class="id">U</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) .<br/>
<span class="kwd">Variable</span> (<span class="id">f</span> : <span class="id">pS</span> -&gt; <span class="id">U</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">S</span> := <span class="id">weak_uniformType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_ball</span> (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">x</a></span> : <span class="id">S</span>) (<span class="id">r</span> : <span class="id">R</span>) (<span class="id">y</span> : <span class="id">S</span>) := <span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">r</span> (<span class="id">f</span> <span class="id">y</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">weak_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">PseudoMetric.Mixin</span> <span class="id">R</span> <span class="id">S</span> <span class="id">entourage</span> <span class="id">weak_ball</span><br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#set">_</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof537')">Next Obligation.</span></div>
<div class="proofscript" id="proof537">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>]; <span class="id">exact</span>: <span class="id">ball_center</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof538')">Next Obligation.</span></div>
<div class="proofscript" id="proof538">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ?; <span class="id">exact</span>: <span class="id">ball_sym</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof539')">Next Obligation.</span></div>
<div class="proofscript" id="proof539">
 <span class="id">move</span>=&gt; ? ? ? ? ?; <span class="id">exact</span>: <span class="id">ball_triangle</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof540')">Next Obligation.</span></div>
<div class="proofscript" id="proof540">
<span class="id">rewrite</span> /<span class="id">entourage</span> /= /<span class="id">weak_ent</span> -<span class="id">entourage_ballE</span> /<span class="id">entourage_</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#nbhsx_ballx">have</a></span> -&gt; : (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> (<span class="id">f</span> <span class="id"><a href="mathcomp.classical.boolp.html#exists2P">xy</a></span>.1) <span class="id">e</span> (<span class="id">f</span> <span class="id">xy</span>.2)]) =<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">preimage</span> (<span class="id">map_pair</span> <span class="id">f</span>) \<span class="id">o</span> <span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2])%<span class="id">FUN</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">apply</span>/<span class="id">filter_fromP</span>.<br/>
- <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set_countable">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 1 =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span>; <span class="id">wlog</span> <span class="id">e1lee2</span> : <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_ballP">have</a></span> [?|/<span class="id">ltW</span> ?] := <span class="id">lerP</span> <span class="id">e1</span> <span class="id">e2</span>; [<span class="id">exact</span> | <span class="id">rewrite</span> <span class="id">setIC</span>; <span class="id">exact</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">e1</span> =&gt; //; <span class="id">rewrite</span> -<span class="id">preimage_setI</span>; <span class="id">apply</span>: <span class="id">preimage_subset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">le_ball</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">e1lee2</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">e</span> ?] <span class="id">heE</span>; <span class="kwd">exists</span> <span class="id">e</span> =&gt; //; <span class="id">apply</span>: <span class="id">preimage_subset</span>.<br/>
- <span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">set</a></span> <span class="id">xy</span> | (<span class="id">ball</span> <span class="id">xy</span>.1 1 <span class="id">xy</span>.2)]; <span class="kwd">exists</span> 1 =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [<span class="id">e1</span> <span class="id">e1pos</span> <span class="id">he1E1</span>] [<span class="id">e2</span> <span class="id">e2pos</span> <span class="id">he2E2</span>].<br/>
&nbsp;&nbsp;<span class="id">wlog</span> ? : <span class="id">E1</span> <span class="id">E2</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span> <span class="id">he1E1</span> <span class="id">he2E2</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [? /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">e1</span> <span class="id">e2</span>)|/<span class="id">ltW</span> ? ] := <span class="id">lerP</span> <span class="id">e1</span> <span class="id">e2</span>; <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">exact</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">e2</span> <span class="id">e1</span>); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">E1</span> `&amp;` <span class="id">E2</span>) =&gt; //; <span class="kwd">exists</span> <span class="id">e1</span> =&gt; // <span class="id">xy</span> /= <span class="id">B</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">he1E1</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">he2E2</span>/<span class="id">le_ball</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">B</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e</span> ?; <span class="kwd">exists</span> ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]) =&gt; //; <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; /=.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">S</span> <span class="id">weak_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ballE</span> (<span class="id">e</span> : <span class="id">R</span>) (<span class="id">x</span> : <span class="id">weak_pseudoMetricType</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span>@^-1` (<span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">e</span>) = <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof541')">Proof.</span></div>
<div class="proofscript" id="proof541">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">weak_pseudoMetric</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_second_countable</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id"><a name="countable_uniform">pseudoMetricType</a></span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; @<span class="id">second_countable</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof542')">Proof.</span></div>
<div class="proofscript" id="proof542">
<span class="id">have</span> <span class="id">npos</span> <span class="id">n</span> : (0:<span class="id">R</span>) &lt; <span class="id">n</span>.+1%:<span class="id">R</span>^-1 <span class="kwd">by</span> [].<br/>
<span class="id">pose</span> <span class="id">f</span> <span class="id">n</span> (<span class="id">z</span> : <span class="id">T</span>): <span class="id">set</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#iffLR">T</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#countable_uniformityP">ball</a></span> <span class="id">z</span> (<span class="id">PosNum</span> (<span class="id">npos</span> <span class="id">n</span>))%:<span class="id">num</span>)^°.<br/>
<span class="id">move</span>=&gt; <span class="id">cmpt</span>; <span class="id">have</span> <span class="id">h</span> <span class="id">n</span> : <span class="id">finite_subset_cover</span> [<span class="id">set</span>: <span class="id">T</span>] (<span class="id">f</span> <span class="id">n</span>) [<span class="id">set</span>: <span class="id">T</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">cmpt</span>; <span class="id">rewrite</span> <span class="id">compact_cover</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="id">rewrite</span> /<span class="id">f</span>; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">f</span> /<span class="id">interior</span>; <span class="id">exact</span>: <span class="id">nbhsx_ballx</span>.<br/>
<span class="id">pose</span> <span class="id">h</span>' <span class="id">n</span> := <span class="id">cid</span> (<span class="id">iffLR</span> (<span class="id">exists2P</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">h</span> <span class="id">n</span>)).<br/>
<span class="id">pose</span> <span class="id">h</span>'' <span class="id">n</span> := <span class="id">projT1</span> (<span class="id">h</span>' <span class="id">n</span>).<br/>
<span class="id">pose</span> <span class="id">B</span> := \<span class="id">bigcup_n</span> (<span class="id">f</span> <span class="id">n</span>) @` [<span class="id">set</span>` <span class="id">h</span>'' <span class="id">n</span>]; <span class="kwd">exists</span> <span class="id">B</span>;[|<span class="id">split</span>].<br/>
- <span class="id">apply</span>: <span class="id">bigcup_countable</span> =&gt; // <span class="id">n</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">finite_set_countable</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">finite_image</span>/ <span class="id">finite_fset</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span> =&gt; ? [? <span class="id">_</span> [? <span class="id">_</span> &lt;-]]; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">V</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#set">nbhs_ballP</a></span> [] <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>] <span class="id">ballsubV</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">N</span>] := @<span class="id">ltr_add_invr</span> <span class="id">R</span> 0%<span class="id">R</span> (<span class="id">eps</span>%:<span class="id">num</span>/2) <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">add0r</span> =&gt; <span class="id">deleps</span>.<br/>
&nbsp;&nbsp;<span class="id"><a name="countable_uniform.entG">have</a></span> [<span class="id">w</span> <span class="id">wh</span> <span class="id">fx</span>] : <span class="kwd">exists2</span> <span class="id">w</span> : <span class="id">T</span>, <span class="id">w</span> \<span class="kwd">in</span> <span class="id">h</span>'' <span class="id">N</span> &amp; <span class="id">f</span> <span class="id">N</span> <span class="id">w</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span> /(<span class="id">_</span> <span class="id">x</span>) [// | <span class="id">w</span> ? ?]] := <span class="id">projT2</span> (<span class="id">h</span>' <span class="id">N</span>); <span class="kwd">exists</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">f</a></span> <span class="id">N</span> <span class="id">w</span>); <span class="id">first</span> <span class="id">split</span> =&gt; //; <span class="id"><a name="symG">first</a></span> (<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">ballsubV</span>) =&gt; <span class="id">z</span> <span class="id">bz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">_</span>%:<span class="id">num</span>]<span class="id">splitr</span>; <span class="id">apply</span>: (@<span class="id">ball_triangle</span> <span class="id">_</span> <span class="id">_</span> <span class="id">w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">le_ball</span> (<span class="id">ltW</span> <span class="id">deleps</span>)); <span class="id">apply</span>/<span class="id">ball_sym</span>; <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">le_ball</span> (<span class="id">ltW</span> <span class="id">deleps</span>)); <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">apply</a></span>: <span class="id">interior_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_surj</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; $|{<span class="id">surjfun</span> [<span class="id">set</span>: <span class="id">nat</span>] &gt;-&gt; @<span class="id">clopen</span> <span class="id">T</span>}|.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof543')">Proof.</span></div>
<div class="proofscript" id="proof543">
<span class="id">move</span>=&gt; <span class="id">cmptT</span>.<br/>
<span class="id">suff</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#g_">clopen</a></span> <span class="id">T</span> = <span class="id">set0</span> \/ $|{<span class="id">surjfun</span> [<span class="id">set</span>: <span class="id">nat</span>] &gt;-&gt; @<span class="id">clopen</span> <span class="id">T</span>}|.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; //; <span class="id">rewrite</span> <span class="id">eqEsubset</span> =&gt; -[/(<span class="id">_</span> <span class="id">_</span> <span class="id">clopenT</span>)].<br/>
<span class="id">exact</span>/<span class="id">pfcard_geP</span>/<span class="id">clopen_countable</span>/<span class="id">compact_second_countable</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">countable_uniform</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">cnt_unif</span> : @<span class="id">countable_uniformity</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">f_</span> := <span class="id">projT1</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">countable_uniformityP</a></span> <span class="id">cnt_unif</span>)).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">countableBase</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">f_</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof544')">Proof.</span></div>
<div class="proofscript" id="proof544">
 <span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id">countable_uniformityP</span> <span class="id">cnt_unif</span>)). Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">entF</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">entourage</span> (<span class="id">f_</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof545')">Proof.</span></div>
<div class="proofscript" id="proof545">
 <span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id">countable_uniformityP</span> <span class="id">cnt_unif</span>)). Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id">g_</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">S</span> <span class="id">n</span> <span class="kwd">then</span> <span class="kwd">let</span> <span class="id">W</span> := <span class="id">split_ent</span> (<span class="id">split_ent</span> (<span class="id">g_</span> <span class="id">n</span>)) `&amp;` <span class="id">f_</span> <span class="id">n</span> <span class="kwd">in</span> <span class="id">W</span> `&amp;` <span class="id">W</span>^-1<br/>
&nbsp;&nbsp;<span class="kwd">else</span> [<span class="id">set</span>: <span class="id">T</span>*<span class="id">T</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">entG</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">entourage</span> (<span class="id">g_</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof546')">Proof.</span></div>
<div class="proofscript" id="proof546">
<span class="id">elim</span>: <span class="id">n</span> =&gt; /=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourageT</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">entg</span>; <span class="id">apply</span>/<span class="id">entourage_invI</span>; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">symG</span> (<span class="id">n</span> : <span class="id">nat</span>) : ((<span class="id">g_</span> <span class="id">n</span>)^-1)%<span class="id">classic</span> = <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof547')">Proof.</span></div>
<div class="proofscript" id="proof547">
<span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">n</a></span> =&gt; // <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id">andC</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">descendG1</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof548')">Proof.</span></div>
<div class="proofscript" id="proof548">
<span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">split_ent_subset</span>; <span class="id">exact</span>: <span class="id">entourage_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">split_ent_subset</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">descendG</span> (<span class="id">n</span> <span class="id">m</span>: <span class="id">nat</span>) : (<span class="id">m</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">g_</span> <span class="id">n</span> `&lt;=` <span class="id">g_</span> <span class="id">m</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof549')">Proof.</span></div>
<div class="proofscript" id="proof549">
<span class="id">elim</span>: <span class="id">n</span>; <span class="id">rewrite</span> ?<span class="id">leqn0</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt;/<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> <span class="id">ltnS</span> =&gt; /<span class="id">orP</span> [/<span class="id">eqP</span> &lt;- //|] /<span class="id">IH</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">exact</span>: <span class="id">descendG1</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">splitG3</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof550')">Proof.</span></div>
<div class="proofscript" id="proof550">
<span class="id">suff</span> <span class="id">g2split</span> : <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">split_ent</span> (<span class="id">g_</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball">subset_trans</a></span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">subset_split_ent</span> (<span class="id">entG</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">set_compose_subset</span> (<span class="id">g2split</span>); <span class="id">rewrite</span> -[<span class="id">_</span> <span class="id">n</span>.+1]<span class="id">set_compose_diag</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">g2split</span>; <span class="id">apply</span>: <span class="id">set_compose_subset</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span> <span class="id">_</span>] [<span class="id">z</span> <span class="id">_</span>] [&lt;- &lt;-]; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">subset_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">set_compose_subset</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage">subIset</a></span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">gsubf</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">f_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof551')">Proof.</span></div>
<div class="proofscript" id="proof551">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">countableBaseG</span> <span class="id">A</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">g_</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof552')">Proof.</span></div>
<div class="proofscript" id="proof552">
<span class="id">move</span>=&gt; /<span class="id">countableBase</span> [<span class="id">N</span>] <span class="id">fnA</span>; <span class="kwd">exists</span> <span class="id">N</span>.+1.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">fnA</span>; <span class="id">exact</span>: <span class="id">gsubf</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ring_scope</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Definition</span> <span class="id">distN</span> (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">nat</span> := `|<span class="id">floor</span> <span class="id">e</span>^-1|%<span class="id">N</span>.<br/>
<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#step_ball">Local</a></span> <span class="kwd">Lemma</span> <span class="id">distN0</span> : <span class="id">distN</span> 0 = 0%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof553')">Proof.</span></div>
<div class="proofscript" id="proof553">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">distN</span> <span class="id">invr0</span> <span class="id">floor0</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_nat</span> (<span class="id">n</span> : <span class="id">nat</span>): <span class="id">distN</span> (<span class="id">n</span>%:<span class="id">R</span>^-1) = <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof554')">Proof.</span></div>
<div class="proofscript" id="proof554">
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">distN</span> <span class="id">invrK</span> <span class="id">floor_natz</span> -[<span class="id">RHS</span>]<span class="id">distn0</span>; <span class="id">congr</span> <span class="id">absz</span>; <span class="id">rewrite</span> <span class="id">subr0</span> <span class="id">intz</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_le</span> <span class="id">e1</span> <span class="id">e2</span> : <span class="id">e1</span> &gt; 0 -&gt; <span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; (<span class="id">distN</span> <span class="id">e2</span> &lt;= <span class="id">distN</span> <span class="id">e1</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof555')">Proof.</span></div>
<div class="proofscript" id="proof555">
<span class="id">move</span>=&gt; <span class="id">e1pos</span> <span class="id">e1e2</span>; <span class="id">rewrite</span> /<span class="id">distN</span>; <span class="id">apply</span>: <span class="id">lez_abs2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">floor_ge0</span> <span class="id">ltW</span>// <span class="id">invr_gt0</span> (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">le_floor</span>// <span class="id">lef_pinv</span> ?<span class="id">invrK</span> ?<span class="id">invr_gt0</span>//; <span class="id">exact</span>: (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">n</span>.+1 <span class="kwd">then</span> <span class="kwd">exists</span> <span class="id">y</span> <span class="id">d1</span> <span class="id">d2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &lt; <span class="id">d1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &lt; <span class="id">d2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_</span> (<span class="id">distN</span> <span class="id">d2</span>) (<span class="id">y</span>, <span class="id">z</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">d1</span> + <span class="id">d2</span> = <span class="id">e</span>]<br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">e</span> &gt; 0 /\ <span class="id">g_</span> (<span class="id">distN</span> <span class="id">e</span>) (<span class="id">x</span>, <span class="id">z</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Definition</span> <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> := <span class="kwd">exists</span> <span class="id">i</span>, (<span class="id">n_step_ball</span> <span class="id">i</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_pos</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> : <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> -&gt; 0 &lt; <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof556')">Proof.</span></div>
<div class="proofscript" id="proof556">
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> =&gt; [[]|] // <span class="id">n</span>; <span class="id">case</span>=&gt; [?] [?] [?] [] ? ? ? ? &lt;-; <span class="id">apply</span>: <span class="id">addr_gt0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_pos</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> : <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> -&gt; 0 &lt; <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof557')">Proof.</span></div>
<div class="proofscript" id="proof557">
 <span class="kwd">by</span> <span class="id">case</span> =&gt; ?; <span class="id">exact</span>: <span class="id">n_step_ball_pos</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">entourage_nball</span> <span class="id">e</span> :<br/>
&nbsp;&nbsp;0 &lt; <span class="id">e</span> -&gt; <span class="id">entourage</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">step_ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof558')">Proof.</span></div>
<div class="proofscript" id="proof558">
<span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">g_</span> (<span class="id">distN</span> <span class="id">e</span>))) =&gt; // [[<span class="id">x</span> <span class="id">y</span>]] ?.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_center</span> <span class="id">x</span> <span class="id">e</span> : 0 &lt; <span class="id">e</span> -&gt; <span class="id">n_step_ball</span> 0 <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof559')">Proof.</span></div>
<div class="proofscript" id="proof559">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">entourage_refl</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_center</span> <span class="id">x</span> <span class="id">e</span> : 0 &lt; <span class="id">e</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#distN_le">e</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof560')">Proof.</span></div>
<div class="proofscript" id="proof560">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="kwd">exists</span> 0%<span class="id">N</span>; <span class="id">apply</span>: <span class="id">n_step_ball_center</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_triangle</span> <span class="id">n</span> <span class="id">m</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">d1</span> <span class="id">d2</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">m</span> <span class="id">y</span> <span class="id">d2</span> <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> (<span class="id">n</span> + <span class="id">m</span>).+1 <span class="id">x</span> (<span class="id">d1</span> + <span class="id">d2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof561')">Proof.</span></div>
<div class="proofscript" id="proof561">
<span class="id">move</span>: <span class="id">n</span> <span class="id">z</span> <span class="id">d2</span>; <span class="id">elim</span>: <span class="id">m</span> =&gt; [<span class="id">n</span> <span class="id">z</span> <span class="id">d2</span> <span class="id">Nxy</span> [? ?]|<span class="id">n</span> <span class="id">IH</span> <span class="id">m</span> <span class="id">z</span> <span class="id">d2</span> <span class="id">Oxy</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">d1</span>, <span class="id">d2</span>; <span class="id">split</span>; <span class="id">rewrite</span> ?<span class="id">addn0</span> // (<span class="id">n_step_ball_pos</span> <span class="id">Nxy</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">w</span>] [<span class="id">e1</span>] [<span class="id">e2</span>] [<span class="id">Oyw</span> ? ? ? &lt;-].<br/>
<span class="kwd">exists</span> <span class="id">w</span>, (<span class="id">d1</span> + <span class="id">e1</span>), <span class="id">e2</span>; <span class="id">rewrite</span> <span class="id">addnS</span> <span class="id">addrA</span>.<br/>
<span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addr_gt0</span>//; <span class="id">exact</span>: <span class="id">n_step_ball_pos</span> <span class="id">Oxy</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">IH</span> <span class="id">m</span> <span class="id">w</span> <span class="id">e1</span> <span class="id">Oxy</span> <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball_le">Oyw</a></span>) =&gt; <span class="id">t</span> [<span class="id">e3</span>] [<span class="id">e4</span>] [] <span class="id">Oxt</span> ? ? ? &lt;-; <span class="kwd">exists</span> <span class="id">t</span>, <span class="id">e3</span>, <span class="id">e4</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_triangle</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">d1</span> <span class="id">d2</span> :<br/>
&nbsp;&nbsp;<span class="id">step_ball</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span> -&gt; <span class="id">step_ball</span> <span class="id">y</span> <span class="id">d2</span> <span class="id">z</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> (<span class="id">d1</span> + <span class="id">d2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof562')">Proof.</span></div>
<div class="proofscript" id="proof562">
<span class="id">move</span>=&gt; [<span class="id">n</span> <span class="id">Oxy</span>] [<span class="id">m</span> <span class="id">Oyz</span>]; <span class="kwd">exists</span> (<span class="id">n</span> + <span class="id">m</span>).+1.<br/>
<span class="id">exact</span>: <span class="id">n_step_ball_triangle</span> <span class="id">Oxy</span> <span class="id">Oyz</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_sym</span> <span class="id">n</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">y</span> <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball">e</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof563')">Proof.</span></div>
<div class="proofscript" id="proof563">
<span class="id">move</span>: <span class="id">x</span> <span class="id">y</span> <span class="id">e</span>; <span class="id">elim</span>: <span class="id">n</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ?; <span class="id">rewrite</span> /= -{1}<span class="id">symG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> [<span class="id">t</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] /<span class="id">IH</span> <span class="id">Oty</span> ? ?.<br/>
<span class="id">rewrite</span> <span class="id">addrC</span> -<span class="id">symG</span> -[<span class="id">n</span>]<span class="id">add0n</span> =&gt; <span class="id">gty</span> &lt;-; <span class="id">apply</span>: (<span class="id">n_step_ball_triangle</span> <span class="id">_</span> <span class="id">Oty</span>).<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">gty</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_sym</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> : <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">step_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof564')">Proof.</span></div>
<div class="proofscript" id="proof564">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">n</span> /<span class="id">n_step_ball_sym</span> ?; <span class="kwd">exists</span> <span class="id">n</span>. Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_le</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> :<br/>
&nbsp;&nbsp;<span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof565')">Proof.</span></div>
<div class="proofscript" id="proof565">
<span class="id">move</span>: <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span>; <span class="id">elim</span>: <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1e2</span> <span class="id">y</span> [?] <span class="id">gxy</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">descendG</span>; <span class="id">last</span> (<span class="id">exact</span>: <span class="id">gxy</span>); <span class="id">exact</span>: <span class="id">distN_le</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1e2</span> <span class="id">z</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] /<span class="id">IH</span> <span class="id">P</span> <span class="id">d1pos</span> <span class="id">d2pos</span> <span class="id">gyz</span> <span class="id">d1d2e1</span>.<br/>
<span class="id">have</span> <span class="id">d1e1d2</span> : <span class="id">d1</span> = <span class="id">e1</span> - <span class="id">d2</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">d1d2e1</span> -<span class="id">addrA</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
<span class="id">have</span> <span class="id">e2d2le</span> : <span class="id">e1</span> - <span class="id">d2</span> &lt;= <span class="id">e2</span> - <span class="id">d2</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">ler_sub</span>.<br/>
<span class="kwd">exists</span> <span class="id">y</span>, (<span class="id">e2</span> - <span class="id">d2</span>), <span class="id">d2</span>; <span class="id">split</span> =&gt; //.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">P</span>; <span class="id">apply</span>: <span class="id">le_trans</span> <span class="id">e2d2le</span>; <span class="id">rewrite</span> <span class="id">d1e1d2</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">lt_le_trans</span> <span class="id">e2d2le</span>; <span class="id">rewrite</span> -<span class="id">d1e1d2</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">addrA</span> [-<span class="id">_</span> + <span class="id">_</span>]<span class="id">addrC</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_le</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> :<br/>
&nbsp;&nbsp;<span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof566')">Proof.</span></div>
<div class="proofscript" id="proof566">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e1e2</span> ? [<span class="id">n</span> <span class="id">P</span>]; <span class="kwd">exists</span> <span class="id">n</span>; <span class="id">exact</span>: (<span class="id">n_step_ball_le</span> <span class="id">e1e2</span>). Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_half</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">n</span>.+1%:<span class="id">R</span>^-1 / (2:<span class="id">R</span>) &lt;= <span class="id">n</span>.+2%:<span class="id">R</span>^-1.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof567')">Proof.</span></div>
<div class="proofscript" id="proof567">
<span class="id">rewrite</span> -<span class="id">invrM</span> //; [|<span class="id">exact</span>: <span class="id">unitf_gt0</span> |<span class="id">exact</span>: <span class="id">unitf_gt0</span>].<br/>
<span class="id">rewrite</span> <span class="id">lef_pinv</span> ?<span class="id">posrE</span> // -?<span class="id">natrM</span> ?<span class="id">ler_nat</span> -<span class="id">addn1</span> -<span class="id"><a name="n_step_ball_le_g">addn1</a></span> -<span class="id">addnA</span> <span class="id">mulnDr</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">muln1</span> <span class="id">leq_add2r</span> <span class="id">leq_pmull</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">split_n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">z</span> :<br/>
&nbsp;&nbsp;0 &lt; <span class="id">e1</span> -&gt; 0 &lt; <span class="id">e2</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span>.+1 <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">a</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">a</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">t1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> 0 <span class="id">t1</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">t2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">b</span> <span class="id">t2</span> <span class="id">e2</span> <span class="id">z</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">a</span> + <span class="id">b</span> = <span class="id">n</span>)%<span class="id">N</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof568')">Proof.</span></div>
<div class="proofscript" id="proof568">
<span class="id">move</span>: <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span>; <span class="id">elim</span>: <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span> <span class="id">e1pos</span> <span class="id">e2pos</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] <span class="id">Oxy</span> ? ? <span class="id">gd2yz</span> <span class="id">deE</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">e1</span> &lt;= <span class="id">d1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1d1</span>; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">y</span>, 0%<span class="id">N</span>, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">apply</span>: <span class="id">n_step_ball_le</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Oxy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> <span class="id">ler_addl</span>; <span class="id">apply</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -[<span class="id">e2</span>]<span class="id">addr0</span> -(<span class="id">subrr</span> <span class="id">e1</span>) <span class="id">addrA</span> -<span class="id">ler_subl_addr</span> <span class="id">opprK</span> <span class="id">addrC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">e2</span> + <span class="id">_</span>]<span class="id">addrC</span> -<span class="id">deE</span>; <span class="id">exact</span>: <span class="id">ler_add</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addn0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> -<span class="id">real_ltNge</span> ?<span class="id">num_real</span> //.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1d1</span>; <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">z</span>, 0%<span class="id">N</span>, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">n_step_ball_le</span>; <span class="id">last</span> (<span class="id">exact</span>: <span class="id">Oxy</span>); <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> -<span class="id">deE</span>; <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">ler_addr</span>; <span class="id">apply</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addn0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span> <span class="id">e1pos</span> <span class="id">e2pos</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] <span class="id">Od1xy</span> <span class="id">d1pos</span> <span class="id">d2pos</span> <span class="id">gd2yz</span> <span class="id">deE</span>.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">e2</span> &lt;= <span class="id">d2</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e2d2</span>; <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">z</span>, <span class="id">n</span>.+1, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d1</span>); <span class="id">rewrite</span> // -[<span class="id">e1</span>]<span class="id">addr0</span> -(<span class="id">subrr</span> <span class="id">e2</span>) <span class="id">addrA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> -<span class="id">ler_subl_addr</span> <span class="id">opprK</span> <span class="id">ler_add</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> <span class="id">ler_addr</span>; <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_step_ball">rewrite</a></span> <span class="id">addn0</span>.<br/>
<span class="id">have</span> <span class="id">d1E</span>' : <span class="id">d1</span> = <span class="id">e1</span> + (<span class="id">e2</span> - <span class="id">d2</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">deE</span>; <span class="id">rewrite</span> <span class="id">addrA</span> [<span class="id">e1</span> + <span class="id">_</span>]<span class="id">addrC</span> =&gt; &lt;-; <span class="id">rewrite</span> -<span class="id"><a name="countable_uniform_pseudoMetricType_mixin">addrA</a></span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> -?<span class="id">real_ltNge</span> // ?<span class="id">num_real</span> // =&gt; <span class="id">d2lee2</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">IH</span> <span class="id">e1</span> (<span class="id">e2</span> - <span class="id">d2</span>) <span class="id">x</span> <span class="id">y</span>); <span class="id">rewrite</span> ?<span class="id">subr_gt0</span> // -<span class="id">d1E</span>' //.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t1</span> [<span class="id">t2</span>] [<span class="id">c1</span>] [<span class="id">c2</span>] [] <span class="id">Oxy1</span> <span class="id">gt1t2</span> <span class="id">t2y</span> &lt;-.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">t1</span>, <span class="id">t2</span>, <span class="id">c1</span>, <span class="id">c2</span>.+1; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d1</span>); <span class="id">rewrite</span> -?<span class="id">deE</span> // ?<span class="id">ler_addl</span>; <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> <span class="id">y</span>, (<span class="id">e2</span> - <span class="id">d2</span>), <span class="id">d2</span>; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#distN">rewrite</a></span> // ?<span class="id">subr_gt0</span>//.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">addrA</span> [-<span class="id">_</span> + <span class="id">_</span>]<span class="id">addrC</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addnS</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_le_g</span> <span class="id">x</span> <span class="id">n</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> 0 <span class="id">x</span> <span class="id">n</span>%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | <span class="id">g_</span> <span class="id">n</span> (<span class="id">x</span>,<span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof569')">Proof.</span></div>
<div class="proofscript" id="proof569">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] ?; <span class="id">rewrite</span> <span class="id">distN_nat</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">subset_n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">N</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">n_step_ball</a></span> <span class="id">n</span> <span class="id"><a name="sup_pseudometric.Ii">x</a></span> <span class="id">N</span>.+1%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | (<span class="id">g_</span> <span class="id">N</span>) (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof570')">Proof.</span></div>
<div class="proofscript" id="proof570">
<span class="id">move</span>: <span class="id">N</span> <span class="id">x</span>; <span class="id">elim</span>: <span class="id">n</span> {-2}<span class="id"><a name="sup_pseudometric.Icnt">n</a></span> (<span class="id">leqnn</span> <span class="id">n</span>) =&gt; <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt; <span class="id">N</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a name="sup_pseudometric.TS">n_step_ball_le_g</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> ?; <span class="id">exact</span>: <span class="id">descendG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">IH1</span> + + <span class="id">N</span> <span class="id">x1</span> <span class="id">x4</span>; <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [?] <span class="id">P</span>; <span class="id">apply</span>: <span class="id">descendG</span> <span class="id">_</span> <span class="id">P</span>; <span class="id">rewrite</span> <span class="id">distN_nat</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">l</span> <span class="id">ln1</span> <span class="id">Ox1x4</span>.<br/>
<span class="id">case</span>: (@<span class="id">split_n_step_ball</span> <span class="id">l</span> <span class="id">x1</span> (<span class="id">N</span>.+1%:<span class="id"><a href="mathcomp.analysis.topology.html#countable_uniform_pseudoMetricType_mixin">R</a></span>^-1/2) (<span class="id">N</span>.+1%:<span class="id">R</span>^-1/2) <span class="id">x4</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">splitr</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">x2</span> [<span class="id">x3</span>] [<span class="id">l1</span>] [<span class="id">l2</span>] [] <span class="id">P1</span> [? +] <span class="id">P3</span> <span class="id">l1l2</span>; <span class="id">rewrite</span> -<span class="id">splitr</span> <span class="id">distN_nat</span> =&gt; ?.<br/>
<span class="id">have</span> <span class="id">l1n</span> : (<span class="id">l1</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">leq_trans</span> (<span class="id">leq_addr</span> <span class="id">l2</span> <span class="id">l1</span>))// <span class="id">l1l2</span> -<span class="id">ltnS</span>.<br/>
<span class="id">have</span> <span class="id">l2n</span> : (<span class="id">l2</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">leq_trans</span> (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">leq_addl</a></span> <span class="id">l1</span> <span class="id">l2</span>))// <span class="id">l1l2</span> -<span class="id">ltnS</span>.<br/>
<span class="id">apply</span>: <span class="id">splitG3</span>; <span class="kwd">exists</span> <span class="id">x3</span>; [<span class="kwd">exists</span> <span class="id">x2</span> =&gt; //|].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span> <span class="id">N</span>))/(<span class="id">IH1</span> <span class="id">_</span> <span class="id">l1n</span>) : <span class="id">P1</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span> <span class="id">N</span>))/(<span class="id">IH1</span> <span class="id">_</span> <span class="id">l2n</span>) : <span class="id">P3</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">subset_step_ball</span> <span class="id">x</span> <span class="id">N</span> :<br/>
&nbsp;&nbsp;<span class="id">step_ball</span> <span class="id">x</span> <span class="id">N</span>.+1%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | (<span class="id">g_</span> <span class="id">N</span>) (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof571')">Proof.</span></div>
<div class="proofscript" id="proof571">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] <span class="id">n</span>; <span class="id">exact</span>: <span class="id">subset_n_step_ball</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">step_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof572')">Proof.</span></div>
<div class="proofscript" id="proof572">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">E</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">e</span> /= <span class="id">epos</span> <span class="id">esubE</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">filterS</a></span> <span class="id">esubE</span>); <span class="id">exact</span>: <span class="id">entourage_nball</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">case</a></span>: (<span class="id">countableBase</span> <span class="id">entE</span>) =&gt; <span class="id">N</span> <span class="id">fN</span>.<br/>
<span class="kwd">exists</span> <span class="id">N</span>.+2%:<span class="id">R</span>^-1; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">invr_gt0</span>.<br/>
<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">fN</span>); <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#set">gsubf</a></span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> /= <span class="id">N1ball</span>; <span class="id">apply</span>: (@<span class="id">subset_step_ball</span> <span class="id">x</span> <span class="id">N</span>.+1).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniform_pseudoMetricType_mixin</span> := <span class="id">PseudoMetric.Mixin</span><br/>
&nbsp;&nbsp;<span class="id">step_ball_center</span> <span class="id">step_ball_sym</span> <span class="id">step_ball_triangle</span> <span class="id">step_ball_entourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniform_bounded</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">U</span> := <span class="id">PseudoMetricType</span> <span class="id">_</span> <span class="id">countable_uniform_pseudoMetricType_mixin</span><br/>
&nbsp;&nbsp;<span class="kwd">in</span> @<span class="id">ball</span> <span class="id">_</span> <span class="id">U</span> <span class="id">x</span> 2 <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof573')">Proof.</span></div>
<div class="proofscript" id="proof573">
<span class="id">rewrite</span> /<span class="id">ball</span>; <span class="kwd">exists</span> <span class="id">O</span>%<span class="id">N</span>; <span class="id">rewrite</span> /<span class="id">n_step_ball</span>; <span class="id">split</span>; <span class="id">rewrite</span> // /<span class="id">distN</span>. <br/>
<span class="id">suff</span> -&gt; : @<span class="id">floor</span> <span class="id">R</span> 2^-1 = 0 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">absz0</span> /=.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">apply</a></span>/<span class="id">eqP</span>; <span class="id">rewrite</span> -[<span class="id">_</span> == <span class="id">_</span>]<span class="id">negbK</span>; <span class="id">rewrite</span> <span class="id">floor_neq0</span> <span class="id">negb_or</span> -?<span class="id">ltNge</span> -?<span class="id">leNgt</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">andP</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> <span class="id">invf_lt1</span> //= <span class="id">ltr_addl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">countable_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sup_pseudometric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realType</span>) (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">Ii</span> : <span class="kwd">Type</span>).<br/>
<span class="kwd">Variable</span> (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">Icnt</span> : <span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">I</span> : <span class="id">choiceType</span> := <span class="id">classicType_choiceType</span> <span class="id">Ii</span>.<br/>
<span class="kwd">Let</span> <span class="id">TS</span> := <span class="kwd">fun</span> <span class="id"><a name="subspace_pointedType">i</a></span> =&gt; <span class="id">PseudoMetric.Pack</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">Tc</a></span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniformityT</span> := @<span class="id">countable_sup_ent</span> <span class="id">T</span> <span class="id">Ii</span> <span class="id">Tc</span> <span class="id">Icnt</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">i</span> =&gt; @<span class="id">countable_uniformity_metric</span> <span class="id">_</span> (<span class="id">TS</span> <span class="id">i</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_pseudoMetric_mixin</span> := @<span class="id">countable_uniform_pseudoMetricType_mixin</span> <span class="id">R</span><br/>
&nbsp;&nbsp;(<span class="id">sup_uniformType</span> <span class="id">Tc</span>) <span class="id">countable_uniformityT</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspace_filter">sup_pseudoMetricType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">sup_uniformType</span> <span class="id">Tc</span>) <span class="id">sup_pseudoMetric_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">sup_pseudometric</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_pseudometric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspaceP">realType</a></span>) (<span class="id">Ii</span> : <span class="id">countType</span>) (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">pseudoMetricType</a></span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">Icnt</span> : <span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">product_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">sup_pseudoMetricType</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">PseudoMetric.class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_pseudoMetricType</span> (<span class="kwd">fun</span> <span class="id">f</span> : <span class="id">dep_arrow_pointedType</span> <span class="id">Tc</span> =&gt; <span class="id">f</span> <span class="id">i</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Icnt</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">product_pseudometric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">T</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">subspace</span> {<span class="id">T</span>} <span class="id">_</span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">incl_subspace</span> {<span class="id">T</span> <span class="id">A</span>} (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) : <span class="id">T</span> := <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Subspace</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_subspace</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within">set</a></span> (<span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">subspace</a></span> <span class="id">A</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> <span class="kwd">then</span> <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>) <span class="kwd">else</span> <span class="id">globally</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">x</a></span>].<br/>
<br/>
<span class="kwd">Variant</span> <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> : <span class="kwd">Prop</span> -&gt; <span class="kwd">Prop</span> -&gt; <span class="id">bool</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>) -&gt; <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id">WithinSubspace</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> <span class="id">True</span> <span class="id">False</span> <span class="id">true</span> (<span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>))<br/>
&nbsp;&nbsp;| <span class="id">WithoutSubspace</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> <span class="id">False</span> <span class="id">True</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">false</a></span> (<span class="id">globally</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">nbhs_subspaceP</a></span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs_subspace_spec</span> <span class="id">x</span> (<span class="id">A</span> <span class="id">x</span>) (~ <span class="id">A</span> <span class="id">x</span>) (<span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span>) (<span class="id">nbhs_subspace</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof574')">Proof.</span></div>
<div class="proofscript" id="proof574">
<span class="id">rewrite</span> /<span class="id">nbhs_subspace</span>; <span class="id">case</span>:(<span class="id">boolP</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">x</a></span> \<span class="kwd">in</span> <span class="id">A</span>)); <span class="id">rewrite</span> ?(<span class="id">inE</span>, <span class="id">notin_set</span>) =&gt; <span class="id">xA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">propext</span> (<span class="id">A</span> <span class="id">x</span>) <span class="id">True</span>)// <span class="id">not_True</span>; <span class="id">constructor</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">propext</span> (<span class="id">A</span> <span class="id">x</span>) <span class="id">False</span>)// <span class="id">not_False</span>; <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_in</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">within</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">A</a></span> (<span class="id">nbhs</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#in_setP">x</a></span>) = <span class="id">nbhs_subspace</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof575')">Proof.</span></div>
<div class="proofscript" id="proof575">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_out</span> (<span class="id">x</span> : <span class="id">T</span>) : ~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">globally</span> [<span class="id">set</span> <span class="id">x</span>] = <span class="id">nbhs_subspace</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof576')">Proof.</span></div>
<div class="proofscript" id="proof576">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_filter</span> (<span class="id"><a name="nbhs_subspace_interior">x</a></span> : <span class="id">subspace</span> <span class="id">A</span>) : <span class="id">ProperFilter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof577')">Proof.</span></div>
<div class="proofscript" id="proof577">
<span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; ?; <span class="id">last</span> <span class="id">exact</span>: <span class="id">globally_properfilter</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">within_nbhs_proper</span>; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_pointedType</span> := <span class="id">PointedType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">subspace</a></span> <span class="id">A</span>) <span class="id">point</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_filteredType</span> :=<br/>
&nbsp;&nbsp;<span class="id">FilteredType</span> (<span class="id">subspace</span> <span class="id">A</span>) (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">nbhs_subspace</span>.<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_topologicalMixin</span> :<br/>
&nbsp;&nbsp;<span class="id">Topological.mixin_of</span> (<span class="id">nbhs_subspace</span>) := @<span class="id">topologyOfFilterMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">subspace</span> <span class="id">A</span>) <span class="id">nbhs_subspace</span> <span class="id">nbhs_subspace_filter</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof578')">Next Obligation.</span></div>
<div class="proofscript" id="proof578">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">A0</span>; <span class="id">case</span>: <span class="id"><a name="open_subspace1out">nbhs_subspaceP</a></span> =&gt; ? =&gt; [/<span class="id">nbhs_singleton</span>|]; <span class="id">apply</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof579')">Next Obligation.</span></div>
<div class="proofscript" id="proof579">
<span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">A0</span>; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; [|] <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs_interior</a></span>; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">y</span> <span class="id">A0y</span> <span class="id">Ay</span>; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> <span class="id">x</span> -&gt;; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_topologicalMixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_cvgP</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">A</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt; (<span class="id">F</span> --&gt; <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof580')">Proof.</span></div>
<div class="proofscript" id="proof580">
 <span class="kwd">by</span> <span class="id">case</span>: (<span class="id">y</span> <span class="kwd">in</span> <span class="id">F</span> --&gt; <span class="id">y</span>) / <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_continuousP</span> {<span class="id">S</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">S</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">f</span> @ <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>) --&gt; <span class="id">f</span> <span class="id">x</span>) .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof581')">Proof.</span></div>
<div class="proofscript" id="proof581">
<span class="id">split</span> =&gt; [<span class="id">ctsf</span> <span class="id">x</span> <span class="id">Ax</span> <span class="id">W</span> /=|<span class="id">wA</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">x</a></span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> //= <span class="id">nbhs_subspace_in</span> //=; <span class="id">apply</span>: <span class="id">ctsf</span>.<br/>
<span class="id">case</span>: (<span class="id">y</span> <span class="kwd">in</span> <span class="id">_</span> @[<span class="id">_</span> --&gt; <span class="id">y</span>]) / (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; <span class="id">Ax</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">cvg_trans</span> <span class="id">_</span> (<span class="id">wA</span> <span class="id">_</span> <span class="id">Ax</span>)).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">nbhs_singleton</span> //= ?; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_eq_continuous</span> {<span class="id">S</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> <span class="id">g</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">continuous</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof582')">Proof.</span></div>
<div class="proofscript" id="proof582">
<span class="id">rewrite</span> ?<span class="id">subspace_continuousP</span>=&gt; <span class="id">feq</span> <span class="id">L</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">rewrite</span> -(<span class="id">feq</span> <span class="id">x</span>) ?<span class="id">inE</span> //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#closed">L</a></span> <span class="id">x</span> <span class="id">Ax</span>); <span class="id">apply</span>: <span class="id">fmap_within_eq</span>=&gt; ? ?; <span class="id">rewrite</span> <span class="id">feq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace_in</span> {<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceIT">topologicalType</a></span>} (<span class="id">f</span> : <span class="id">subspace</span> <span class="id"><a href="mathcomp.analysis.topology.html#open0">A</a></span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof583')">Proof.</span></div>
<div class="proofscript" id="proof583">
<span class="id">rewrite</span> <span class="id">propeqE</span> <span class="id">in_setP</span> <span class="id">subspace_continuousP</span>/<span class="id">filter_of</span>/<span class="id">nbhs</span> //=; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Q</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; //=; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">x</span> <span class="id">Ax</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">Ax</span>); <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; //=; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_interior</span> (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span>^° <span class="id">x</span> -&gt; <span class="id">nbhs</span> <span class="id">x</span> = (<span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof584')">Proof.</span></div>
<div class="proofscript" id="proof584">
<span class="id">move</span>=&gt; /[<span class="id">dup</span>] /[<span class="id">dup</span>] /<span class="id">interior_subset</span> ? /<span class="id">within_interior</span> &lt;- ?.<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">RHS</span> / <span class="id">nbhs_subspaceP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_ex</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">A</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) <span class="id">U</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">V</span>, <span class="id"><a href="mathcomp.analysis.topology.html#withinE">nbhs</a></span> (<span class="id">x</span> : <span class="id">T</span>) <span class="id">V</span> &amp; <span class="id">U</span> `&amp;` <span class="id">A</span> = <span class="id">V</span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof585')">Proof.</span></div>
<div class="proofscript" id="proof585">
 <span class="kwd">by</span> <span class="id">case</span>: (<span class="id">nbhs</span> <span class="id">_</span>) / <span class="id">nbhs_subspaceP</span>; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">rewrite</a></span> // ?<span class="id">withinE</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">incl_subspace_continuous</span> : <span class="id">continuous</span> <span class="id">incl_subspace</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof586')">Proof.</span></div>
<div class="proofscript" id="proof586">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">apply</a></span>/<span class="id">subspace_continuousP</span> =&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceOpen</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspace1out</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) : ~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">open</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof587')">Proof.</span></div>
<div class="proofscript" id="proof587">
<span class="id">move</span>=&gt; /<span class="id">nbhs_subspace_out</span> <span class="id">E</span>; <span class="id">have</span> : <span class="id">nbhs</span> <span class="id">x</span> [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">nbhs</span> //= -<span class="id">E</span>.<br/>
<span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; [[<span class="id">U</span> []]] <span class="id">oU</span> <span class="id">Ux</span> <span class="id">Usub</span>; <span class="id">suff</span> : <span class="id">U</span> = [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">move</span>=&gt; &lt;-.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; // <span class="id">t</span> -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspace_out</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">U</span> `&lt;=` ~` <span class="id">A</span> -&gt; <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof588')">Proof.</span></div>
<div class="proofscript" id="proof588">
<span class="id">move</span>=&gt; <span class="id">Usub</span>; <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">U</span> = \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">U</span>) [<span class="id">set</span> <span class="id">i</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; ? ?; <span class="id">apply</span>: <span class="id">open_subspace1out</span>; <span class="id">exact</span>: <span class="id">Usub</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span>; [<span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">x</span>|<span class="id">case</span>=&gt; <span class="id">i</span> ? -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceT</span> : <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#openC">A</a></span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof589')">Proof.</span></div>
<div class="proofscript" id="proof589">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id"><a href="mathcomp.classical.boolp.html#eq_exists">case</a></span>: <span class="id">nbhs_subspaceP</span> =&gt; //= ? ?; <span class="id">apply</span>: <span class="id">withinT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceIT</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#congr1">U</a></span> `&amp;` <span class="id">A</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof590')">Proof.</span></div>
<div class="proofscript" id="proof590">
<span class="id">apply</span>/<span class="id">propext</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oU</span>; <span class="id"><a name="open_subspaceW">apply</a></span>: <span class="id">openI</span> =&gt; //; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">apply</a></span>: <span class="id">open_subspaceT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">U</span> = (<span class="id">U</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">U</span> `&amp;` ~`<span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">openU</span> =&gt; //; <span class="id">apply</span>: <span class="id">open_subspace_out</span> =&gt; ? [].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">setIUr</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#closed">setUCr</a></span> <span class="id">setIT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceTI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceW">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>)) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof591')">Proof.</span></div>
<div class="proofscript" id="proof591">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">open_subspaceIT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceT</span> : <span class="id">closed</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof592')">Proof.</span></div>
<div class="proofscript" id="proof592">
<span class="id">rewrite</span> -(<span class="id">setCK</span> <span class="id">A</span>);<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.boolp.html#propext">apply</a></span>: <span class="id">open_closedC</span>; <span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> <span class="id">setICl</span>; <span class="id">exact</span>: <span class="id">open0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>, <span class="id">open</span> (<span class="id">V</span> : <span class="id"><a href="mathcomp.analysis.topology.html#subspace">set</a></span> <span class="id">T</span>) /\ <span class="id">V</span> `&amp;` <span class="id">A</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">U</a></span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof593')">Proof.</span></div>
<div class="proofscript" id="proof593">
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> <span class="id">UV</span>]]]; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> -<span class="id">UV</span> =&gt; <span class="id">x</span> //= []; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">withinE</a></span> /= =&gt; <span class="id">Ax</span> <span class="id">Vx</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">oV</span>; <span class="id">rewrite</span> <span class="id">openE</span>; <span class="id">exact</span>.<br/>
<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> =&gt; <span class="id">oUA</span>.<br/>
<span class="id">have</span> <span class="id"><a href="mathcomp.analysis.topology.html#closedI">oxF</a></span> <span class="id">x</span> : (<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span> -&gt; <span class="kwd">exists2</span> <span class="id">V</span>, <span class="id">open_nbhs</span> <span class="id">x</span> <span class="id">V</span> &amp; <span class="id">V</span> `&amp;` <span class="id">A</span> `&lt;=` <span class="id">U</span> `&amp;` <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">dup</span>] <span class="id">UAx</span> [<span class="id">Ux</span> <span class="id">Ax</span>]; <span class="id">move</span>: (<span class="id">oUA</span> <span class="id">_</span> <span class="id">UAx</span>); <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; // <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">withinE</span> /= =&gt; -[<span class="id">V</span> <span class="id">nbhsV</span>]; <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span> =&gt; <span class="id">UV</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>^°; <span class="id">rewrite</span> ?<span class="id">open_nbhsE</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id"><a href="mathcomp.analysis.topology.html#closure">exact</a></span>: <span class="id">open_interior</span>|<span class="id">exact</span>: <span class="id">nbhs_interior</span>].<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span> =&gt; <span class="id">t</span> [/<span class="id">interior_subset</span>].<br/>
<span class="id">pose</span> <span class="id">f</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">pselect</span> ((<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span>) <span class="id">is</span> <span class="id">left</span> <span class="id">e</span> <span class="kwd">then</span> <span class="id">projT1</span> (<span class="id">cid2</span> (<span class="id">oxF</span> <span class="id">x</span> <span class="id">e</span>)) <span class="kwd">else</span> <span class="id">set0</span>.<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">f</span> <span class="id">x</span>); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">i</span> <span class="id">UAi</span>; <span class="id">rewrite</span> /<span class="id">f</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; // ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; //= <span class="id">W</span>; <span class="id">rewrite</span> <span class="id">open_nbhsE</span> =&gt; -[].<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span> /<span class="id">f</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">t</a></span> [[<span class="id">u</span> <span class="id">UAu</span>]] /=; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; /= <span class="id">W</span> <span class="id">_</span> + ? ?; <span class="id">exact</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">UAt</span>; <span class="id"><a href="mathcomp.classical.classical_sets.html#setSI">split</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#closureE">case</a></span>: <span class="id">UAt</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">t</a></span> =&gt; //; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= -[<span class="id">Ut</span> <span class="id">At</span>]; <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; //= <span class="id">W</span> [].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>, <span class="id"><a name="subspace_hausdorff">closed</a></span> (<span class="id">V</span> : <span class="id">set</span> <span class="id">T</span>) /\ <span class="id">V</span> `&amp;` <span class="id">A</span> = <span class="id">U</span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof594')">Proof.</span></div>
<div class="proofscript" id="proof594">
<span class="id">rewrite</span> -<span class="id">openC</span> <span class="id">open_subspaceP</span>.<br/>
<span class="id">under</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> &lt;-&gt; <span class="id">X</span>] <span class="id">eq_exists</span> =&gt; <span class="id">V</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">openC</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; -[<span class="id">V</span> [? <span class="id">VU</span>]]; <span class="kwd">exists</span> (~` <span class="id">V</span>); <span class="id">split</span>; <span class="id">rewrite</span> ?<span class="id">setCK</span> //;<br/>
&nbsp;&nbsp;<span class="id">move</span>/(<span class="id">congr1</span> <span class="id">setC</span>): <span class="id">VU</span>; <span class="id">rewrite</span> ?<span class="id">eqEsubset</span> ?<span class="id">setCI</span> ?<span class="id">setCK</span>; <span class="id">firstorder</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) -&gt; <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#subspace">U</a></span> : <span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">subspace</a></span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof595')">Proof.</span></div>
<div class="proofscript" id="proof595">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">oU</a></span>; <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">U</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) -&gt; <span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof596')">Proof.</span></div>
<div class="proofscript" id="proof596">
  <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">closed_openC</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">open_subspaceW</a></span>/<span class="id">open_closedC</span>; <span class="id">rewrite</span> <span class="id">setCK</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_setIS</span> (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#subspace_cvgP">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof597')">Proof.</span></div>
<div class="proofscript" id="proof597">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">rewrite</span> <span class="id">open_subspaceP</span>.<br/>
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> &lt;-]]]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">openI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="kwd">exists</span> (<span class="id">U</span> `&amp;` <span class="id">A</span>); <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_setSI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">U</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof598')">Proof.</span></div>
<div class="proofscript" id="proof598">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">setIC</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">open_setIS</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_setIS</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">closed</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) = <span class="id">closed</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof599')">Proof.</span></div>
<div class="proofscript" id="proof599">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">rewrite</span> <span class="id">closed_subspaceP</span>.<br/>
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> &lt;-]]]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">closedI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="kwd">exists</span> (<span class="id">U</span> `&amp;` <span class="id">A</span>); <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_setSI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">A</span> `&amp;` <span class="id">U</span>) = <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceP">closed</a></span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof600')">Proof.</span></div>
<div class="proofscript" id="proof600">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">setIC</span> <span class="id">closed_setIS</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">U</a></span> `&lt;=` <span class="id">A</span> -&gt; <span class="id">closure</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) = <span class="id">closure</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof601')">Proof.</span></div>
<div class="proofscript" id="proof601">
<span class="id">have</span> /<span class="id">closed_subspaceP</span> := (@<span class="id">closed_closure</span> <span class="id">_</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>))).<br/>
<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#subspace">V</a></span>] [<span class="id">clV</span> <span class="id">VAclUA</span>] /[<span class="id">dup</span>] /(@<span class="id">closure_subset</span> <span class="id">subspace_topologicalType</span>).<br/>
<span class="id">have</span>/<span class="id">closure_id</span> &lt;- := (<span class="id">closed_subspaceT</span>) =&gt; /<span class="id">setIidr</span> &lt;-; <span class="id">rewrite</span> <span class="id">setIC</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">UsubA</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">setSI</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspace_filter">closureE</a></span>; <span class="id">apply</span>: <span class="id">smallest_sub</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_subspaceW</span>; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> -<span class="id">VAclUA</span>; <span class="id">apply</span>: <span class="id">setSI</span>; <span class="id">rewrite</span> <span class="id">closureE</span> //=; <span class="id">apply</span>: <span class="id">smallest_sub</span> =&gt; //.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span> (@<span class="id">subIsetl</span> <span class="id">_</span> <span class="id">V</span> <span class="id">A</span>); <span class="id">rewrite</span> <span class="id">VAclUA</span> <span class="id">subsetI</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">exact</span>: (@<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">U</span> : <span class="id"><a name="SubspaceRelative">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>))).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_hausdorff</span> :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">hausdorff_space</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">topologicalType</a></span> <span class="id">of</span> <span class="id">subspace</span> <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof602')">Proof.</span></div>
<div class="proofscript" id="proof602">
<span class="id">rewrite</span> ?<span class="id">open_hausdorff</span> =&gt; + <span class="id">x</span> <span class="id">y</span> <span class="id">xNy</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xNy</span>).<br/>
<span class="id">move</span>=&gt; [[<span class="id">P</span> <span class="id">Q</span>]] /= [<span class="id">Px</span> <span class="id">Qx</span>] /= [/<span class="id">open_subspaceW</span> <span class="id">oP</span> /<span class="id">open_subspaceW</span> <span class="id">oQ</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id">Q</span>).<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">SubspaceOpen</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_subspaceIP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt; <span class="id">compact</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof603')">Proof.</span></div>
<div class="proofscript" id="proof603">
<span class="id">rewrite</span> ?<span class="id">compact_ultra</span> /=.<br/>
<span class="id">split</span>=&gt; + <span class="id">F</span> <span class="id">UF</span> <span class="id">FUA</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span> <span class="id">FUA</span>) [<span class="id">x</span>] [[<span class="id">Ux</span> <span class="id">Ax</span>] <span class="id">Fp</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>=&gt; //; <span class="id">move</span>/<span class="id">subspace_cvgP</span>: <span class="id">Fp</span> =&gt; /(<span class="id">_</span> <span class="id">Ax</span>) <span class="id">Fx</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span>; [<span class="id">exact</span>: <span class="id">Fx</span> | <span class="id">exact</span>: <span class="id">cvg_within</span>].<br/>
<span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>/<span class="id">subspace_cvgP</span> =&gt; //.<br/>
<span class="id"><a name="nbhs_subspaceT">rewrite</a></span> <span class="id">withinE</span> =&gt; <span class="id">W</span>/= -[<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">V</a></span> <span class="id">nbhsV</span> <span class="id">WV</span>]; <span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">V</span> `&amp;` (<span class="id">U</span> `&amp;` <span class="id">A</span>)) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> -<span class="id">setIA</span> [<span class="id">A</span> `&amp;` <span class="id">_</span>]<span class="id">setIC</span> -<span class="id">WV</span>=&gt;?[]?[].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> //; <span class="id">exact</span>: <span class="id">Fp</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_connectedP</span> : <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">U</span>, @<span class="id">clopen</span> (<span class="id">subspace_topologicalType</span>) <span class="id">U</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U</span> `&lt;=` <span class="id">A</span>  -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; <span class="id">U</span> = <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof604')">Proof.</span></div>
<div class="proofscript" id="proof604">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">U</span> [/<span class="id">open_subspaceP</span> <span class="id">oU</span> /<span class="id">closed_subspaceP</span> <span class="id">cU</span>] <span class="id">UA</span> <span class="id">U0</span>; <span class="id">apply</span> =&gt; //.<br/>
&nbsp;&nbsp;- <span class="id">case</span>: <span class="id">oU</span> =&gt; <span class="id">V</span> [<span class="id">oV</span> <span class="id">VAUA</span>]; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">rewrite</span> // <span class="id">setIC</span> <span class="id">VAUA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>.<br/>
&nbsp;&nbsp;- <span class="id">case</span>: <span class="id">cU</span> =&gt; <span class="id">V</span> [<span class="id">cV</span> <span class="id">VAUA</span>]; <span class="kwd">exists</span> <span class="id">V</span> =&gt; //; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">VAUA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">clpnA</span> <span class="id">U</span> <span class="id">Un0</span> [<span class="id">V</span> <span class="id">oV</span> <span class="id">UVA</span>] [<span class="id">W</span> <span class="id">cW</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceRelative.T">UWA</a></span>]; <span class="id">apply</span>: <span class="id">clpnA</span> =&gt; //; <span class="id">first</span> <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">UVA</span> <span class="id">setIAC</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#in_setP">setIid</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">closed_subspaceP</span>; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">UWA</span> <span class="id">setIAC</span> <span class="id">setIid</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UWA</span>; <span class="id">exact</span>: <span class="id">subIsetl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Subspace</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">subspace_filter</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous_subspace_in">T</a></span>) (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>) := <span class="id">nbhs_subspace_filter</span> <span class="id">x</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">subspace_proper_filter</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>) := <span class="id">nbhs_subspace_filter</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">within</span>' <span class="id">A</span> , '<span class="id">continuous</span>' <span class="id">f</span> }" := (<span class="kwd">forall</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">fmap</span> <span class="id">f</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open">filter_of</a></span> (<span class="id">Phantom</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">x</span>))]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id"><a href="mathcomp.analysis.topology.html#open">filter</a></span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">f</a></span> <span class="id">x</span>]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceRelative</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">U</span> : <span class="id">topologicalType</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_subset</span> <span class="id">A</span> <span class="id">B</span> (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">B</span>) `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closed">nbhs</a></span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof605')">Proof.</span></div>
<div class="proofscript" id="proof605">
<span class="id">rewrite</span> /<span class="id">nbhs</span> //= =&gt; <span class="id">AB</span>; <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">A</span>); <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">B</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">apply</span>: <span class="id">within_subset</span> =&gt; //=; <span class="id">exact</span>: (<span class="id">nbhs_filter</span> <span class="id">x</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">AB</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Bx</span> ? <span class="id">W</span> /<span class="id">nbhs_singleton</span> /(<span class="id">_</span> <span class="id">Bx</span>) ? ? -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceW</span> {<span class="id">U</span>} <span class="id">A</span> <span class="id">B</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#closed_subspaceP">U</a></span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof606')">Proof.</span></div>
<div class="proofscript" id="proof606">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">ctsF</span> ? ? ?; <span class="id">apply</span>: (@<span class="id">nbhs_subspace_subset</span> <span class="id">A</span> <span class="id">B</span>) =&gt; //; <span class="id">exact</span>: <span class="id">ctsF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspaceT</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">setT</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof607')">Proof.</span></div>
<div class="proofscript" id="proof607">
<span class="id">rewrite</span> {1}/<span class="id">nbhs</span> //=; <span class="id">have</span> [<span class="id">_</span>|] := <span class="id">nbhs_subspaceP</span> [<span class="id">set</span>: <span class="id">T</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">cbn</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span> <span class="id">withinE</span>; <span class="id">split</span> =&gt; [<span class="id">W</span> [<span class="id">V</span> <span class="id">nbhsV</span>]|<span class="id">W</span> ?]; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> 2!<span class="id">setIT</span> =&gt; -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceT_for</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> (<span class="id">f</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceIT">subspace</a></span> <span class="id">A</span> -&gt; <span class="id">U</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof608')">Proof.</span></div>
<div class="proofscript" id="proof608">
<span class="id">rewrite</span> /<span class="id">filter_of</span>/<span class="id">nbhs</span>/=/<span class="id">prop_for</span> =&gt; <span class="id">inA</span> <span class="id">ctsf</span>.<br/>
<span class="id">have</span> [<span class="id">_</span>|//] := <span class="id">nbhs_subspaceP</span> <span class="id">A</span> <span class="id">x</span>.<br/>
<span class="id">apply</span>: (<span class="id">cvg_trans</span> <span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">ctsf</a></span>); <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">apply</a></span>: <span class="id">cvg_fmap2</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">subspace</span>; <span class="id">exact</span>: <span class="id">nbhs_filter</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_in_subspaceT</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof609')">Proof.</span></div>
<div class="proofscript" id="proof609">
<span class="id">rewrite</span> <span class="id">continuous_subspace_in</span> ?<span class="id">in_setP</span> =&gt; <span class="id">ctsf</span> <span class="id">t</span> <span class="id">At</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">continuous_subspaceT_for</span> =&gt; //=; <span class="id">apply</span>: <span class="id">ctsf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceT</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof610')">Proof.</span></div>
<div class="proofscript" id="proof610">
<span class="id">move</span>=&gt; <span class="id">ctsf</span>; <span class="id">rewrite</span> <span class="id">continuous_subspace_in</span> =&gt; ? ?.<br/>
<span class="id">exact</span>: <span class="id">continuous_in_subspaceT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_open_subspace</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> <span class="id">A</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof611')">Proof.</span></div>
<div class="proofscript" id="proof611">
<span class="id">rewrite</span> <span class="id">openE</span> <span class="id">continuous_subspace_in</span> /= =&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">propeqE</span> ?<span class="id">in_setP</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; + <span class="id">x</span> /[<span class="id">dup</span>] <span class="id">Ax</span> /<span class="id">oA</span> <span class="id">Aox</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ax</span>);<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">filter_of</span> -(<span class="id">nbhs_subspace_interior</span> <span class="id">Aox</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_inP</span> {<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">U</a></span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} &lt;-&gt; <span class="kwd">forall</span> <span class="id">X</span>, <span class="id">open</span> <span class="id">X</span> -&gt; <span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">f</span> @^-1` <span class="id">X</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof612')">Proof.</span></div>
<div class="proofscript" id="proof612">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">continuous_open_subspace</span>// <span class="id">continuousP</span>.<br/>
<span class="kwd">by</span> <span class="id">under</span> <span class="id">eq_forall</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">open_setSI</span>//.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">withinU_continuous</span> {<span class="id">U</span>} <span class="id">A</span> <span class="id">B</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span> `|` <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof613')">Proof.</span></div>
<div class="proofscript" id="proof613">
<span class="id">move</span>=&gt; ? ? <span class="id">ctsA</span> <span class="id">ctsB</span>; <span class="id">apply</span>/<span class="id">continuous_closedP</span> =&gt; <span class="id">W</span> <span class="id">oW</span>.<br/>
<span class="id">case</span>/<span class="id">continuous_closedP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">oW</span>)/<span class="id">closed_subspaceP</span>: <span class="id">ctsA</span> =&gt; <span class="id">V1</span> [? <span class="id">V1W</span>].<br/>
<span class="id">case</span>/<span class="id">continuous_closedP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">oW</span>)/<span class="id">closed_subspaceP</span>: <span class="id">ctsB</span> =&gt; <span class="id">V2</span> [? <span class="id">V2W</span>].<br/>
<span class="id">apply</span>/<span class="id">closed_subspaceP</span>; <span class="kwd">exists</span> ((<span class="id">V1</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">V2</span> `&amp;` <span class="id">B</span>)); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedU</span>; <span class="id">exact</span>: <span class="id">closedI</span>.<br/>
<span class="id">rewrite</span> [<span class="id">RHS</span>]<span class="id">setIUr</span> -<span class="id">V2W</span> -<span class="id">V1W</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; [[][]] ? ? [] ?; [<span class="id">left</span> | <span class="id">left</span> | <span class="id">right</span> | <span class="id">right</span>]; <span class="id">split</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; [][] ? ?; <span class="id">split</span>=&gt; []; [<span class="id">left</span>; <span class="id">split</span> | <span class="id">left</span> | <span class="id">right</span>; <span class="id">split</span> | <span class="id">right</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspaceT_continuous</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : {<span class="kwd">fun</span> <span class="id">A</span> &gt;-&gt; <span class="id">B</span>}) :<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">continuous</span> (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">subspace</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof614')">Proof.</span></div>
<div class="proofscript" id="proof614">
<span class="id">move</span>=&gt; /<span class="id">continuousP</span> <span class="id">ctsf</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">O</span> /<span class="id">open_subspaceP</span> [<span class="id">V</span> [<span class="id">oV</span> <span class="id">VBOB</span>]].<br/>
<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span>; <span class="id">apply</span>/<span class="id">open_subspaceP</span>.<br/>
<span class="id">case</span>/<span class="id">open_subspaceP</span>: (<span class="id">ctsf</span> <span class="id">_</span> <span class="id">oV</span>) =&gt; <span class="id">W</span> [<span class="id">oW</span> <span class="id">fVA</span>]; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">rewrite</span> <span class="id">fVA</span> -<span class="id">setIA</span> <span class="id">setIid</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span> [<span class="id">fVx</span> <span class="id">Ax</span>]; <span class="id">split</span> =&gt; //.<br/>
- <span class="kwd">by</span> <span class="id">have</span> /[!<span class="id">VBOB</span>]-[] : (<span class="id">V</span> `&amp;` <span class="id">B</span>) (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
- <span class="kwd">by</span> <span class="id">have</span> /[!<span class="id">esym</span> <span class="id">VBOB</span>]-[] : (<span class="id">O</span> `&amp;` <span class="id">B</span>) (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace0</span> {<span class="id">U</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : {<span class="id">within</span> <span class="id">set0</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof615')">Proof.</span></div>
<div class="proofscript" id="proof615">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Q</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /= {2}/<span class="id">nbhs</span> /=.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> (@<span class="id">set0</span> <span class="id">T</span>) <span class="id">x</span>) =&gt; // <span class="id">_</span> /<span class="id">nbhs_singleton</span> /= ? ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace1</span> {<span class="id">U</span>} (<span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">a</a></span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">within</span> [<span class="id">set</span> <span class="id">a</span>], <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof616')">Proof.</span></div>
<div class="proofscript" id="proof616">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Q</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">nbhs_simpl</a></span> /= {2}/<span class="id">nbhs</span> /=.<br/>
<span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> [<span class="id">set</span> <span class="id">a</span>] <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">move</a></span>=&gt; <span class="id">_</span> /<span class="id">nbhs_singleton</span> /= ? ? -&gt;.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt; /<span class="id">nbhs_singleton</span> ?; <span class="id">apply</span>: <span class="id">nearW</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SubspaceRelative</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">SubspaceUniform</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">uniformType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">E</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | (<span class="id">xy</span>.1 = <span class="id">xy</span>.2) \/ (<span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">E</span> <span class="id">xy</span>)]).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_uniformMixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">Uniform.Mixin</span> (<span class="id">subspace</span> <span class="id">A</span>) (@<span class="id">nbhs_subspace</span> <span class="id">_</span> <span class="id">_</span>) <span class="id">subspace_ent</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof617')">Next Obligation.</span></div>
<div class="proofscript" id="proof617">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> (<span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">exact</span>: <span class="id">filterT</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">entP</span> <span class="id">entQ</span>; <span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /=; <span class="id">case</span>; <span class="id">first</span> (<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">split</span>=&gt; /=; <span class="id"><a name="subspace_uniformType">left</a></span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Ax</span> [<span class="id">Ay</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">Pxy</a></span> <span class="id">Qxy</span>]]]; <span class="id">split</span>=&gt; /=; <span class="id">right</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof618')">Next Obligation.</span></div>
<div class="proofscript" id="proof618">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? + [<span class="id">x</span> <span class="id">y</span>]/= -&gt;; <span class="id">case</span>=&gt; <span class="id">V</span> <span class="id">entV</span>; <span class="id">apply</span>; <span class="id">left</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof619')">Next Obligation.</span></div>
<div class="proofscript" id="proof619">
<span class="id">move</span>=&gt; ?; <span class="id">case</span>=&gt; <span class="id">V</span> ? <span class="id">Vsub</span>; <span class="kwd">exists</span> (<span class="id">V</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /= <span class="id">G</span>; <span class="id">apply</span>: <span class="id">Vsub</span>; <span class="id">case</span>: <span class="id">G</span>; <span class="id">first</span> <span class="kwd">by</span> (<span class="id">move</span>=&gt; &lt;-; <span class="id">left</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [? [? <span class="id">Vxy</span>]]; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof620')">Next Obligation.</span></div>
<div class="proofscript" id="proof620">
<span class="id">move</span>=&gt; ?; <span class="id">case</span>=&gt; <span class="id">E</span> <span class="id">entE</span> <span class="id">Esub</span>.<br/>
<span class="kwd">exists</span>  [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">split_ent</span> <span class="id">E</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">E</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] [<span class="id">z</span> /= <span class="id">Ez</span> <span class="id">zE</span>] /=; <span class="id">case</span>: <span class="id">Ez</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ballxx">case</a></span>: <span class="id">zE</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt; -&gt;; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; [ ? []] ? <span class="id">G</span> <span class="id">xy</span>; <span class="id">subst</span>; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_split</span> =&gt; //=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; -&gt; [ ? []] ? <span class="id">G</span>; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_split</span> =&gt; //=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; []? []? ?[]?[]??; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof621')">Next Obligation.</span></div>
<div class="proofscript" id="proof621">
<span class="id">pose</span>  <span class="id">EA</span> := [<span class="id"><a href="mathcomp.analysis.topology.html#subspace_ball">set</a></span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2].<br/>
<span class="id">have</span> <span class="id">entEA</span> : <span class="id">subspace_ent</span> <span class="id">EA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [??] /= [ -&gt;|[?] [?]];[<span class="id">left</span>|<span class="id">right</span>].<br/>
<span class="id">rewrite</span> <span class="id">funeq2E</span>=&gt; <span class="id">x</span> <span class="id">U</span>.<br/>
<span class="id">case</span>: (@<span class="id">nbhs_subspaceP</span> <span class="id">X</span> <span class="id">A</span> <span class="id">x</span>); <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; //=.<br/>
- <span class="id">rewrite</span> <span class="id">withinE</span>; <span class="id">case</span>=&gt; <span class="id">V</span> /[<span class="id">dup</span>] <span class="id">nbhsV</span> =&gt; [/<span class="id">nbhsP</span> [<span class="id">E</span> <span class="id">entE</span> <span class="id">Esub</span>] <span class="id">UV</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">E</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span> =&gt; //= [[??]] /= [-&gt;| [?[]]//]; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">y</span> /= [&lt;-|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> : (<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span> <span class="kwd">by</span> <span class="id">case</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: (@<span class="id">nbhs_singleton</span> <span class="id">X</span>).<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">_</span> [<span class="id">Ay</span> <span class="id">Ey</span>]; <span class="id">suff</span> : (<span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#subspace_pseudoMetricType_mixin">A</a></span>) <span class="id">y</span> <span class="kwd">by</span> <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">Esub</span>.<br/>
- <span class="id">move</span>=&gt; [] <span class="id"><a name="SubspaceWeak">W</a></span> [<span class="id">E</span> <span class="id">eentE</span> <span class="id">subW</span>] <span class="id">subU</span> //=.<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">w</span>; <span class="id">apply</span>: <span class="id">subU</span>; <span class="id">apply</span>: <span class="id">subW</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">withinT</span> <span class="id">_</span> (@<span class="id">nbhs_filter</span> <span class="id">X</span> <span class="id">_</span>))).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">w</span>; <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">E</span> =&gt; // <span class="id">y</span> /= <span class="id">Ey</span>.<br/>
- <span class="id">move</span>=&gt; //= <span class="id">Ux</span>; <span class="kwd">exists</span> <span class="id">EA</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> /= [|[]] //= &lt;-; <span class="id">apply</span>: <span class="id">Ux</span>.<br/>
- <span class="id">rewrite</span> //= =&gt; [[<span class="id">W</span> [<span class="id">W</span>' <span class="id">entW</span>' <span class="id">subW</span>] <span class="id">subU</span>]] ? -&gt;.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subU</span>; <span class="id">apply</span>: <span class="id">subW</span>; <span class="id">left</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_uniformMixin</span>.<br/>
<span class="kwd">End</span> <span class="id">SubspaceUniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspacePseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">X</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_ball</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) (<span class="id">r</span> : <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> <span class="kwd">then</span> <span class="id">A</span> `&amp;` <span class="id">ball</span> (<span class="id">x</span> : <span class="id">X</span>) <span class="id">r</span> <span class="kwd">else</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">PseudoMetric.Mixin</span> <span class="id">R</span> (<span class="id">subspace</span> <span class="id">A</span>) (<span class="id">subspace_ent</span> <span class="id">A</span>) (<span class="id">subspace_ball</span>)<br/>
&nbsp;&nbsp;<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof622')">Next Obligation.</span></div>
<div class="proofscript" id="proof622">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; //= /<span class="id">asboolP</span> ? ?.<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">ballxx</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof623')">Next Obligation.</span></div>
<div class="proofscript" id="proof623">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">e</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; //= /<span class="id">asboolP</span> ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [] <span class="id">Ay</span> /<span class="id">ball_sym</span> <span class="id">yBx</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof624')">Next Obligation.</span></div>
<div class="proofscript" id="proof624">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">e1</span> <span class="id">e2</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; (<span class="id">repeat</span> <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt;?? [??] [??]; <span class="id">split</span> =&gt; //=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.f_">ball_triangle</a></span>; <span class="id">eauto</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ?? [??] -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; + /[<span class="id">swap</span>] =&gt; /[<span class="id">swap</span>] =&gt; -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> -&gt; -&gt;.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof625')">Next Obligation.</span></div>
<div class="proofscript" id="proof625">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">U</span> [<span class="id">W</span> + <span class="id">subU</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">eps</a></span>] <span class="id">nneg</span> <span class="id">subW</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">eps</span> =&gt; //; <span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">subU</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#open">x</a></span> <span class="id">y</span>] /=; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Ay</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">xBy</a></span>]; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subW</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.weakT">move</a></span>=&gt; -&gt;; <span class="id">left</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">eps</span> <span class="id">nneg</span> <span class="id">subE</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> (<span class="id">xy</span>.1 : <span class="id">X</span>) <span class="id">eps</span> <span class="id">xy</span>.2].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="kwd">exists</span> <span class="id">eps</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /= [-&gt;|[]<span class="id"><a href="mathcomp.analysis.topology.html#filterS">Ax</a></span> []<span class="id">Ay</span> <span class="id">xBy</span>]; <span class="id">apply</span>: <span class="id">subE</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">case</a></span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">ballxx</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">SubspacePseudoMetric</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceWeak</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">U</span> : <span class="id">pointedType</span>}.<br/>
<span class="kwd">Variables</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">U</span>' := <span class="id">weak_topologicalType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_subspace_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>') :<br/>
&nbsp;&nbsp;<span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">f</span> @` <span class="id">A</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closed_closure">set</a></span> (<span class="id">subspace</span> (<span class="id">range</span> <span class="id">f</span>))).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof626')">Proof.</span></div>
<div class="proofscript" id="proof626">
<span class="id">case</span>=&gt; <span class="id">B</span> <span class="id">oB</span> &lt;-; <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">B</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
<span class="id">split</span> =&gt; <span class="id">z</span> [] /[<span class="id">swap</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">w</span> <span class="id">_</span> &lt;- ?; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">w</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">w</span> <span class="id">_</span> &lt;- [<span class="id">v</span>] ? &lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SubspaceWeak</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">separate_points_from_closed</span> {<span class="id">I</span> : <span class="kwd">Type</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">U_</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>} (<span class="id">f_</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> -&gt; <span class="id">U_</span> <span class="id">i</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">U</span> -&gt; ~ <span class="id">U</span> <span class="id">x</span> -&gt; <span class="kwd">exists</span> <span class="id">i</span>, ~ (<span class="id">closure</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open">f_</a></span> <span class="id">i</span> @` <span class="id">U</span>)) (<span class="id">f_</span> <span class="id">i</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_embeddings</span>.<br/>
<span class="kwd">Context</span> {<span class="id">I</span> : <span class="id">choiceType</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">U_</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Variable</span> (<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">f_</a></span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> -&gt; <span class="id">U_</span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">sepf</span> : <span class="id">separate_points_from_closed</span> <span class="id">f_</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">ctsf</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">continuous</span> (<span class="id">f_</span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">weakT</span> := @<span class="id">sup_topologicalType</span> <span class="id">T</span> <span class="id">I</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">Topological.class</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">PU</span> := <span class="id">product_topologicalType</span> <span class="id">U_</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">sup_open</span> := (@<span class="id">open</span> <span class="id">weakT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "'<span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">weak_open</a></span>' <span class="id">i</span>" :=<br/>
&nbsp;&nbsp;(@<span class="id">open</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>))) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">natural_open</span> := (@<span class="id">open</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">T</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; (<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">T</span>)) &lt;-&gt; (<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">weakT</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof627')">Proof.</span></div>
<div class="proofscript" id="proof627">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">FTx</span>; <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">i</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /= -&gt; := @<span class="id">nbhsE</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>)) <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">B</span> [[<span class="id">C</span> <span class="id">oC</span> &lt;- ?]] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">FTx</span>; <span class="id">rewrite</span> /= <span class="id">nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f_</span> <span class="id">i</span> @^-1` <span class="id">C</span>) =&gt; //; <span class="id">split</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.f_">exact</a></span>: <span class="id">open_comp</span>.<br/>
<span class="id">move</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">wiFx</span> <span class="id">U</span>; <span class="id">rewrite</span> /= <span class="id">nbhs_simpl</span> <span class="id">nbhsE</span> =&gt; [[<span class="id">B</span> [<span class="id">oB</span> ?]]].<br/>
<span class="id">move</span>/<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">have</span> [//|<span class="id">i</span> <span class="id">nclfix</span>] := @<span class="id">sepf</span> <span class="id"><a href="mathcomp.analysis.topology.html#openI">_</a></span> <span class="id">x</span> (<span class="id">open_closedC</span> <span class="id">oB</span>).<br/>
<span class="id">apply</span>: (<span class="id">wiFx</span> <span class="id">i</span>); <span class="id">have</span> /= -&gt; := @<span class="id">nbhsE</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>)) <span class="id">x</span>.<br/>
<span class="kwd">exists</span> (<span class="id">f_</span> <span class="id">i</span> @^-1` (~` <span class="id">closure</span> [<span class="id">set</span> <span class="id">f_</span> <span class="id">i</span> <span class="id">x</span> | <span class="id"><a href="mathcomp.analysis.topology.html#proj_continuous">x</a></span> <span class="kwd">in</span> ~` <span class="id">B</span>])); [<span class="id">split</span>=&gt;//|].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">open_comp</span>; <span class="id"><a href="mathcomp.analysis.topology.html#accessible_space">last</a></span> <span class="kwd">by</span> <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">openC</a></span>; <span class="id">last</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">closed_closure</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">weak_continuous</span>.<br/>
<span class="id">rewrite</span> <span class="id">closureC</span> <span class="id">preimage_bigcup</span> =&gt; <span class="id">z</span> [<span class="id">V</span> [<span class="id">oV</span>]] <span class="id">VnB</span> =&gt; /<span class="id">VnB</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">forall2NP</span> =&gt; /(<span class="id">_</span> <span class="id">z</span>) [] // /<span class="id">contrapT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_nbhsE</span> <span class="id">x</span> : @<span class="id">nbhs</span> <span class="id">T</span> <span class="id">T</span> <span class="id">x</span> = @<span class="id">nbhs</span> <span class="id">T</span> <span class="id">weakT</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof628')">Proof.</span></div>
<div class="proofscript" id="proof628">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">U</span>; <span class="id">split</span>; <span class="id">move</span>: <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> <span class="id">P</span> := <span class="id">weak_sep_cvg</span> <span class="id">x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">weakT</span>)); <span class="id">exact</span>/<span class="id">P</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> <span class="id">P</span> := <span class="id">weak_sep_cvg</span> <span class="id">x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">T</span>)); <span class="id">exact</span>/<span class="id">P</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_openE</span> : @<span class="id">open</span> <span class="id">T</span> = @<span class="id">open</span> <span class="id">weakT</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof629')">Proof.</span></div>
<div class="proofscript" id="proof629">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">rewrite</span> ?<span class="id">openE</span> /<span class="id">interior</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; + <span class="id">z</span> =&gt; /(<span class="id">_</span> <span class="id">z</span>); <span class="id">rewrite</span> <span class="id">weak_sep_nbhsE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">join_product</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">PU</span> := <span class="id">f_</span> ^~ <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_continuous</span> : <span class="id">continuous</span> <span class="id">join_product</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof630')">Proof.</span></div>
<div class="proofscript" id="proof630">
<span class="id">suff</span> : <span class="id">continuous</span> (<span class="id">join_product</span> : <span class="id">weakT</span> -&gt; <span class="id">PU</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">cts</span> <span class="id">x</span> <span class="id">U</span> =&gt; /<span class="id">cts</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /= -<span class="id">weak_sep_nbhsE</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">x</span>; <span class="id">apply</span>/<span class="id">cvg_sup</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">fmap_filter</span>/(<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">weakT</span>)).<br/>
<span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">move</span>: <span class="id">x</span>; <span class="id">apply</span>/(@<span class="id">continuousP</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings">_</a></span> (<span class="id">weak_topologicalType</span> <span class="id">_</span>)) =&gt; <span class="id">A</span> [<span class="id">B</span> ? <span class="id">E</span>].<br/>
<span class="id">rewrite</span> -<span class="id">E</span> (<span class="id">_</span> : @^~ <span class="id">i</span> =  <span class="id">proj</span> <span class="id">i</span>) //.<br/>
<span class="id">have</span> -&gt; : <span class="id">join_product</span> @^-1` (<span class="id">proj</span> <span class="id">i</span> @^-1` <span class="id">B</span>) = <span class="id">f_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">i</a></span> @^-1` <span class="id">B</span> <span class="kwd">by</span> [].<br/>
<span class="id">apply</span>: <span class="id">open_comp</span> =&gt; // + <span class="id">_</span>; <span class="id">rewrite</span> /<span class="id">cvg_to</span> =&gt; <span class="id">x</span> <span class="id">U</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /= -<span class="id">weak_sep_nbhsE</span>; <span class="id">move</span>: <span class="id">x</span> <span class="id">U</span>; <span class="id">exact</span>: <span class="id">ctsf</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">prod_open</span> :=<br/>
&nbsp;&nbsp;(@<span class="id">open</span> (<span class="id">subspace_topologicalType</span> (<span class="id">range</span> <span class="id">join_product</span>))).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">open</span> ((<span class="id">join_product</span> @` <span class="id">A</span>) : <span class="id">set</span> (<span class="id">subspace</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">range</a></span> <span class="id">join_product</span>))).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof631')">Proof.</span></div>
<div class="proofscript" id="proof631">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">y</span> /= [<span class="id">x</span> <span class="id">Ax</span>] <span class="id"><a href="mathcomp.analysis.topology.html#compact_subspaceIP">jxy</a></span>.<br/>
<span class="id">have</span> [// | <span class="id">i</span> <span class="id">nAfiy</span>] := @<span class="id">sepf</span> (~` <span class="id">A</span>) <span class="id">x</span> (<span class="id">open_closedC</span> <span class="id">oA</span>).<br/>
<span class="id">pose</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">PU</span> := <span class="id">proj</span> <span class="id">i</span> @^-1` (~` <span class="id">closure</span> (<span class="id">f_</span> <span class="id">i</span> @` ~` <span class="id">A</span>)).<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#imageP">_</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id">range</span> <span class="id">join_product</span> `&amp;` <span class="id">B</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> [[<span class="id">w</span> ?]] <span class="id">wzE</span> <span class="id">Bz</span>; <span class="kwd">exists</span> <span class="id">w</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Bz</span>; <span class="id">rewrite</span> /<span class="id">B</span> -<span class="id">wzE</span> <span class="id">closureC</span>; <span class="id">case</span>=&gt; <span class="id">K</span> [<span class="id">oK</span> <span class="id">KsubA</span>] /<span class="id">KsubA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> -&gt; : <span class="id">proj</span> <span class="id">i</span> (<span class="id">join_product</span> <span class="id">w</span>) = <span class="id">f_</span> <span class="id">i</span> <span class="id">w</span> <span class="kwd">by</span> [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">exists2P</span>/<span class="id">forallNP</span>/(<span class="id">_</span> <span class="id">w</span>)/<span class="id">not_andP</span> [] // /<span class="id">contrapT</span>.<br/>
<span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">jxy</span>.<br/>
<span class="id">apply</span>: <span class="id">openI</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_subspaceT</span>.<br/>
<span class="id">apply</span>: <span class="id">open_subspaceW</span>; <span class="id">apply</span>: <span class="id">open_comp</span>; <span class="id">last</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_inj</span> : <span class="id">accessible_space</span> <span class="id">T</span> -&gt; <span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">join_product</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof632')">Proof.</span></div>
<div class="proofscript" id="proof632">
<span class="id">move</span>=&gt; /<span class="id">accessible_closed_set1</span> <span class="id">cl1</span> <span class="id">x</span> <span class="id">y</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">x</span> <span class="id">y</span>) =&gt; // <span class="id">xny</span> <span class="id">_</span> <span class="id">_</span> <span class="id">jxjy</span>.<br/>
<span class="id">have</span> [] := (@<span class="id">sepf</span> [<span class="id">set</span> <span class="id">y</span>] <span class="id">x</span> (<span class="id">cl1</span> <span class="id">y</span>)); <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">eqP</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">P</span>; <span class="id">suff</span> : <span class="id">join_product</span> <span class="id">x</span> <span class="id">i</span> != <span class="id">join_product</span> <span class="id">y</span> <span class="id">i</span> <span class="kwd">by</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#esym">rewrite</a></span> <span class="id">jxjy</span> =&gt; /<span class="id">eqP</span>.<br/>
<span class="id">apply</span>/<span class="id">negP</span>; <span class="id">move</span>: <span class="id">P</span>; <span class="id">apply</span>: <span class="id">contra_not</span> =&gt; /<span class="id">eqP</span>; <span class="id">rewrite</span> /<span class="id">join_product</span> =&gt; -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_closure</span>; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_weak</span> : <span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">join_product</span> -&gt;<br/>
&nbsp;&nbsp;@<span class="id">open</span> <span class="id">T</span> = @<span class="id">open</span> (<span class="id">weak_topologicalType</span> <span class="id">join_product</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof633')">Proof.</span></div>
<div class="proofscript" id="proof633">
<span class="id">move</span>=&gt; <span class="id">inj</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">U</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">V</span> ? &lt;-]; <span class="id">apply</span>: <span class="id">open_comp</span> =&gt; // + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">join_product_continuous</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">join_product_open</span>/<span class="id">open_subspaceP</span> [<span class="id">V</span> [<span class="id">oU</span> <span class="id">VU</span>]].<br/>
<span class="kwd">exists</span> <span class="id">V</span> =&gt; //; <span class="id">have</span> := @<span class="id">f_equal</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">preimage</span> <span class="id">join_product</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">VU</span>.<br/>
<span class="id">rewrite</span> !<span class="id">preimage_setI</span> // !<span class="id">preimage_range</span> !<span class="id">setIT</span> =&gt; -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">preimage_image</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id">w</span> <span class="id">Uw</span>] /<span class="id">inj</span> &lt;- //; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">product_embeddings</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_compact</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">A</span> :<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">compact</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof634')">Proof.</span></div>
<div class="proofscript" id="proof634">
<span class="id">move</span>=&gt; <span class="id">fcont</span> <span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FfA</span>; <span class="id">set</span> <span class="id">G</span> := <span class="id">filter_from</span> <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">C</span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">A</a></span> `&amp;` <span class="id">f</span> @^-1` <span class="id">C</span>).<br/>
<span class="id">have</span> <span class="id">GF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">ProperFilter</a></span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filter_from_proper</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#image_subset">filter_from_filter</a></span> <span class="id">_</span> <span class="id">_</span>)).<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">C1</span> <span class="id">C2</span> <span class="id">F1</span> <span class="id">F2</span>; <span class="kwd">exists</span> (<span class="id">C1</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#closed">C2</a></span>); [<span class="id">exact</span>: <span class="id">filterI</span>|<span class="id">move</span>=&gt; ? [? []]].<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">C</span> /(<span class="id">filterI</span> <span class="id">FfA</span>) /<span class="id">filter_ex</span> [<span class="id">_</span> [[<span class="id">p</span> ? &lt;-]]]; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
<span class="id">move</span>: <span class="id">Aco</span>; <span class="id">rewrite</span> -[<span class="id">A</span>]<span class="id">setIid</span> =&gt; /<span class="id">compact_subspaceIP</span>; <span class="id">rewrite</span> <span class="id">setIid</span>.<br/>
<span class="id">case</span> /(<span class="id">_</span> <span class="id">G</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>) =&gt; // ? [].<br/>
<span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">Ap</span> <span class="id">clsGp</span>]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">p</span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">imageP</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#image_preimage_subset">FB</a></span> /<span class="id">fcont</span> <span class="id">p_Cf</span>.<br/>
<span class="id">have</span> : <span class="id">G</span> (<span class="id">A</span> `&amp;` <span class="id">f</span> @^-1` <span class="id">B</span>) <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clsGp</span> /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">p_Cf</a></span>) [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">q</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_continuous_connected</span> (<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">A</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">connected</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof635')">Proof.</span></div>
<div class="proofscript" id="proof635">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">cA</a></span> <span class="id">cf</span>; <span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">connectedPn</span>[<span class="id">E</span> [<span class="id">E0</span> <span class="id">fAE</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">sE</a></span>]].<br/>
<span class="id">set</span> <span class="id">AfE</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt;(<span class="id">A</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">f</a></span> @^-1` <span class="id">E</span> <span class="id">b</span>) : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>).<br/>
<span class="id">suff</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous">sAfE</a></span> : <span class="id">separated</span> (<span class="id">AfE</span> <span class="id">false</span>) (<span class="id">AfE</span> <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">cA</span>; <span class="id">apply</span>/<span class="id">connectedPn</span>; <span class="kwd">exists</span> <span class="id">AfE</span>; <span class="id">split</span>; <span class="id">last</span> (<span class="id">rewrite</span> /<span class="id">AfE</span>; <span class="id">split</span>).<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; <span class="id">b</span>; <span class="id">case</span>: (<span class="id">E0</span> <span class="id">b</span>) =&gt; /= <span class="id">u</span> <span class="id">Ebu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [<span class="id">t</span> <span class="id">Et</span> <span class="id">ftu</span>] : (<span class="id">f</span> @` <span class="id">A</span>) <span class="id">u</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAE</span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">b</a></span> <span class="id">Ebu</span>; [<span class="id">right</span>|<span class="id">left</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">split</span> =&gt; //=; <span class="id">rewrite</span> /<span class="id">preimage</span> <span class="id">ftu</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setIUr</span> -<span class="id">preimage_setU</span> -<span class="id">fAE</span>; <span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">preimage_image</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> -{2}(<span class="id">setIid</span> <span class="id">A</span>) ?<span class="id">setIA</span> -(@<span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">closure_subspaceW</a></span> <span class="id">_</span> <span class="id">A</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?[].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id">AfE</span> <span class="id">false</span>) -<span class="id">setIA</span> -/(<span class="id">AfE</span> <span class="id">true</span>); <span class="id">case</span>: <span class="id">sAfE</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> -{1}(<span class="id">setIid</span> <span class="id">A</span>) <span class="id">setIC</span> ?<span class="id">setIA</span> -(@<span class="id">closure_subspaceW</span> <span class="id">_</span> <span class="id">A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id">AfE</span> <span class="id">true</span>) -<span class="id">setIA</span> -/(<span class="id">AfE</span> <span class="id">false</span>) <span class="id">setIC</span>; <span class="id">case</span>: <span class="id">sAfE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?[].<br/>
<span class="id">suff</span> <span class="id">cI0</span> <span class="id">b</span> : <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&amp;` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">separated</span> <span class="id">cI0</span> <span class="id">setIC</span> <span class="id">cI0</span>.<br/>
<span class="id">have</span> [<span class="id">fAfE</span> <span class="id">cEIE</span>] :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> @` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">E</span> (~~ <span class="id">b</span>) /\ <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>) `&amp;` <span class="id">E</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">case</span>: <span class="id">sE</span> =&gt; ? ?; <span class="id">case</span>: <span class="id">b</span> =&gt; //; <span class="id">rewrite</span> <span class="id">setIC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [|<span class="id">u</span> <span class="id">Ebu</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">sub_image_setI</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>; <span class="id">exact</span>: <span class="id">image_preimage_subset</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">t</span> [<span class="id">At</span> <span class="id">ftu</span>]] : <span class="kwd">exists</span> <span class="id">t</span>, <span class="id">A</span> <span class="id">t</span> /\ <span class="id">f</span> <span class="id">t</span> = <span class="id">u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> [<span class="id">t</span> <span class="id">At</span> <span class="id">ftu</span>] : (<span class="id">f</span> @` <span class="id"><a href="mathcomp.classical.functions.html#restrict">A</a></span>) <span class="id">u</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAE</span>; <span class="id">case</span>: <span class="id">b</span> <span class="id">Ebu</span>; [<span class="id">left</span>|<span class="id">right</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span> =&gt; //; <span class="id">split</span> =&gt; //=; <span class="id">rewrite</span> /<span class="id">preimage</span> <span class="id">ftu</span>.<br/>
<span class="id">have</span> ? : <span class="id">f</span> @` <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&lt;=` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> /(@<span class="id">image_subset</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">_</a></span> <span class="id">f</span>) : <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&lt;=` <span class="id">f</span> @^-1` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /<span class="id">closure_id</span> -&gt; : <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>) : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_comp</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">closure_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /(@<span class="id">preimage_subset</span> <span class="id">_</span> <span class="id">_</span> <span class="id">f</span>) <span class="id">A0cA0</span> := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">A0cA0</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">subset_trans</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">image_preimage_subset</span>.<br/>
<span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">negPn</span>/<span class="id">negP</span>/<span class="id">set0P</span> =&gt; -[<span class="id">t</span> [? ?]].<br/>
<span class="id">have</span> : <span class="id">f</span> @` <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&amp;` <span class="id">f</span> @` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAfE</span>; <span class="id">exact</span>: <span class="id">subsetI_eq0</span> <span class="id">cEIE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; /(<span class="id">_</span> (<span class="id">f</span> <span class="id">t</span>)) [<span class="id">fcAfEb</span>] <span class="id">_</span>; <span class="id">apply</span>: <span class="id">fcAfEb</span>; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">t</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_limit_continuous</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">continuous</span> (<span class="id">g</span> : <span class="id">U</span> -&gt; <span class="id">V</span>)) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; <span class="id">continuous</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof636')">Proof.</span></div>
<div class="proofscript" id="proof636">
<span class="id">move</span>=&gt; <span class="id">PF</span> <span class="id">ctsF</span> <span class="id">Ff</span> <span class="id">x</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">g</span>; <span class="id">near</span>=&gt; <span class="id">y</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">g</span>; <span class="id">apply</span>/<span class="id">Ff</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">A</span>); <span class="id">split</span> =&gt; // ?; <span class="id">exact</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">y</a></span>)) =&gt; //; <span class="id">near</span>: <span class="id">y</span>; <span class="id">near</span>: <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">ctsF</span>) =&gt; <span class="id">g</span> /(<span class="id">_</span> <span class="id">x</span>) /<span class="id">cvg_app_entourageP</span>; <span class="id">exact</span>.<br/>
<span class="id">apply</span>/<span class="id">Ff</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> (<span class="id">split_ent</span> <span class="id">A</span>))^-1%<span class="id">classic</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">entourage_inv</span> | <span class="id">move</span>=&gt; <span class="id">g</span> <span class="id">fg</span>; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">near_simpl</a></span>; <span class="id">near</span>=&gt; <span class="id">z</span>; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">exact</a></span>: <span class="id">fg</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_limit_continuous_subspace</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">K</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">K</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">continuous</span> (<span class="id">g</span> : <span class="id">subspace</span> <span class="id">K</span> -&gt; <span class="id">V</span>)) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">K</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">K</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof637')">Proof.</span></div>
<div class="proofscript" id="proof637">
<span class="id"><a href="mathcomp.analysis.topology.html#cvg_image">move</a></span>=&gt; <span class="id">PF</span> <span class="id">ctsF</span> <span class="id">Ff</span>; <span class="id">apply</span>: (@<span class="id">subspace_eq_continuous</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">restrict</span> <span class="id">K</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">rewrite</a></span> /<span class="id">restrict</span> =&gt; ? -&gt;.<br/>
<span class="id">apply</span>: (@<span class="id">uniform_limit_continuous</span><br/>
&nbsp;&nbsp;(<span class="id">subspace_topologicalType</span> <span class="id">K</span>) <span class="id">_</span> (<span class="id">restrict</span> <span class="id">K</span> @ <span class="id">F</span>) <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">ctsF</span>) =&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">subspace_eq_continuous</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniform_set1">rewrite</a></span> /<span class="id">restrict</span> =&gt; ? -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span> (@<span class="id">uniform_restrict_cvg</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F</span> ) =&gt; //; <span class="id">exact</span>: <span class="id">PF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_localP</span> {<span class="id">X</span> <span class="id">Y</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">X</span> -&gt; <span class="id">Y</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">x</span> : <span class="id">X</span>), \<span class="kwd">forall</span> <span class="id">U</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> (<span class="id">nbhs</span> <span class="id">x</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">within</span> <span class="id">U</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof638')">Proof.</span></div>
<div class="proofscript" id="proof638">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">near</span>=&gt; <span class="id">U</span>; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>=&gt; ?; <span class="id">exact</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">x</span> =&gt; /(<span class="id">_</span> <span class="id">x</span>)/<span class="id">near_powerset_filter_fromP</span>.<br/>
<span class="id">case</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id"><a href="mathcomp.analysis.topology.html#family_cvg_subset">exact</a></span>: <span class="id">continuous_subspaceW</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span> <span class="id">nbhsU</span> <span class="id">wctsf</span>; <span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">wctsf</span> <span class="id">nbhsU</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">nbhsU</span>; <span class="id"><a href="mathcomp.analysis.topology.html#UniformPointwise.V">rewrite</a></span> <span class="id">nbhsE</span> =&gt; -[] <span class="id">W</span> [<span class="id">oW</span> <span class="id">Wx</span> <span class="id">WU</span>] /(<span class="id">_</span> <span class="id">W</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">_</span> (<span class="id">continuous_subspaceW</span> <span class="id">WU</span> <span class="id">wctsf</span>)); <span class="id">apply</span> =&gt; //; <span class="kwd">exists</span> <span class="id">W</span>.<br/>
<span class="id">move</span>/<span class="id">nbhs_singleton</span>: <span class="id">nbhsU</span>; <span class="id">move</span>: <span class="id">x</span>; <span class="id">apply</span>/<span class="id">in_setP</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">continuous_open_subspace</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">totally_disconnected_prod</span> (<span class="id">I</span> : <span class="id">choiceType</span>)<br/>
&nbsp;&nbsp;(<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) (<span class="id">A</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">set</span> (<span class="id">T</span> <span class="id">i</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">totally_disconnected</span> (<span class="id"><a name="gauges.split_sym">A</a></span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;@<span class="id">totally_disconnected</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">f</a></span> =&gt; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof639')">Proof.</span></div>
<div class="proofscript" id="proof639">
<span class="id">move</span>=&gt; <span class="id">dsctAi</span> <span class="id">x</span> /= <span class="id">Aix</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? -&gt;; <span class="id">exact</span>: <span class="id"><a name="gauge">connected_component_refl</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">f</span> /= [<span class="id">C</span> /= [<span class="id">Cx</span> <span class="id">CA</span> <span class="id"><a href="mathcomp.analysis.topology.html#gauges.split_sym">ctC</a></span> <span class="id">Cf</span>]]; <span class="id">apply</span>/<span class="id">functional_extensionality_dep</span> =&gt; <span class="id">i</span>.<br/>
<span class="id">suff</span> : <span class="id">proj</span> <span class="id">i</span> @` <span class="id"><a href="mathcomp.analysis.topology.html#gauges.split_sym">C</a></span> `&lt;=` [<span class="id">set</span> <span class="id">x</span> <span class="id">i</span>] <span class="kwd">by</span> <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">rewrite</span> -(<span class="id">dsctAi</span> <span class="id">i</span>) // =&gt; <span class="id">Ti</span> ?; <span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">i</span> @` <span class="id">C</span>) =&gt; //.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#gauge">split</a></span>; [<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [<span class="id">r</span> <span class="id">Cr</span> &lt;-]; <span class="id">exact</span>: <span class="id">CA</span> |].<br/>
<span class="id">apply</span>/(<span class="id">connected_continuous_connected</span> <span class="id">ctC</span>)/<span class="id">continuous_subspaceT</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#filterS">exact</a></span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">UniformPointwise</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#Filter">V</a></span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">singletons</span> {<span class="id">T</span> : <span class="kwd">Type</span>} := [<span class="id">set</span> [<span class="id">set</span> <span class="id">x</span>] | <span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>: <span class="id">T</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_family_singleton</span> <span class="id">F</span> (<span class="id">f</span>: <span class="id">U</span> -&gt; <span class="id">V</span>):<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = {<span class="id">family</span> @<span class="id">singletons</span> <span class="id">U</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof640')">Proof.</span></div>
<div class="proofscript" id="proof640">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">propeqE</a></span> <span class="id">fam_cvgP</span> <span class="id">cvg_sup</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">A</span> [<span class="id">x</span> <span class="id">_</span> &lt;-] =&gt; /(<span class="id">_</span> <span class="id">x</span>); <span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span> =&gt; <span class="id">W</span> /=; <span class="id">rewrite</span> ?<span class="id">nbhs_simpl</span> /<span class="id">fmap</span> /= =&gt; [[<span class="id">W</span>' + &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">g</span> <span class="id">W</span>'<span class="id">g</span> /=; <span class="kwd">exists</span> <span class="id">g</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">i</span>; <span class="id">have</span> /[<span class="id">swap</span>] /[<span class="id">apply</span>] : <span class="id">singletons</span> [<span class="id">set</span> <span class="id">i</span>] <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
<span class="id">move</span>=&gt; + <span class="id">W</span> //=; <span class="id">rewrite</span> ?<span class="id">nbhs_simpl</span> =&gt; <span class="id">Q</span> =&gt; /<span class="id">Q</span> <span class="id">Q</span>'; <span class="kwd">exists</span> (@^~ <span class="id">i</span> @^-1` <span class="id"><a href="mathcomp.analysis.topology.html#gauges.entourage_gauge.E">W</a></span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [<span class="id">j</span> [? + &lt;-//]|<span class="id">j</span> <span class="id">Wj</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_compact_family</span> <span class="id">F</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">family</span> <span class="id">compact</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof641')">Proof.</span></div>
<div class="proofscript" id="proof641">
<span class="id">move</span>=&gt; <span class="id">PF</span>; <span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span>; <span class="id">apply</span>: <span class="id">family_cvg_subset</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">x</span> <span class="id">_</span> &lt;-]; <span class="id">exact</span>: <span class="id">compact_set1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvgP</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_split_ent">F</a></span> (<span class="id">f</span>: <span class="id">U</span> -&gt; <span class="id">V</span>):<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; <span class="kwd">forall</span> (<span class="id">t</span> : <span class="id">U</span>), (<span class="kwd">fun</span> <span class="id">g</span> =&gt; <span class="id">g</span> <span class="id">t</span>) @ <span class="id">F</span> --&gt; <span class="id">f</span> <span class="id">t</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof642')">Proof.</span></div>
<div class="proofscript" id="proof642">
<span class="id">move</span>=&gt; <span class="id">Ff</span>; <span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">fam_cvgP</span> =&gt; + <span class="id">t</span> <span class="id">A</span> <span class="id">At</span> =&gt; /(<span class="id">_</span> [<span class="id">set</span> <span class="id">t</span>]); <span class="id">rewrite</span> <span class="id">uniform_set1</span>; <span class="id">apply</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">pf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; ? [<span class="id">t</span> <span class="id">_</span> &lt;-]; <span class="id">rewrite</span> <span class="id">uniform_set1</span>; <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">exact</a></span>: <span class="id">pf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">UniformPointwise</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">gauges</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">split_sym</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">W</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;(<span class="id">split_ent</span> <span class="id">W</span>) `&amp;` (<span class="id">split_ent</span> <span class="id">W</span>)^-1.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">entourage_gauge</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">E</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) (<span class="id">entE</span> : <span class="id">entourage</span> <span class="id">E</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> [<span class="id">set</span>: <span class="id">nat</span>] (<span class="kwd">fun</span> <span class="id">n</span> =&gt; <span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#gauges.entourage_gauge.E">iter_split_ent</a></span> <span class="id">j</span> : <span class="id">entourage</span> (<span class="id">iter</span> <span class="id">j</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof643')">Proof.</span></div>
<div class="proofscript" id="proof643">
 <span class="kwd">by</span> <span class="id">elim</span>: <span class="id">j</span> =&gt; [|<span class="id">i</span> <span class="id">IH</span>]; <span class="id">exact</span>: <span class="id">filterI</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_ent</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof644')">Proof.</span></div>
<div class="proofscript" id="proof644">
<span class="id">case</span>=&gt; <span class="id">n</span>; <span class="id"><a name="gauge_pseudoMetric_mixin">elim</a></span>: <span class="id">n</span> <span class="id">A</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">_</span> /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> ? <span class="id">A</span> <span class="id">_</span> /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">have</span> ? := <span class="id">iter_split_ent</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_filter</span> : <span class="id">Filter</span> <span class="id">gauge</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof645')">Proof.</span></div>
<div class="proofscript" id="proof645">
<span class="id"><a href="mathcomp.analysis.topology.html#gauge_uniformType">apply</a></span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="id">wlog</span> <span class="id">ilej</span> : <span class="id">i</span> <span class="id"><a name="uniform_pseudometric_sup">j</a></span> / (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">WH</span>; <span class="id">have</span> [|/<span class="id">ltnW</span>] := <span class="id">leqP</span> <span class="id">i</span> <span class="id">j</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[|<span class="id"><a href="mathcomp.analysis.topology.html#entourage">rewrite</a></span> (<span class="id">setIC</span> (<span class="id">iter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>))]; <span class="id">exact</span>: <span class="id">WH</span>.<br/>
<span class="kwd">exists</span> <span class="id">j</span> =&gt; //; <span class="id">rewrite</span> <span class="id">subsetI</span>; <span class="id">split</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#gauge_pseudoMetricType">elim</a></span>: <span class="id">j</span> <span class="id">i</span> <span class="id">ilej</span> =&gt; [<span class="id">i</span>|<span class="id">j</span> <span class="id">IH</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">i</a></span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[&lt;-//|/<span class="id">ltnSE</span>/<span class="id">IH</span>]; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span>/= [<span class="id">jx</span> <span class="id">_</span>]; <span class="id">apply</span>: <span class="id">split_ent_subset</span> =&gt; //; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_refl</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof646')">Proof.</span></div>
<div class="proofscript" id="proof646">
<span class="id">case</span>=&gt; <span class="id">n</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">subset_trans</span> =&gt; -[<span class="id">_</span> <span class="id">a</span>]/= -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_refl</span>; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset1">gauge_inv</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set1">A</a></span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; <span class="id">gauge</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof647')">Proof.</span></div>
<div class="proofscript" id="proof647">
<span class="id">case</span>=&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">EA</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1))).<br/>
- <span class="id">exact</span>: <span class="id">gauge_filter</span>.<br/>
- <span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> <span class="id">EA</span>; <span class="id">last</span> <span class="id"><a href="mathcomp.analysis.topology.html#iter_split_ent">move</a></span>=&gt; <span class="id">n</span>; <span class="id">move</span>=&gt; <span class="id">EA</span> [? ?] [/=] ? ?; <span class="id">exact</span>: <span class="id">EA</span>.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span> .<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_split</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">gauge</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof648')">Proof.</span></div>
<div class="proofscript" id="proof648">
<span class="id">case</span> =&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">EA</span>; <span class="kwd">exists</span> (<span class="id">iter</span> <span class="id">n</span>.+1 <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">EA</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="ArzelaAscoli">apply</a></span>: <span class="id">subset_split_ent</span>; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">a</a></span> <span class="id">c</span> [<span class="id">b</span>] [] ? ? [] ? ?; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">b</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_uniformType_mixin</span> :=<br/>
&nbsp;<span class="id">UniformMixin</span> <span class="id">gauge_filter</span> <span class="id">gauge_refl</span> <span class="id">gauge_inv</span> <span class="id">gauge_split</span> <span class="id">erefl</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_topologicalTypeMixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfEntourageMixin</span> <span class="id">gauge_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_filtered</span> := <span class="id">FilteredType</span> <span class="id">T</span> <span class="id">T</span> (<span class="id">nbhs_</span> <span class="id">gauge</span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">gauge_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">gauge_filtered</span> <span class="id">gauge_topologicalTypeMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">gauge_uniformType</span> := <span class="id">UniformType</span><br/>
&nbsp;&nbsp;<span class="id">gauge_topologicalType</span> <span class="id">gauge_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_countable_uniformity</span> : <span class="id">countable_uniformity</span> <span class="id">gauge_uniformType</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof649')">Proof.</span></div>
<div class="proofscript" id="proof649">
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1) | <span class="id">n</span> <span class="kwd">in</span> [<span class="id">set</span>: <span class="id">nat</span>]].<br/>
<span class="id">split</span>; [<span class="id">exact</span>: <span class="id">card_image_le</span> | <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">W</span> [<span class="id">n</span>] <span class="id">_</span> &lt;-; <span class="kwd">exists</span> <span class="id">n</span>|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">D</span> [<span class="id">n</span> <span class="id"><a name="equicontinuous_subset_id">_</a></span> ?]; <span class="kwd">exists</span> (<span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">E</a></span> `&amp;` <span class="id">E</span>^-1)).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_pseudoMetric_mixin</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;@<span class="id">countable_uniform_pseudoMetricType_mixin</span> <span class="id">R</span> <span class="id">_</span> <span class="id">gauge_countable_uniformity</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_pseudoMetricType</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">gauge_uniformType</span> (@<span class="id">gauge_pseudoMetric_mixin</span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id">entourage_gauge</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_pseudometric_sup</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">uniformType</span>} :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">entourage</span> <span class="id">T</span> = @<span class="id">sup_ent</span> <span class="id">T</span> {<span class="id">E</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | @<span class="id">entourage</span> <span class="id">T</span> <span class="id">E</span>}<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">E</span> =&gt; <span class="id">Uniform.class</span> (@<span class="id">gauge_pseudoMetricType</span> <span class="id">T</span> (<span class="id">projT1</span> <span class="id">E</span>) (<span class="id">projT2</span> <span class="id">E</span>) <span class="id">R</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof650')">Proof.</span></div>
<div class="proofscript" id="proof650">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [<span class="id">E</span> <span class="id">entE</span>|<span class="id">E</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">pe</span> : {<span class="id">classic</span> {<span class="id">E0</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | <span class="id">_</span>}} * <span class="id">_</span> := (<span class="id">exist</span> <span class="id">_</span> <span class="id">E</span> <span class="id">entE</span>, <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">entPE</span> : `[&lt; @<span class="id">entourage</span> (<span class="id">gauge_uniformType</span> <span class="id">entE</span>) <span class="id">E</span> &gt;].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="kwd">exists</span> 0%<span class="id">N</span> =&gt; // ? [].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">fset1</span> (<span class="id">exist</span> <span class="id">_</span> <span class="id">pe</span> <span class="id">entPE</span>)) =&gt; //=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id">in_setE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_fset1</span> <span class="id">bigcap_set1</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">W</span> /= [/= <span class="id">J</span>] <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">_</a></span> &lt;- /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; -[] [] [] /= <span class="id">D</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entD</span> <span class="id">G</span> /[<span class="id">dup</span>] /<span class="id">asboolP</span> [<span class="id">n</span> <span class="id">_</span> + <span class="id">_</span> <span class="id">_</span>] =&gt; /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">gauges</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">normal_space</span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_precompact">topologicalType</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id">closed</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_nbhs</span> <span class="id">A</span> `&lt;=` <span class="id">filter_from</span> (<span class="id">set_nbhs</span> <span class="id">A</span>) <span class="id">closure</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">regular_space</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> : <span class="id">T</span>, <span class="id">nbhs</span> <span class="id">a</span> `&lt;=` <span class="id">filter_from</span> (<span class="id">nbhs</span> <span class="id">a</span>) <span class="id">closure</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ArzelaAscoli</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Context</span> {<span class="id">Y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">uniformType</a></span>}.<br/>
<span class="kwd">Context</span> {<span class="id">hsdf</span> : <span class="id">hausdorff_space</span> <span class="id">Y</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">I</a></span> : <span class="kwd">Type</span>).<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">equicontinuous</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">d</span> : <span class="id"><a href="mathcomp.analysis.topology.html#tychonoff">I</a></span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id">Y</span> * <span class="id">Y</span>)), <span class="id">entourage</span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">x</span>, <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">W</span> <span class="id">i</span> -&gt; <span class="id">E</span>(<span class="id">d</span> <span class="id">i</span> <span class="id">x</span>, <span class="id">d</span> <span class="id">i</span> <span class="id">y</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_subset</span> {<span class="id">I</span> <span class="id">J</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">V</span> : <span class="id">set</span> <span class="id">J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id"><a href="mathcomp.analysis.topology.html#closure_limit_point">fW</a></span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} {<span class="id">fV</span> : <span class="id">J</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} :<br/>
&nbsp;&nbsp;<span class="id">fW</span> @`<span class="id">W</span> `&lt;=` <span class="id">fV</span> @` <span class="id">V</span> -&gt; <span class="id">equicontinuous</span> <span class="id">V</span> <span class="id">fV</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">equicontinuous</a></span> <span class="id">W</span> <span class="id">fW</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof651')">Proof.</span></div>
<div class="proofscript" id="proof651">
<span class="id">move</span>=&gt; <span class="id">WsubV</span> + <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>); <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">y</span> <span class="id">VE</span> <span class="id">i</span> <span class="id">Wi</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">WsubV</span> (<span class="id">fW</span> <span class="id">i</span>)); [<span class="kwd">exists</span> <span class="id">i</span> | <span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">Vj</span> &lt;-; <span class="id">exact</span>: <span class="id">VE</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_subset_id</span> (<span class="id">W</span> <span class="id">V</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">W</span> `&lt;=` <span class="id">V</span> -&gt; <span class="id">equicontinuous</span> <span class="id">V</span> <span class="id">id</span> -&gt; <span class="id">equicontinuous</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_ultra">W</a></span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof652')">Proof.</span></div>
<div class="proofscript" id="proof652">
<span class="id">move</span>=&gt; <span class="id">WsubV</span>; <span class="id">apply</span>: <span class="id">equicontinuous_subset</span> =&gt; ? [<span class="id">y</span> ? &lt;- /=]; <span class="kwd">exists</span> <span class="id">y</span> =&gt; //.<br/>
<span class="id">exact</span>: <span class="id">WsubV</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_continuous_for</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">fW</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>) <span class="id">i</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">fW</a></span>} -&gt; <span class="id">W</span> <span class="id">i</span> -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> (<span class="id">fW</span> <span class="id">i</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof653')">Proof.</span></div>
<div class="proofscript" id="proof653">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> <span class="id">Wf</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">E</span> <span class="id">entE</span>; <span class="id">near_simpl</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">near</a></span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">_</span> <span class="id">entE</span>) <span class="id">y</span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#continuous_compact">Unshelve</a></span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_continuous</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">fW</span> : <span class="id">I</span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) (<span class="id">i</span> : <span class="id">I</span>) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">fW</span> -&gt; <span class="id">W</span> <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_cvg_compact_family">i</a></span> -&gt; <span class="id">continuous</span> (<span class="id">fW</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof654')">Proof.</span></div>
<div class="proofscript" id="proof654">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> <span class="id">Wf</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">equicontinuous_continuous_for</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Wf</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">ectsW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">pointwise_precompact</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">d</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">precompact</span> [<span class="id">set</span> (<span class="id">d</span> <span class="id">i</span> <span class="id">x</span>) | <span class="id">i</span> <span class="kwd">in</span> <span class="id">W</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_subset</span> {<span class="id">I</span> <span class="id">J</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">V</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">J</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">fW</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} {<span class="id">fV</span> : <span class="id">J</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} :<br/>
&nbsp;&nbsp;<span class="id">fW</span> @` <span class="id">W</span> `&lt;=` <span class="id">fV</span> @` <span class="id">V</span> -&gt; <span class="id">pointwise_precompact</span> <span class="id">V</span> <span class="id">fV</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">fW</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof655')">Proof.</span></div>
<div class="proofscript" id="proof655">
<span class="id">move</span>=&gt; <span class="id">WsubV</span> + <span class="id">x</span> =&gt; /(<span class="id">_</span> <span class="id">x</span>) <span class="id">pcptV</span>; <span class="id">apply</span>: <span class="id">precompact_subset</span> <span class="id">pcptV</span> =&gt; <span class="id">y</span> [<span class="id">i</span> <span class="id">Wi</span> &lt;-].<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">WsubV</span> (<span class="id">fW</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">i</a></span>)); [<span class="kwd">exists</span> <span class="id">i</span> | <span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">Vj</span> &lt;-; <span class="kwd">exists</span> <span class="id">j</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_precompact</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">fW</a></span> : <span class="id">I</span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">fW</span> -&gt; <span class="id">precompact</span> ((<span class="id">fW</span> @` <span class="id">W</span>) : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof656')">Proof.</span></div>
<div class="proofscript" id="proof656">
<span class="id">rewrite</span> <span class="id">precompactE</span> =&gt; <span class="id">ptwsPreW</span>.<br/>
<span class="id">pose</span> <span class="id">K</span> := <span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">closure</span> [<span class="id">set</span> <span class="id">fW</span> <span class="id">i</span> <span class="id">x</span> | <span class="id">i</span> <span class="kwd">in</span> <span class="id">W</span>].<br/>
<span class="id">set</span> <span class="id">R</span> := [<span class="id">set</span> <span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#near">Y</a></span>} | <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">X</span>, <span class="id">K</span> <span class="id">x</span> (<span class="id">f</span> <span class="id">x</span>)].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">have</a></span> <span class="id">C</span> : <span class="id">compact</span> <span class="id">R</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">tychonoff</span> =&gt; <span class="id">x</span>; <span class="id">rewrite</span> -<span class="id">precompactE</span>; <span class="id">move</span>: <span class="id">ptwsPreW</span>; <span class="id">exact</span>.<br/>
<span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">C</span>); <span class="id"><a href="mathcomp.analysis.topology.html#small_set_sub">first</a></span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">have</span> <span class="id">WsubR</span> : (<span class="id">fW</span> @` <span class="id">W</span>) `&lt;=` <span class="id">R</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">f</span> <span class="id">Wf</span> <span class="id">x</span>; <span class="id">rewrite</span> /<span class="id">R</span> /<span class="id">K</span> <span class="id">closure_limit_point</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">Wf</span> =&gt; <span class="id">i</span> ? &lt;-; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">rewrite</span> <span class="id">closureE</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">smallest_sub</a></span> (<span class="id">compact_closed</span> <span class="id">_</span> <span class="id">C</span>) <span class="id">WsubR</span>.<br/>
<span class="id">exact</span>: <span class="id">hausdorff_product</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_pointwise_compact</span> (<span class="id">W</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> (@<span class="id">fct_UniformFamily</span> <span class="id">X</span> <span class="id">Y</span> <span class="id">compact</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof657')">Proof.</span></div>
<div class="proofscript" id="proof657">
<span class="id">rewrite</span> [<span class="id">x</span> <span class="kwd">in</span> <span class="id">x</span> <span class="id">_</span> -&gt; <span class="id">_</span>]<span class="id">compact_ultra</span> [<span class="id">x</span> <span class="kwd">in</span> <span class="id">_</span> -&gt; <span class="id">x</span> <span class="id">_</span>]<span class="id">compact_ultra</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">F</span> <span class="id">UF</span> <span class="id">FW</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span> <span class="id">FW</span>) [<span class="id">h</span> [<span class="id">Wh</span> <span class="id">Fh</span>]]; <span class="kwd">exists</span> <span class="id">h</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">Q</a></span> <span class="id">Fq</span>; <span class="id">apply</span>: (<span class="id">pointwise_cvg_compact_family</span> <span class="id">_</span> <span class="id">Fh</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_pointwise_precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">precompact</span> <span class="id">W</span> -&gt; <span class="id">pointwise_precompact</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">W</a></span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof658')">Proof.</span></div>
<div class="proofscript" id="proof658">
<span class="id">move</span>=&gt; + <span class="id">x</span>; <span class="id">rewrite</span> ?<span class="id">precompactE</span> =&gt; <span class="id">pcptW</span>.<br/>
<span class="id">have</span> : <span class="id">compact</span> (<span class="id">proj</span> <span class="id">x</span> @` (<span class="id">closure</span> <span class="id">W</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">continuous_compact</span> =&gt; //; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>=&gt; <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">E</span> <span class="id">nbhsE</span>; <span class="id">have</span> := (@<span class="id">proj_continuous</span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">g</span> <span class="id">E</span> <span class="id">nbhsE</span>).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (@<span class="id">pointwise_cvg_compact_family</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">g</span>)).<br/>
<span class="id">move</span>=&gt; /[<span class="id">dup</span>]/(<span class="id">compact_closed</span> <span class="id">hsdf</span>)/<span class="id">closure_id</span> -&gt; /<span class="id">subclosed_compact</span>.<br/>
<span class="id">apply</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">closure_subset</span>/<span class="id">image_subset</span>; <span class="id">exact</span>: (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">W</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_entourage</span> (<span class="id">x</span> : <span class="id">X</span>) (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) <span class="id">E</span> :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; \<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">g</a></span> \<span class="id">near</span> <span class="id">f</span>, <span class="id">E</span> (<span class="id">f</span> <span class="id">x</span>, <span class="id">g</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof659')">Proof.</span></div>
<div class="proofscript" id="proof659">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">have</span> : ({<span class="id">ptws</span>, <span class="id">nbhs</span> <span class="id">f</span> --&gt; <span class="id">f</span>}) <span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span> =&gt; /<span class="id">fam_cvgP</span> /(<span class="id">_</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
<span class="id">rewrite</span> <span class="id">uniform_set1</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">E</span> (<span class="id">f</span> <span class="id">x</span>))); <span class="id">apply</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">move</a></span>: <span class="id">E</span> <span class="id">entE</span>; <span class="id">exact</span>/<span class="id">cvg_entourageP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt; <span class="id">equicontinuous</span> (<span class="id">closure</span> <span class="id">W</span>) <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof660')">Proof.</span></div>
<div class="proofscript" id="proof660">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> =&gt; <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>; <span class="id">near</span>=&gt; <span class="id">y</span> =&gt; <span class="id">f</span> <span class="id">clWf</span>.<br/>
<span class="id"><a name="pointwise_compact_closure">near</a></span> (<span class="id">within</span> <span class="id">W</span> (<span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}))) =&gt; <span class="id">g</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">near</a></span>: <span class="id">g</span>; <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">near_withinE</a></span>; <span class="id">near_simpl</span>; <span class="id">near</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#compact">g</a></span> =&gt; <span class="id">Wg</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">apply</a></span>: (@<span class="id">entourage_split</span> <span class="id">_</span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">apply</span>: (@<span class="id">entourage_split</span> <span class="id">_</span> (<span class="id">g</span> <span class="id">y</span>)) =&gt; //; <span class="id">first</span> <span class="id">exact</span>: (<span class="id">near</span> (@<span class="id">ectsW</span> <span class="id">x</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_compact_cvg">_</a></span>)).<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">entourage_sym</span>; <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">small_ent_sub</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#pointwise_compact_cvg">small_set_sub</a></span> <span class="id">_</span> <span class="id">_</span> (@<span class="id">entourage</span> <span class="id">Y</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_compact_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>})) (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">W</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> <span class="id">F</span>, <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">family</span> <span class="id">compact</span>, <span class="id">F</span> --&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">f</a></span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof661')">Proof.</span></div>
<div class="proofscript" id="proof661">
<span class="id">move</span>=&gt; <span class="id">PF</span> /<span class="id">near_powerset_filter_fromP</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">case</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">W</span>; <span class="id">wlog</span> <span class="id">Wf</span> : <span class="id">f</span> <span class="id">W</span> / <span class="id">W</span> <span class="id">f</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id"><a href="mathcomp.analysis.topology.html#compact_ultra">FW</a></span> /<span class="id">equicontinuous_closure</span> =&gt; /(<span class="id">_</span> <span class="id">f</span> (<span class="id">closure</span> <span class="id">W</span>)) <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span> =&gt; <span class="id">Ff</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">pointwise_cvg_compact_family</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Q</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> (<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">FW</span>); <span class="id">exact</span>: <span class="id">subset_closure</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEcvg</span>; <span class="kwd">exists</span> <span class="id">F</span>; [|<span class="id">split</span>] =&gt; // ? /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">FW</span> <span class="id">ectsW</span>; <span class="id">split</span>=&gt; [<span class="id">ptwsF</span>|]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">pointwise_cvg_compact_family</span>.<br/>
<span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">K</span> ? <span class="id">U</span> /=; <span class="id">rewrite</span> <span class="id">uniform_nbhs</span> =&gt; [[<span class="id">E</span> [<span class="id">eE</span> <span class="id">EsubU</span>]]].<br/>
<span class="id">suff</span> : \<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">within</span> <span class="id">W</span> (<span class="id">nbhs</span> <span class="id">f</span>), <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">K</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">y</a></span>, <span class="id">g</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">near_withinE</span>; <span class="id">near_simpl</span> =&gt; <span class="id">N</span>; <span class="id">apply</span>: (<span class="id">filter_app</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">_</a></span> <span class="id">FW</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ptwsF</span>; <span class="id">near</span>=&gt; <span class="id">g</span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">EsubU</a></span>; <span class="id">apply</span>: (<span class="id">near</span> <span class="id">N</span> <span class="id">g</span>).<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (@<span class="id">entourage</span> <span class="id">Y</span>)) =&gt; <span class="id">E</span>'.<br/>
<span class="id">have</span> <span class="id">entE</span>' : <span class="id">entourage</span> <span class="id">E</span>' <span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">near_small_set</span> <span class="id">_</span>)).<br/>
<span class="id">pose</span> <span class="id">Q</span> := <span class="kwd">fun</span> (<span class="id">h</span> : <span class="id">X</span> -&gt; <span class="id">Y</span>) <span class="id">x</span> =&gt; <span class="id">E</span>' (<span class="id">f</span> <span class="id">x</span>, <span class="id">h</span> <span class="id">x</span>).<br/>
<span class="id">apply</span>: (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">K</span>)) =&gt; // <span class="id">x</span> <span class="id">Kx</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">y</span> <span class="id">g</span> =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">eE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">entourage_sym</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">x</span> <span class="id">E</span>' <span class="id">entE</span>') <span class="id">y</span>).<br/>
<span class="id">apply</span>: (@<span class="id">entourage_split</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">_</a></span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">near</span>: <span class="id">g</span>; <span class="id">near_simpl</span>; <span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#compact_set1">cvg_within</a></span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">pointwise_cvg_entourage</span>.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">x</span> <span class="id">E</span>' <span class="id">entE</span>')) =&gt; //.<br/>
<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">withinT</span> <span class="id">_</span> (<span class="id">nbhs_filter</span> <span class="id">f</span>))).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_compact_closure</span> (<span class="id">W</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) =<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof662')">Proof.</span></div>
<div class="proofscript" id="proof662">
<span class="id">rewrite</span> ?<span class="id">closureEcvg</span> // <span class="id">predeqE</span> =&gt; ? ?.<br/>
<span class="id">split</span>; <span class="id">move</span>=&gt; [<span class="id">F</span> <span class="id">PF</span> [<span class="id">Fx</span> <span class="id">WF</span>]]; (<span class="kwd">exists</span> <span class="id">F</span>; <span class="id">last</span> <span class="id">split</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>/@<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">pointwise_compact_cvg</a></span> =&gt; //; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span> =&gt; //; <span class="id">exact</span>: <span class="id">WF</span>.<br/>
<span class="id">apply</span>/@<span class="id">pointwise_compact_cvg</span> =&gt; //; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span> =&gt; //; <span class="id">exact</span>: <span class="id">WF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_equicontinuous</span> (<span class="id"><a href="mathcomp.analysis.topology.html#continuous">W</a></span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_powerset_filter_fromP">compact</a></span>, <span class="id">X</span> -&gt; <span class="id">Y</span> }).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof663')">Proof.</span></div>
<div class="proofscript" id="proof663">
<span class="id">move</span>=&gt; /<span class="id">pointwise_precompact_precompact</span> + <span class="id">ectsW</span>.<br/>
<span class="id">rewrite</span> ?<span class="id">precompactE</span> <span class="id">compact_ultra</span> <span class="id">compact_ultra</span> <span class="id">pointwise_compact_closure</span> //.<br/>
<span class="id">move</span>=&gt; /= + <span class="id">F</span> <span class="id">UF</span> <span class="id">FcW</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span>); <span class="id">rewrite</span> <span class="id">image_id</span>; <span class="id">case</span> =&gt; // <span class="id">p</span> [<span class="id">cWp</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous_subspaceT">Fp</a></span>].<br/>
<span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>/(<span class="id">pointwise_compact_cvg</span>) =&gt; //.<br/>
<span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span> })) =&gt; //; <span class="id">exact</span>: <span class="id">equicontinuous_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">precompact_equicontinuous</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">lcptX</span> : <span class="id">locally_compact</span> [<span class="id"><a href="mathcomp.analysis.topology.html#continuous">set</a></span>: <span class="id">X</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">compact_equicontinuous</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">X</a></span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous_continuous">Y</a></span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof664')">Proof.</span></div>
<div class="proofscript" id="proof664">
<span class="id">move</span>=&gt; <span class="id">ctsW</span> <span class="id">cptW</span> <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>.<br/>
<span class="id">have</span> [//|<span class="id">U</span> <span class="id">UWx</span> [<span class="id">cptU</span> <span class="id">clU</span>]] := @<span class="id">lcptX</span> <span class="id">x</span>; <span class="id">rewrite</span> <span class="id">withinET</span> <span class="kwd">in</span> <span class="id">UWx</span>.<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (@<span class="id">entourage</span> <span class="id">Y</span>)) =&gt; <span class="id">E</span>'.<br/>
<span class="id">have</span> <span class="id">entE</span>' : <span class="id">entourage</span> <span class="id">E</span>' <span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">near_small_set</span> <span class="id">_</span>)).<br/>
<span class="id">pose</span> <span class="id">Q</span> := <span class="kwd">fun</span> (<span class="id">y</span> : <span class="id">X</span>) (<span class="id">f</span> : {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) =&gt; <span class="id">E</span>' (<span class="id">f</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">y</span>).<br/>
<span class="id">apply</span>: (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">W</span>)) =&gt; // <span class="id">f</span> <span class="id">Wf</span>; <span class="id">near</span>=&gt; <span class="id">g</span> <span class="id">y</span> =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">entE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">entourage_sym</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">fam_nbhs</span> <span class="id">_</span> <span class="id">entE</span>' (@<span class="id">compact_set1</span> <span class="id">_</span> <span class="id">x</span>)) <span class="id">g</span>).<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">y</span>) (<span class="id">entourage_split_ent</span> <span class="id">entE</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">y</span>; <span class="id">apply</span>: ((@<span class="id">ctsW</span> <span class="id">f</span> <span class="id">Wf</span> <span class="id">x</span>) (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)); <span class="id">exact</span>: <span class="id">nbhs_entourage</span>.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">fam_nbhs</span> <span class="id">_</span> <span class="id">entE</span>' <span class="id">cptU</span>) <span class="id">g</span>) =&gt; //; <span class="id">exact</span>: (<span class="id">near</span> <span class="id">UWx</span> <span class="id">y</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_equicontinuous</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof665')">Proof.</span></div>
<div class="proofscript" id="proof665">
<span class="id">move</span>=&gt; <span class="id">pcptW</span> <span class="id">ctsW</span>; <span class="id">apply</span>: (<span class="id">equicontinuous_subset_id</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">W</span>)).<br/>
<span class="id">apply</span>: <span class="id">compact_equicontinuous</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">precompactE</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">f</span>; <span class="id">rewrite</span> <span class="id">closureEcvg</span> =&gt; [[<span class="id">G</span> <span class="id">PG</span> [<span class="id">Gf</span> <span class="id">GW</span>]]] <span class="id">x</span> <span class="id">B</span> /=.<br/>
<span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; -[<span class="id">E</span> <span class="id">entE</span>] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">near_simpl</span>.<br/>
<span class="id">suff</span> <span class="id">ctsf</span> : <span class="id">continuous</span> <span class="id">f</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">E</span> <span class="id">entE</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span>; <span class="id">exact</span>: <span class="id">ctsf</span>.<br/>
<span class="id">apply</span>/<span class="id">continuous_localP</span> =&gt; <span class="id">x</span>'; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>: <span class="id">continuous_subspaceW</span>.<br/>
<span class="id">case</span>: (@<span class="id">lcptX</span> <span class="id">x</span>') =&gt; // <span class="id">U</span>; <span class="id">rewrite</span> <span class="id">withinET</span> =&gt; <span class="id">nbhsU</span> [<span class="id">cptU</span> <span class="id">_</span>].<br/>
<span class="kwd">exists</span> <span class="id">U</span> =&gt; //; <span class="id">apply</span>: (<span class="id">uniform_limit_continuous_subspace</span> <span class="id">PG</span> <span class="id">_</span> <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>; <span class="id">near</span>: <span class="id">g</span>; <span class="id">exact</span>: <span class="id">GW</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">fam_cvgP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">cptU</span>) : <span class="id">Gf</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">precompact_equicontinuous</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">Ascoli</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">locally_compact</span> [<span class="id">set</span>: <span class="id">X</span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">id</span> /\ <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof666')">Proof.</span></div>
<div class="proofscript" id="proof666">
<span class="id">move</span>=&gt; <span class="id">lcpt</span>; <span class="id">split</span> =&gt; [[<span class="id">Wid</span> <span class="id">ectsW</span>]|[<span class="id">fWf</span>]<span class="id">pcptW</span>].<br/>
&nbsp;&nbsp;<span class="id">split</span>=&gt; [?|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">equicontinuous_continuous</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">pointwise_precompact_equicontinuous</span>.<br/>
<span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">precompact_equicontinuous</span>.<br/>
<span class="id">exact</span>: <span class="id">precompact_pointwise_precompact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">ArzelaAscoli</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/tree/yoshihiro503%40generate_index">a fork of coq2html</a></div>
</body>
</html>
